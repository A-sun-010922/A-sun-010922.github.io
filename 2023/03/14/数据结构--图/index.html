

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/1.png">
  <link rel="icon" href="/img/1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Sugar">
  <meta name="keywords" content="">
  
    <meta name="description" content="数据结构—图一、图的定义1.1 顶点与边图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V，E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。 无向边：若顶点vi到vj之间的边没有方向，则称这条边为无向边，用无序偶对(vi,vj)来表示 如果图中任意两个顶点之间的边都是无向边，则称这个图为无向图。 有向边：若从顶点vi到vj的边有方向，则称这条边为有向边，也称为弧">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构--图">
<meta property="og:url" content="http://sugar-122.github.io/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数据结构—图一、图的定义1.1 顶点与边图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V，E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。 无向边：若顶点vi到vj之间的边没有方向，则称这条边为无向边，用无序偶对(vi,vj)来表示 如果图中任意两个顶点之间的边都是无向边，则称这个图为无向图。 有向边：若从顶点vi到vj的边有方向，则称这条边为有向边，也称为弧">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://sugar-122.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE.png">
<meta property="article:published_time" content="2023-03-14T11:43:09.491Z">
<meta property="article:modified_time" content="2023-03-20T12:37:45.653Z">
<meta property="article:author" content="Sugar">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://sugar-122.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE.png">
  
  
  
  <title>数据结构--图 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"sugar-122.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Sugar</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="数据结构--图"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-14 19:43" pubdate>
          2023年3月14日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          56 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据结构--图</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="数据结构—图"><a href="#数据结构—图" class="headerlink" title="数据结构—图"></a>数据结构—图</h1><h2 id="一、图的定义"><a href="#一、图的定义" class="headerlink" title="一、图的定义"></a>一、图的定义</h2><h3 id="1-1-顶点与边"><a href="#1-1-顶点与边" class="headerlink" title="1.1 顶点与边"></a>1.1 顶点与边</h3><p>图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V，E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p>
<p><strong>无向边：</strong>若顶点vi到vj之间的边没有方向，则称这条边为无向边，用无序偶对(vi,vj)来表示</p>
<p>如果图中任意两个顶点之间的边都是无向边，则称这个图为无向图。</p>
<p><strong>有向边：</strong>若从顶点vi到vj的边有方向，则称这条边为有向边，也称为弧</p>
<p>无向边用小括号“（）”表示，而有向边则是用尖括号“&lt;&gt;”表示</p>
<p>在无向图中，如果任意两个顶点之间都存在边，则称该图为<strong>无向完全图</strong>。含有n个顶点的无向完全图有n×(n-1)/2条边</p>
<p>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n×(n-1)条边。</p>
<p>有很少条边或者弧的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong></p>
<p>有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。<strong>带权的图通常称为网</strong>。</p>
<p>对于无向图G=（V,{E})，如果边（v,v’)∈E，则称顶点v和v’互为邻接点，即v和v’相邻接。边（v,v’)依附于顶点v和v’，或者说（v,v’)与顶点v和v‘相关联。<strong>顶点v的度是和v相关联的边的数目。</strong></p>
<p>以顶点v为头的弧的数目称为v的入度，记为ID(v)；</p>
<p>以v为尾的弧的数目称为v的出度，记为OD(v)</p>
<p>顶点v的度为TD(v)=ID(v)+OD(v)</p>
<p><strong>路径的长度是路径上的边或弧的数目</strong></p>
<p><strong>第一个顶点到最后一个顶点相同的路径称为回路或环</strong></p>
<p><strong>序列中顶点不重复出现的路径称为简单路径</strong></p>
<p>除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或者简单环</p>
<h3 id="1-2-连通图"><a href="#1-2-连通图" class="headerlink" title="1.2 连通图"></a>1.2 连通图</h3><p>在无向图G中，如果顶点v到顶点v’有路径，则称v和v’是连通的。</p>
<p>如果对于图中任意两个顶点vi、vj∈E，vi和vj都是连通的，则称G是连通图</p>
<p><strong>连通分量</strong>：无向图中的极大连通子图称为连通分量</p>
<p>（1）要是子图</p>
<p>（2）子图要是连通的</p>
<p>（3）连通子图含有极大顶点数</p>
<p>（4）具有极大顶点数的连通子图包含依附于这些顶点的所有边</p>
<h2 id="二、图的存储结构"><a href="#二、图的存储结构" class="headerlink" title="二、图的存储结构"></a>二、图的存储结构</h2><h3 id="2-1-邻接矩阵"><a href="#2-1-邻接矩阵" class="headerlink" title="2.1 邻接矩阵"></a>2.1 邻接矩阵</h3><p>用两个数组来表示图，一个一维数据存储图中顶点信息，一个二维数组存储图中的边或弧的信息</p>
<p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314212538963.png" srcset="/img/loading.gif" lazyload alt="无向图邻接矩阵"></p>
<p>无向图的边数组是一个对称矩阵</p>
<p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314212654932.png" srcset="/img/loading.gif" lazyload alt="有向图邻接矩阵"></p>
<h3 id="2-2-邻接表"><a href="#2-2-邻接表" class="headerlink" title="2.2 邻接表"></a>2.2 邻接表</h3><p>领接矩阵的问题在于它对存储空间有极大的浪费，如下：</p>
<p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314213010440.png" srcset="/img/loading.gif" lazyload alt></p>
<p>所以：数组与链表相结合的存储方式—-邻接表</p>
<p>（1）图中顶点用一个一维数组存储，顶点也可以用单链表来存储。但是数据更加容易读取顶点信息，更加方便。另外对于顶点数组中，每个数组元素还需要存储指向第一个邻接点的指针，以便查找该顶点的边信息。</p>
<p>（2）图中的每个顶点V~i~的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点V~i~的边表，有向图则称为顶点V~i~作为弧尾的出边表。</p>
<p>无向图邻接表</p>
<p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314213616546.png" srcset="/img/loading.gif" lazyload alt="无向图邻接表"></p>
<p>有向图邻接表</p>
<p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314213727207.png" srcset="/img/loading.gif" lazyload alt="有向图邻接表"></p>
<p>这样很容易确定每个顶点的出度，但是为了更加方便的确定顶点的入度，我们引入有向图的逆邻接表，即对每个顶点V~i~都建立一个链接为V~i~的表</p>
<p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314214021296.png" srcset="/img/loading.gif" lazyload alt="逆邻接表"></p>
<p>对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可</p>
<p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314214136442.png" srcset="/img/loading.gif" lazyload alt="带权图"></p>
<h3 id="2-3-十字链表"><a href="#2-3-十字链表" class="headerlink" title="2.3 十字链表"></a>2.3 十字链表</h3><p>将邻接表和逆邻接表结合起来—十字链表</p>
<p>顶点表结点结构</p>
<p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314214725184.png" srcset="/img/loading.gif" lazyload alt="顶点表结点结构"></p>
<p><strong>firstin表示入边表头指针，指向该顶点的入边表中第一个结点</strong></p>
<p><strong>firstout表示出边表头指针，指向该顶点的出边表中的第一个结点</strong></p>
<p>边表结点结构</p>
<p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314214943293.png" srcset="/img/loading.gif" lazyload alt="边表结点结构"></p>
<p><strong>tailvex是指弧起点在顶点表的下标</strong></p>
<p><strong>headvex是指弧终点在顶点表中的下标 </strong></p>
<p><strong>headlink是指入边表指针域，指向终点相同的下一条边</strong></p>
<p><strong>taillink是指边表指针域，指向起点相同的下一条边</strong></p>
<p>如果是网，还可以再增加一个<strong>weight</strong>域来存储权值</p>
<p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314215514793.png" srcset="/img/loading.gif" lazyload alt="十字链表"></p>
<p>如上图，以顶点V~0~为例，<strong>firstout</strong>指向的是出边表中的第一个结点V~3~，所以V~0~边表结点的headvex=3，而tailvex其实就是当前顶点V~0~的下标0，由于V~0~只有一个出边顶点，所以<strong>headlink</strong>和<strong>taillink</strong>都是空。</p>
<p>虚线箭头的含义：对于V~0~来说，它有两个顶点V~1~和V~2~的入边。因此V~0~的<strong>firstin</strong>指向顶点V~1~的边表结点中<strong>headvex</strong>为0的结点，如①</p>
<p>接着由入边结点的<strong>headlink</strong>指向下一个入边顶点V~2~，如图中的②</p>
<p>对于顶点V~1~,他有一个入边顶点V~2~，所以它的<strong>firstin</strong>指向顶点V~2~的边表结点中headvex为1的结点，如③</p>
<p>顶点V~2~和V~3~也是同样有一个入边顶点，如图④和⑤</p>
<h3 id="2-4-邻接多重表"><a href="#2-4-邻接多重表" class="headerlink" title="2.4 邻接多重表"></a>2.4 邻接多重表</h3><p>优化无向表的方案，邻接多重表</p>
<p>边表结点结构</p>
<p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314221055749.png" srcset="/img/loading.gif" lazyload alt="边表结点结构"></p>
<p><strong>ivex</strong>和<strong>jvex</strong>是与某条边依附的两个顶点在顶点表中下标。</p>
<p><strong>ilink</strong>指向依附顶点<strong>ivex</strong>的下一条边，<strong>jlink</strong>指向依附顶点<strong>jvex</strong>的下一条边。</p>
<p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230315210434883.png" srcset="/img/loading.gif" lazyload alt="邻接多重表"></p>
<p>①②③④是将顶点的firstedge指向一条边，顶点下标与ivex的值相同。</p>
<p>由于顶点V~0~的（V~0~，V~1~）边的邻边有(V~0~，V~3~)和（V~0~，V~2~）。因此⑤⑥的连线就是满足指向下一条依附于顶点V~0~的边的目标，注意<strong>ilink</strong>指向的结点的<strong>jvex</strong>一定要和它本身的<strong>ivex</strong>的值相同。其余线条同样的道理。</p>
<h3 id="2-5-边集数组"><a href="#2-5-边集数组" class="headerlink" title="2.5 边集数组"></a>2.5 边集数组</h3><p><strong>边集数组由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标，终点下标和权组成。</strong></p>
<p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230315211320079.png" srcset="/img/loading.gif" lazyload alt="边集数组"></p>
<h2 id="三、图的遍历"><a href="#三、图的遍历" class="headerlink" title="三、图的遍历"></a>三、图的遍历</h2><p>从图中的某一个顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历</p>
<h3 id="3-1-深度优先遍历（DFS）"><a href="#3-1-深度优先遍历（DFS）" class="headerlink" title="3.1 深度优先遍历（DFS）"></a>3.1 深度优先遍历（DFS）</h3><p>图的深度优先搜索（Depth First Search，DFS）是一种用于遍历和搜索图的算法，它从图的某个顶点开始，尽可能深地探索图的分支，直到到达没有未探索过的邻接节点的顶点，然后回溯到前一个顶点，继续探索其他分支。DFS通常使用递归的方式实现，也可以使用栈的方式来实现。 DFS的算法步骤如下：</p>
<ol>
<li>从图中某个顶点开始遍历，将该顶点标记为已访问。</li>
<li>访问该顶点的所有未访问过的邻接点，对每个邻接点递归执行DFS算法。</li>
<li>如果所有邻接点都已被访问，则回溯到前一个顶点，继续执行DFS算法，直到所有顶点都被访问。</li>
</ol>
<p>DFS算法的时间复杂度为O(V+E)，其中V为顶点数，E为边数。由于DFS算法是一种深度优先的算法，因此它的空间复杂度比较高，当遍历的深度过大时，会占用大量的内存空间。为了避免这种情况的发生，可以使用迭代加深搜索或优化的DFS算法，例如剪枝、双向DFS等。</p>
<h3 id="3-2-广度优先遍历（BFS）"><a href="#3-2-广度优先遍历（BFS）" class="headerlink" title="3.2 广度优先遍历（BFS）"></a>3.2 广度优先遍历（BFS）</h3><p>图的广度优先搜索（Breadth First Search，BFS）是一种用于遍历和搜索图的算法，它从图的某个顶点开始，先访问该顶点的所有邻接点，然后再访问这些邻接点的所有邻接点，以此类推，直到所有顶点都被访问。BFS通常使用队列的方式实现。 BFS的算法步骤如下：</p>
<ol>
<li>选择一个顶点作为起点，并将其加入队列。</li>
<li>从队列中取出一个顶点，访问该顶点并将其标记为已访问。</li>
<li>访问该顶点的所有未访问过的邻接点，并将这些邻接点加入队列。</li>
<li>重复步骤2和步骤3，直到队列为空。 </li>
</ol>
<p>BFS算法的时间复杂度为O(V+E)，其中V为顶点数，E为边数。BFS算法的空间复杂度也比较高，因为需要使用队列来存储访问过的顶点，当图的顶点数较大时，会占用较多的内存空间。为了避免这种情况的发生，可以使用双向BFS等优化算法。 BFS算法常用于解决图的最短路径、连通性、拓扑排序等问题。在实际应用中，BFS算法也可以用于解决一些经典问题，例如迷宫问题等。</p>
<h2 id="四、最小生成树"><a href="#四、最小生成树" class="headerlink" title="四、最小生成树"></a>四、最小生成树</h2><p>把构造连通图的最小代价生成树称为最小生成树</p>
<h3 id="4-1-Prim算法"><a href="#4-1-Prim算法" class="headerlink" title="4.1 Prim算法"></a>4.1 Prim算法</h3><p>它是一种用于求解加权无向连通图的最小生成树的贪心算法。</p>
<p>它的基本思想是从一个任意顶点开始，每次找到与当前生成树相邻的、边权最小的顶点加入生成树中，直到所有顶点都被加入生成树为止。Prim算法使用一个优先队列来维护当前与生成树相邻的顶点，每次从优先队列中取出边权最小的顶点加入生成树，然后将该顶点的所有未被访问过的邻接点加入优先队列中。这个过程持续到所有顶点都被加入生成树为止。</p>
<p>Prim算法的具体实现可以采用两种不同的数据结构，分别是邻接矩阵和邻接表。邻接矩阵可以用来表示稠密图，它的时间复杂度为O(V^2)，其中V为顶点数。邻接表可以用来表示稀疏图，它的时间复杂度为O(E log V)，其中E为边数，V为顶点数。因此，在实际应用中，我们通常使用邻接表来实现Prim算法。</p>
<p>Prim算法的时间复杂度为O(E log V)，其中E为边数，V为顶点数。这是因为Prim算法需要遍历每个顶点，并且需要在每次遍历时更新优先队列中的元素。由于使用了优先队列来维护当前与生成树相邻的顶点，因此可以保证每次取出的顶点都是当前与生成树距离最小的顶点，从而保证了Prim算法的正确性。</p>
<h3 id="4-2-Kruskal算法"><a href="#4-2-Kruskal算法" class="headerlink" title="4.2 Kruskal算法"></a>4.2 Kruskal算法</h3><p>Kruskal算法是一种用于求解加权无向连通图的最小生成树的贪心算法。他的基本思想是将图中的所有边按照边权从小到大进行排序，然后依次将边加入生成树中，如果加入某条边会形成环，则舍弃该边，直到所有顶点都被加入生成树为止。</p>
<p>Kruskal算法的时间复杂度为O(ElogE)，其中E为边数，V为顶点数。这是因为Kruskal算法需要排序所有边，并且需要在每次遍历时判断当前边的两个端点是否在同一集合中。由于使用了并查集来维护当前生成树的连通性，因此可以保证每次加入的边都不会形成环，从而保证了Kruskal算法的正确性。</p>
<p>Kruskal算法的优点是实现简单，适用于稀疏图。当图的边数比较大时，Kruskal算法的效率比Prim算法高。Kruskal算法的缺点是空间复杂度比较高，因为需要使用并查集来维护当前生成树的连通性，当图的顶点数较大时，会占用较多的内存空间。</p>
<p><strong>ps：</strong>并查集是一种用于处理集合合并及查询连通性问题的数据结构，常用于求解最小生成树、最短路、图的连通性等问题。并查集主要支持两个操作：合并和查找。</p>
<ul>
<li>合并操作：将两个不相交的集合合并为一个集合。</li>
<li>查找操作：查找某个元素所在的集合。 并查集通常使用一个数组来表示集合，数组中的每个元素表示一个节点，节点的值表示该节点的父节点。如果一个节点的父节点为自身，则说明该节点是集合的代表元素。并查集的合并操作可以通过将两个节点的父节点设置为同一个值来实现，查找操作可以通过递归地查找该节点的父节点并返回其代表元素来实现。在实际应用中，为了提高并查集的效率，通常会使用路径压缩和按秩合并等优化技术。 并查集的时间复杂度主要取决于合并操作的时间复杂度，因此可以通过使用路径压缩和按秩合并等优化技术来减少合并操作的时间复杂度，并使得并查集的时间复杂度达到近乎常数级别。</li>
</ul>
<h2 id="五、最短路径"><a href="#五、最短路径" class="headerlink" title="五、最短路径"></a>五、最短路径</h2><p>对于网图来说，最短路径就是两个顶点之间经过的边上权值之和最小的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</p>
<h3 id="5-1-Dijkstra算法"><a href="#5-1-Dijkstra算法" class="headerlink" title="5.1 Dijkstra算法"></a>5.1 Dijkstra算法</h3><p>Dijkstra算法是一种用于求解带权有向图中单源最短路径的算法，其基本思想是从源点开始，按照节点到源点的距离递增的顺序依次确定每个节点的最短路径。Dijkstra算法可以处理没有负权边的图，时间复杂度为O(n^2)，其中n为节点数。 具体来说，Dijkstra算法的步骤如下：</p>
<ol>
<li>初始化：将源点的最短路径长度设为0，将其它节点的最短路径长度设为无穷大，将所有节点标记为未访问。</li>
<li>选择最短路径节点：从未访问的节点中选择一条距离源点最近的节点，将其标记为已访问。</li>
<li>更新最短路径：对于从源点出发，且未访问的每个相邻节点，如果经过当前节点到达该相邻节点的距离比该相邻节点当前的最短路径更短，则更新该相邻节点的最短路径。</li>
<li>重复第2步和第3步，直到所有节点都被访问。</li>
<li>最短路径计算：根据每个节点的最短路径长度，可以计算出源点到每个节点的最短路径。 Dijkstra算法的时间复杂度取决于选择最短路径节点的方式。如果使用线性搜索来选择最短路径节点，则时间复杂度为O(n^2)；如果使用堆或优先队列来选择最短路径节点，则时间复杂度为O(m log n)，其中m为边数。因此，使用堆或优先队列的Dijkstra算法更适合处理大型稠密图，而使用线性搜索的Dijkstra算法更适合处理小型稀疏图。</li>
</ol>
<h3 id="5-2-Floyd算法"><a href="#5-2-Floyd算法" class="headerlink" title="5.2 Floyd算法"></a>5.2 Floyd算法</h3><p>Floyd算法是一种用于求解全源最短路径的算法，它的基本思想是动态规划。具体而言，Floyd算法通过中间节点逐步扩展路径，更新每对节点之间的最短路径长度，直到得到所有节点之间的最短路径长度。</p>
<p>Floyd算法的步骤如下：</p>
<ol>
<li><p>初始化：将每对节点之间的最短路径长度初始化为直接相连的边的权值，对于不相邻的节点之间的距离，将其距离设为无穷大（表示不可达）。</p>
</li>
<li><p>中间节点遍历：对于每一个节点k，检查从节点i到节点j的路径是否通过节点k，如果通过节点k路径更短，则更新节点i到节点j的最短路径长度。</p>
</li>
<li><p>重复执行2，直到每对节点之间的最短路径长度不再更新。 Floyd算法的时间复杂度为O(n^3)，其中n为节点数。</p>
<p>下面是Floyd算法的伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">procedure <span class="hljs-title">FloydWarshall</span> <span class="hljs-params">(distance[][], V)</span></span><br><span class="hljs-function">   <span class="hljs-keyword">for</span> k from 1 to V</span><br><span class="hljs-function">      <span class="hljs-keyword">for</span> i from 1 to V</span><br><span class="hljs-function">         <span class="hljs-keyword">for</span> j from 1 to V</span><br><span class="hljs-function">            distance[i][j] </span>= <span class="hljs-built_in">min</span>(distance[i][j], distance[i][k] + distance[k][j])<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="六、拓扑排序"><a href="#六、拓扑排序" class="headerlink" title="六、拓扑排序"></a>六、拓扑排序</h2><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为<strong>AOV网</strong></p>
<p>设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列v~1~，v~2~，……，v~n~，满足若从顶点v~i~到v~j~有一条路径，则在顶点序列中顶点v~i~必在v~j~之前，则我们称这样的顶点序列为一个拓扑序列。</p>
<p>拓扑序列可以使用拓扑排序算法，其基本思想是通过不断删除入度为0的节点，来逐步构建DAG的拓扑序列。</p>
<p>拓扑排序算法步骤：</p>
<ol>
<li>统计每个节点的入度。对于每个节点，统计其有多少个父节点（即指向该节点的边的数量），并将这个值存储在一个数组中。</li>
<li>将入度为0的节点加入队列。将所有入度为0的节点加入一个队列中，作为拓扑序列的起点。</li>
<li>删除入度为0的节点。从队列中取出一个入度为0的节点，将其从图中删除，并将其所有邻居节点的入度减1。如果邻居节点的入度变为0，则将其加入队列中。</li>
<li>重复步骤3，直到队列为空。重复执行步骤3，直到队列为空。如果在此过程中，存在某个节点的入度始终不为0，那么这个图就不是DAG，拓扑排序失败。</li>
<li>输出拓扑序列。当队列为空时，所有节点都已经被访问，拓扑序列构建完成，按照拓扑序列输出所有节点即可。</li>
</ol>
<p>拓扑排序算法的时间复杂度为O(V+E)，其中V是节点数，E是边数。</p>
<h2 id="七、关键路径"><a href="#七、关键路径" class="headerlink" title="七、关键路径"></a>七、关键路径</h2><p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，称之为AOE网。</p>
<p><strong>关键路径</strong>是指在一个项目网络图中，从开始节点到结束节点的所有路径中，耗时最长的路径。<strong>在这个路径上的每个活动都是关键活动</strong>。因为这些活动的持续时间不能延误，否则整个项目的完成时间都会被延误。</p>
<p><strong>1. ETV：事件最早发生时间，就是顶点的最早发生时间</strong></p>
<p><strong>2. LTV：事件最晚需要开始的时间，超出此时间将会延误整个工程</strong></p>
<p><strong>3. ETE：活动最早开工时间，即弧a~k~的最早发生时间</strong></p>
<p><strong>4. LTE：活动的最晚开工时间，即弧a~k~的最晚发生时间</strong></p>
<p><strong>ETE和LTE相等的活动就是关键活动</strong></p>
<p><strong>关键路径上的顶点时间最早发生时间和最晚发生时间一致</strong></p>
<p>第一步：拓扑排序获得每一个事件的最早发生时间</p>
<p>第二步：根据事件的最早发生时间EVT推断事件的最晚发生时间LTV</p>
<p>第三步：找到EVT和LTV相等的事件</p>
<p><strong>计算活动的最早与最晚发生时间</strong></p>
<p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230320202500069.png" srcset="/img/loading.gif" lazyload alt="示例"></p>
<p>以上图为例，当我们已经知道了事件的最早发生时间和最晚发生时间之后，我们可以推断出活动的最早发生时间和最晚发生时间</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">事件		V1 V2 V3 V4 V5 V6 V7 V8 V9<br>最早发生  <span class="hljs-number"> 0 </span> 6	<span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 16 </span>14 18<br>最迟发生  <span class="hljs-number"> 0 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 10 </span>16<span class="hljs-number"> 14 </span>18<br>活动      a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11<br>最早开始  <span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 16 </span> 14<br>最晚开始  <span class="hljs-number"> 0 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 10 </span>16  14<br></code></pre></td></tr></table></figure>
<p>以a4为例，它的最早发生时间为，事件2的最早发生时间为6，立马进行活动a4，所以a4的最早发生时间为6，事件2的最晚发生时间为6，事件5的最晚发生时间是7，而a4所需要的时间为1，所以a4的最晚发生时间为7-1=6，这样才不会延误整个工程，其余活动同理。</p>
<p>最终就可以找到关键路径与关键活动</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>数据结构--图</div>
      <div>http://sugar-122.github.io/2023/03/14/数据结构--图/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Sugar</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月14日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/22/%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE/" title="线性索引查找">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">线性索引查找</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/" title="数据结构--树（2）">
                        <span class="hidden-mobile">数据结构--树（2）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
