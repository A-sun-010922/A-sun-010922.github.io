

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/1.png">
  <link rel="icon" href="/img/1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Sugar">
  <meta name="keywords" content="">
  
    <meta name="description" content="图解TCP&#x2F;IP协议学习第一章 网络基础知识计算机网络根据规模可以分为WAN(Wide Area Nerwork，广域网)和LAN(Local Area Network，局域网) 计算机与网络发展的7个阶段： （1）批处理：事先将用户程序和数据装入卡带或磁带，并由计算机按照一定的顺序读取，使用户所要执行的这些程序和数据能够一并批量得到处理的方式。  （2）分时系统(TSS)：指多个终端与同一个计算">
<meta property="og:type" content="article">
<meta property="og:title" content="图解TCP&#x2F;IP协议学习">
<meta property="og:url" content="http://sugar-122.github.io/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="图解TCP&#x2F;IP协议学习第一章 网络基础知识计算机网络根据规模可以分为WAN(Wide Area Nerwork，广域网)和LAN(Local Area Network，局域网) 计算机与网络发展的7个阶段： （1）批处理：事先将用户程序和数据装入卡带或磁带，并由计算机按照一定的顺序读取，使用户所要执行的这些程序和数据能够一并批量得到处理的方式。  （2）分时系统(TSS)：指多个终端与同一个计算">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://sugar-122.github.io/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.png">
<meta property="article:published_time" content="2023-03-29T07:30:02.250Z">
<meta property="article:modified_time" content="2023-04-26T07:59:41.862Z">
<meta property="article:author" content="Sugar">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://sugar-122.github.io/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.png">
  
  
  
  <title>图解TCP/IP协议学习 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"sugar-122.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Sugar</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="图解TCP/IP协议学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-29 15:30" pubdate>
          2023年3月29日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          48k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          398 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">图解TCP/IP协议学习</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="图解TCP-IP协议学习"><a href="#图解TCP-IP协议学习" class="headerlink" title="图解TCP/IP协议学习"></a>图解TCP/IP协议学习</h1><h2 id="第一章-网络基础知识"><a href="#第一章-网络基础知识" class="headerlink" title="第一章 网络基础知识"></a>第一章 网络基础知识</h2><p>计算机网络根据<strong>规模</strong>可以分为<strong>WAN(Wide Area Nerwork，广域网)和LAN(Local Area Network，局域网)</strong></p>
<p>计算机与网络发展的7个阶段：</p>
<p><strong>（1）批处理：</strong>事先将用户程序和数据装入卡带或磁带，并由计算机按照一定的顺序读取，使用户所要执行的这些程序和数据能够一并批量得到处理的方式。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329155056754.png" srcset="/img/loading.gif" lazyload alt="批处理"></p>
<p><strong>（2）分时系统(TSS)：</strong>指多个终端与同一个计算机连接，允许多个用户同时使用一台计算机的系统。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329155551134.png" srcset="/img/loading.gif" lazyload alt="分时系统"></p>
<p><strong>（3）计算机之间的通信：</strong>计算机与计算机之间由通信线路连接，人们能够很轻松地即时读取另一台计算机中的数据，从而极大地缩短了传送数据的时间。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329155826451.png" srcset="/img/loading.gif" lazyload alt="计算机之间的通信"></p>
<p><strong>（4）计算机网络的产生：</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329160038835.png" srcset="/img/loading.gif" lazyload alt="计算机网络的产生"></p>
<p>互连多种计算机的网络诞生，让各式各样的计算机相互连接，从大型的超级计算机或主机到小型的个人电脑。</p>
<p><strong>（5）互联网的普及：</strong>一人一机</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329160558473.png" srcset="/img/loading.gif" lazyload alt="互联网的普及"></p>
<p><strong>（6）以互联网技术为中心的时代：</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329160631657.png" srcset="/img/loading.gif" lazyload alt="以互联网技术为中心的时代"></p>
<p><strong>（7）从“单纯建立连接”到“安全建立连接”</strong></p>
<h3 id="1-1-协议"><a href="#1-1-协议" class="headerlink" title="1.1 协议"></a>1.1 协议</h3><p>协议就是计算机与计算机之间通过网络实现通信时事先达成的一种“约定”，只要遵循相同的协议就能实现通信；反之，如果使用的协议不同，就无法实现通信。</p>
<p><strong>分组交换协议：</strong>分组交换是指将一个大数据分割为一个个叫做包的较小单位进行传输的方法。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329161541019.png" srcset="/img/loading.gif" lazyload alt="分组交换"></p>
<p>每一个分组中附加上的源主机地址和目标主机地址送给通信线路，这些发送端地址、接收端地址以及分组序号写入的部分称为”<strong>报文首部</strong>“。</p>
<p>分组序号是为了辨别这个分组是原始数据的哪一部分，按照相应的序号将分组重新装配为原始数据。</p>
<p>而通信协议就是用来规定报文首部应该写入哪些信息、应该如何处理这些信息……</p>
<p><strong>协议的分层</strong></p>
<p>分层可以将每个分层独立使用，即使系统中某些分层发生变化，也不会波及到整个系统，因此可以构建一个扩展性和灵活性都较强的系统。此外，分层可以细分通信功能，更易于单独实现每个分层的协议，并界定各个分层的具体责任和义务；但是过分的模块化，使处理变得更加沉重以及每个模块都不得不实现相似的处理逻辑。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329162128558.png" srcset="/img/loading.gif" lazyload alt="协议的分层"></p>
<p><strong>OSI参考模型</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329162607293.png" srcset="/img/loading.gif" lazyload alt="OSI参考模型"></p>
<p><strong>OSI参考模型中各个层的作用</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329180221366.png" srcset="/img/loading.gif" lazyload alt="OSI参考模型中各个层的作用"></p>
<p><strong>应用层：</strong>为应用程序提供服务并规定应用程序中通信相关的细节</p>
<p><strong>表示层：</strong>将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式，主要负责数据格式的转换</p>
<p><strong>会话层：</strong>负责建立和断开通信连接以及数据的分割等数据传输相关的管理</p>
<p><strong>传输层：</strong>起着可靠传输的作用。只在通信双方结点上进行处理，而无需在路由器上处理</p>
<p><strong>网络层：</strong>将数据传输到目的地址。目的地址可以使多个网络通过路由器连接而成的某一个地址。主要负责寻址和路由选择</p>
<p><strong>数据链路层：</strong>负责物理层面上互连的、结点之间的通信传输</p>
<p><strong>物理层：</strong>负责0、1比特流与电压的高低、光的闪灭之间的互换</p>
<h3 id="1-2-传输"><a href="#1-2-传输" class="headerlink" title="1.2 传输"></a>1.2 传输</h3><p><code>面向有连接型</code>和<code>面向无连接型</code></p>
<p><strong>面向有连接型：</strong>在发送数据之前，需要在收发主机之间连接一条通信线路。</p>
<p><strong>面向无连接型：</strong>不要求建立和断开连接。发送端可于任何时候自由发送数据；反之接收端也永远不知道自己在何时从哪里收到数据。</p>
<p>网络通信方式：<code>电路交换</code>和<code>分组交换</code></p>
<blockquote>
<p><strong>电路交换</strong>：交换机主要负责数据的中转处理，计算机首先被连接到交换机上，而交换机与交换机之间则由众多通信线路再继续连接。计算机在发送数据的时候，需要通过交换机与目标主机建立通信电路，建立好连接之后，用户一直使用这条电路，直到该连接被断开为止</p>
<p><strong>弊端：</strong>如果一条电路上连接了多台计算机，但是基于电路交换的话某一台计算机会独占线路，其他计算机只能等待，但是又无法预测该台计算机数据传输何时结束，就会造成浪费和拥堵</p>
<p><strong>分组交换：</strong>让连接到通信电路的计算机将所要发送的数据分成多个数据包，按照一定的顺序排列之后分别发送，就是分组交换。这样提高了通信线路的利用率，由于在分组的过程中，已经在每个分组的首部写入了发送端和接收端的地址，所以即使同一条线路同时为多个用户提供服务，也可以明确区分每个分组数据发往的目的地</p>
<p>在分组交换中，由分组交换机(路由器)连接通信链路。大致处理过程是：发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后，缓存到自己的缓冲区，然后再转发给目标计算机。</p>
<p><strong>弊端：</strong>在分组交换中，计算机与路由器之间以及路由器与路由器之间通常只有一条通信线路。因此，这条线路其实是一条共享线路，所以通信线路的速度可能会有所不同，根据网络拥堵情况，数据达到目标地址的时间有长有短。当路由器的缓存饱和或溢出的时候，可能会出现分组数据丢失，无法发送到对端的情况</p>
</blockquote>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329183334166.png" srcset="/img/loading.gif" lazyload alt="电路交换和分组交换"></p>
<p>网络通信还可以根据目标地址的个数及其后续的行为对通信进行分类</p>
<p><strong>单播、广播、多播、任播</strong></p>
<blockquote>
<p>单播：1对1通信。固定电话</p>
<p>广播：将消息从1台主机发送到与之相连的所有其他主机。广播通信</p>
<p>多播：与广播类似，但是多播要限定某一组主机作为接收端。电视会议</p>
<p>任播：指在特定的多台主机中选出一台作为接收端的一种通信方式，跟多播有一些相似之处，但是它的行为和多播不同，任播通信从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息。任播在实际应用中有DNS根域名解析服务器</p>
</blockquote>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329184128190.png" srcset="/img/loading.gif" lazyload alt="单播、广播、多播、任播"></p>
<h3 id="1-3-地址"><a href="#1-3-地址" class="headerlink" title="1.3 地址"></a>1.3 地址</h3><p>​    一个地址必须明确表示一个主体对象。MAC地址和IP地址在表示一个通信主机时都具有唯一性，但是它们中只有IP地址具有层次性。</p>
<p>层次性的理解就是，每一部分都具有它自身的含义</p>
<p>MAC地址中的制造商标识号，产品编号以及通用编号等信息在某种程度上也具有一定的层次性，但是对于寻找地址并没有起到任何作用，所以不能称为层次性。</p>
<p><strong>IP地址怎样实现分层，为什么说具有层次性？</strong></p>
<blockquote>
<p>一方面，IP地址由网络号和主机号两部分组成，即使通信主体的IP地址不同，若主机号不同，网络号相同，说明他们处于同一个网段。同处一个网段的主机也都属于同一个部分或集团组织。另一方面，网络号相同的主机在组织结构、提供商类型和地域分布上都比较集中，也为IP寻址带来了极大的方便。</p>
</blockquote>
<p>网络传输中，每个结点都会根据分组数据的地址信息，来判断报文该由哪一个网卡发送出去。为此，各个地址会参考一个发出接口列表。在这一点上MAC寻址和IP寻址是一样的。MAC寻址中所参考的表叫做<strong>地址转发表</strong>，而IP寻址中所参考的叫做<strong>路由控制表</strong></p>
<p>MAC地址转发表中所记录的是实际的MAC地址，路由表中所记录的IP地址则是集中了之后的网络号</p>
<h3 id="1-4-网络构成要素"><a href="#1-4-网络构成要素" class="headerlink" title="1.4 网络构成要素"></a>1.4 网络构成要素</h3><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329185839843.png" srcset="/img/loading.gif" lazyload alt="网络构成要素"></p>
<p><strong>通信媒介与数据链路</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329190018036.png" srcset="/img/loading.gif" lazyload alt="通信媒介与数据链路"></p>
<p><strong>网卡</strong></p>
<p>一台计算机连接网络的时候，必须要使用网卡(全称为网络接口卡)</p>
<p><strong>中继器</strong></p>
<p>物理层面上延长网络的设备，信号在传播过程中可能会受到减弱，所以我们需要对减弱的信号进行放大和发送， 这一项工作就由中继器来做</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329190442297.png" srcset="/img/loading.gif" lazyload alt="中继器"></p>
<p><strong>网桥/2层交换机</strong></p>
<p>数据链路层面上连接两个网络的设备。</p>
<p>网桥两边的通信媒介可能是不一样的，比如左边是电缆，右边是光纤。而网桥就是将不同媒介的数据帧进行转换，以实现两个网络之间的数据通信。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329190551552.png" srcset="/img/loading.gif" lazyload alt="网桥"></p>
<p><strong>路由器/3层交换机</strong></p>
<p>路由器是在OSI模型的第3层—网络层面上连接两个网络、并对分组报文进行转发的设备。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329191329424.png" srcset="/img/loading.gif" lazyload alt="路由器/3层交换机"></p>
<p>基于IP地址进行数据转发，先通过学习IP地址来建立转发表，然后根据数据包的源和目的IP地址进行路由判断，从而实现数据的快速转发和路由。</p>
<p><strong>4~7层交换机</strong></p>
<p>4~7层交换机负责处理OSI模型中从传输层到应用层的数据</p>
<p><strong>网关</strong></p>
<p>用于连接两个不同的网络，使得可以互相通信，网关通常是一台计算机或路由器，它可以将一个网络的数据包转发到另一个网络中，实现不同网络之间的数据交换和通信。</p>
<p>作用：</p>
<p>（1）实现不同协议之间的转换：将一个协议的数据包转换成另一个协议的数据包，从而实现不同协议之间的通信</p>
<p>（2）实现不同网络之间的连接：连接两个不同的网络成为一个更大的网络</p>
<p>（3）提供安全功能：网关可以对数据包进行过滤和检查，以提高网络的安全性。例如，网关可以对数据包的源地址和目的地址进行检查，防止未经授权的访问。</p>
<p>（4）提供路由功能：网关可以根据不同的路由协议对数据包进行路由，从而实现不同网络之间的数据转发和通信</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329191802486.png" srcset="/img/loading.gif" lazyload alt="网关"></p>
<h2 id="第二章-TCP-IP基础知识"><a href="#第二章-TCP-IP基础知识" class="headerlink" title="第二章 TCP/IP基础知识"></a>第二章 TCP/IP基础知识</h2><p>互联网进行通信的时候，需要相应的网络协议，TCP/IP原本就是为使用互联网而开发制定的协议族，因此，互联网的协议就是TCP/IP</p>
<p>互联网中的每个网络都是由骨干网和末端网组成的，每个网络之间通过NOC相连，如果网络的运行商不同，他的网络连接方式和使用方法也会不同。连接这种异构网络需要<strong>IX</strong>的支持。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330204725100.png" srcset="/img/loading.gif" lazyload alt="互联网的结构"></p>
<h3 id="2-1-分层"><a href="#2-1-分层" class="headerlink" title="2.1 分层"></a>2.1 分层</h3><p><strong>TCP/IP协议分层模型</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330205028567.png" srcset="/img/loading.gif" lazyload alt="TCP/IP协议分层模型"></p>
<p><strong>硬件（物理层）：</strong>这种硬件就相当于以太网或电话线路等物理层的设备。</p>
<p><strong>网络接口层（数据链路层）：</strong>网络接口层利用以太网中的数据链路进行通信，属于接口层，可以看做是让NIC起作用的”驱动程序“。</p>
<p><strong>互联网层（网络层）：</strong>互联网层使用IP协议，它相当于OSI模型中的第3层网络层，IP协议基于IP地址转发分包数据。</p>
<p><strong>IP：</strong>是跨越网络传送数据包，使整个互联网都能收到数据的协议。IP协议使数据能够发送到地球的另一端，使用IP地址作为主机的标识。</p>
<p><strong>ICMP：</strong>IP数据包在发送途中一旦发生异常导致无法到达对端目标地址时，需要给发送端发送一个发生异常的通知。</p>
<p><strong>ARP：</strong>从分组数据包的IP地址中解析出物理地址(MAC地址)的一种协议</p>
<p><strong>传输层：</strong>让应用程序之间实现通信，而计算机内部通常同一时间运行着多个程序，为了分清哪些程序与哪些程序在进行通信，识别这些应用程序的是端口号</p>
<p><strong>TCP：</strong>面向连接的传输层协议，保证两端通信主机之间的通信可达。它可以正确处理在传输过程中丢包、传输顺序乱掉等异常情况，还可以有效利用带宽，缓解网络拥堵。<strong>但是</strong>为了建立与断开连接，需要至少7次的发包收包，导致网络流量的浪费，此外为了提高网络的利用率，TCP协议中定义了各种各样复杂的规范，因此不利于视频会议等场合使用。</p>
<p><strong>UDP：</strong>面向无连接的传输层协议，不会关注对端是否真的收到了传送过去的数据，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。</p>
<p><strong>应用层：</strong>TCP/IP应用的架构绝大多数属于客户端/服务端模型。提供服务的程序叫服务端，接收服务的程序叫客户端。</p>
<p><strong>WWW：</strong>浏览器与服务端之间通信所用的协议是HTTP，所传输数据的主要格式是HTML，WWW中的HTTP属于应用层协议，HTML属于表示层协议</p>
<p><strong>电子邮件：</strong>在网络上发送信件，不管距离，只要连着互联网就可以互相发送邮件。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330210810713.png" srcset="/img/loading.gif" lazyload alt="电子邮件"></p>
<p><strong>FTP：</strong>文件传输是指将保存在其他计算机硬盘上的文件转移到本地的硬盘上，或将本地硬盘的文件传送到其他机器硬盘上的意思。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330210912928.png" srcset="/img/loading.gif" lazyload alt="文件传输"></p>
<p><strong>远程登录（TELNET和SSH）：</strong>远程登录是指登录到远程的计算机上，使那台计算机上的程序得以运行的一种功能</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330211119105.png" srcset="/img/loading.gif" lazyload alt="远程登录"></p>
<p><strong>网络管理（SNMP）：</strong>在TCP/IP中进行网络管理时，采用SNMP协议，使用SNMP管理的主机、网桥、路由器等称作SNMP代理，而进行管理的那一段叫做管理器。</p>
<p>在SNMP的代理端，保存着网络接口的信息， 通信数据量，异常数据量以及设备温度等信息，这些信息可以通过MIB访问</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330211327777.png" srcset="/img/loading.gif" lazyload alt="网络管理"></p>
<h3 id="2-2-通信"><a href="#2-2-通信" class="headerlink" title="2.2 通信"></a>2.2 通信</h3><p><strong>数据包首部：</strong>每个分层中，都会对所发送的数据附加一个首部，这个首部包含了该层必要的信息，如发送的目标地址以及协议相关信息。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330211556300.png" srcset="/img/loading.gif" lazyload alt="数据包首部"></p>
<p>包、帧、数据报、段、消息都用来表述数据的单位，帧用于数据链路层中包的单位，数据报是网络侧以上的分层中包的单位，段是表示TCP数据流中的信息，消息是应用协议中数据的单位。</p>
<p>数据包的首部，明确标明了协议应该如何读取数据</p>
<p><strong>以甲要给乙发送电子邮件，来讲解TCP/IP通信的过程。</strong></p>
<p><strong>（1）应用程序处理：</strong>应用程序进行编码处理，发送邮件的那一刻建立TCP连接，利用这个TCP连接发送数据。它的过程首先是将应用的数据发送给下一层的TCP，在做实际的转发处理</p>
<p><strong>（2）TCP模块的处理：</strong>TCP根据应用的指示，负责建立连接、发送数据以及断开连接。TCP提供将应用层发来的数据顺利发送到对端的可靠传输。</p>
<p>它会在应用层数据的前端附加一个TCP首部，TCP首部中包括源端口号和目标端口号(用以识别发送主机跟接收主机上的应用)、序号（用以发送的包中哪部分是数据）以及校验和（用以判断数据是否被损坏），然后将附加了TCP首部的包再发送给IP</p>
<p><strong>（3）IP模块的处理：</strong>IP将传过来的数据包，添加IP首部，包含接收端IP地址以及发送端IP地址，紧随IP首部的还有用来判断后面数据是TCP还是UDP的信息。IP包生成后，参考路由控制表决定此IP包的路由或主机，随后IP包将被发送给连接这些路由器或主机网络接口的驱动程序，以实现真正发送数据。如果不知道接收端的MAC地址，可以利用ARP查找，只要知道了对端的MAC地址，就可以将MAC地址和IP地址交给以太网的驱动程序，实现数据传输。</p>
<p><strong>（4）网络接口（以太网驱动）的处理：</strong>给数据包附加上以太网首部并进行发送处理，以太网首部中包含接收端MAC地址、发送端MAC地址以及标志以太网类型的以太网数据的协议。根据上述信息产生的以太网数据包将通过物理层传输给接收端，发送处理中的FCS由硬件计算，添加到包的最后。设置FCS的目的是为了判断数据包是否由于噪声而被破坏。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330213136726.png" srcset="/img/loading.gif" lazyload alt="发邮件通信过程"></p>
<p><strong>经过数据链路的包：</strong>包流动的时候，从前往后一次被附加了以太网包首部，IP包首部，TCP包首部以及应用自己的包首部和数据，而包的最后则追加了以太网包尾。</p>
<p>每个包首部中至少都有两个信息：一个是发送端和接收端地址，另一个是上一层的协议类型</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330213517198.png" srcset="/img/loading.gif" lazyload alt="包结构"></p>
<p><strong>数据包接收处理：</strong>包的接收流程是发送流程的逆序过程。</p>
<p><strong>网络接口（以太网驱动）的处理：</strong>主机收到以太网包以后，首先从以太网的包的首部找到MAC地址判断是否为发给自己的包，如果不是发给自己的包则丢弃数据。而如果接收到了恰好是发给自己的包，就查找以太网包首部中的类型域从而确定以太网协议所传送过来的数据类型。这个类中中数据类型是IP包，因此将数据传送给处理IP的子程序，如果这时不是IP而是其他诸如ARP的协议，就把数据传给ARP处理,如果类型无法识别就丢弃。</p>
<p><strong>IP模块的处理：</strong>IP模块收到IP包首部及后面的数据部分以后，也做类似的处理，如果判断得出包首部中的IP地址与自己的IP地址匹配，则可接收数据并从中查找上一层的协议，传给相应的模块处理。</p>
<p><strong>TCP模块的处理：</strong>在TCP模块中，首先会计算一下校验和，判断数据是否被破坏，然后检查是否在按照序号接收数据，最后检查端口号，确定具体的应用程序。数据接收完毕后，接收端发送“确认回执”给发送端，如果这个回执信息未能达到发送端，那么发送端就会认为接收端没有接收到数据而一直反复发送。数据被完整地接收以后，会传给由端口识别的应用程序。</p>
<p><strong>应用程序的处理：</strong>接收端应用程序会直接接收发送端发送的数据。通过解析数据可以获取邮件的收件人地址是乙的地址，如果主机B上没有乙的邮件信箱，那么主机B返回给发送一个“无此收件地址”的报错信息。</p>
<h2 id="第三章-数据链路"><a href="#第三章-数据链路" class="headerlink" title="第三章 数据链路"></a>第三章 数据链路</h2><p>数据链路，指OSI参考模型中的数据链路层，有时也指以太网、无线局域网等通信手段。</p>
<p>数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范，通信媒介包括双绞线电缆，同轴电缆，光纤，电波以及红外线等介质。此外，各个设备之间有时也会通过交换机、网桥、中继器等中转数据。</p>
<p><strong>MAC地址：</strong>MAC地址用于识别数据链路中互连的结点。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331170749749.png" srcset="/img/loading.gif" lazyload alt="MAC地址"></p>
<p><strong>MAC地址长48比特</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331170924346.png" srcset="/img/loading.gif" lazyload alt="MAC地址"></p>
<h3 id="3-1-传输"><a href="#3-1-传输" class="headerlink" title="3.1 传输"></a>3.1 传输</h3><h4 id="3-1-1-共享介质型网络"><a href="#3-1-1-共享介质型网络" class="headerlink" title="3.1.1 共享介质型网络"></a>3.1.1 <strong>共享介质型网络</strong></h4><p>从通信介质的使用方法上看，网络可以分为共享介质型和非共享介质型。共享介质型网络织由多个设备共享一个通信介质的一种网络。最早的以太网和FDDI就是介质共享型网络，这种方式下，设备之间使用同一个载波信道进行发送和接收，为此基本上采用半双工通信方式，并有必要对介质进行访问控制。共享介质型网络中有两种介质访问控制方式：一种是<strong>争用方式</strong>，另一种是<strong>令牌传递方式</strong>。</p>
<p><strong>争用方式：</strong>指争夺数据传输的权利，也加CSMA(载波监听多路访问)。这种方法通常令网络中的各个站采用先到先得的方式占用信道发送数据，如果多个站同时发送帧，则会产生冲突现象，导致网络拥堵和性能下降。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331172744540.png" srcset="/img/loading.gif" lazyload alt="CSMA"></p>
<p>改良CSMA的另一种方式：<strong>CSMA/CD</strong>方式，它要求每一个站提前检查冲突，一旦发生冲突，则尽早释放信道。</p>
<p>工作原理：</p>
<p>（1）如果载波信道上没有数据流动，则任何站都可以发送数据。</p>
<p>（2）检查是否会发生冲突，一旦发生冲突，发起发送数据，同时立即释放载波信道</p>
<p>（3）放弃发送以后，随机延时一段时间，再重新争用介质，重新发送帧。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331172758635.png" srcset="/img/loading.gif" lazyload alt="CSMA/CD"></p>
<p><strong>令牌传递方式：</strong>令牌传递方式是沿着令牌环发送一种叫做“令牌”的特殊报文，是控制传输的一种方式，只有获得令牌的站才能发送数据。</p>
<p><strong>特点：</strong>一是不会有冲突，二是每个站都有通过平等循环获得令牌的机会。但是一个站在没有收到令牌前不能发送数据帧， 因此在网络不太拥堵的情况下数据链路的利用率也就达不到100%。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331211409656.png" srcset="/img/loading.gif" lazyload alt="令牌传递"></p>
<h4 id="3-1-2-非共享介质网络"><a href="#3-1-2-非共享介质网络" class="headerlink" title="3.1.2 非共享介质网络"></a>3.1.2 <strong>非共享介质网络</strong></h4><p>不共享介质，是对介质采取专用的一种传输控制方式。在这种方式下，网络中的每个站直连交换机，由交换机负责转发数据帧。不共享通信介质，通常采用全双工通信方式。在这种一对一连接全双工通信的方式下不会发生冲突，可以实现高效的通信。</p>
<p>但是如果交换机损坏，与之相连的所有计算机之间都将无法通信。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331211925563.png" srcset="/img/loading.gif" lazyload alt="非共享介质网络"></p>
<h3 id="3-2-转发"><a href="#3-2-转发" class="headerlink" title="3.2 转发"></a>3.2 转发</h3><h4 id="3-2-1-根据MAC地址转发"><a href="#3-2-1-根据MAC地址转发" class="headerlink" title="3.2.1 根据MAC地址转发"></a>3.2.1 <strong>根据MAC地址转发</strong></h4><p>以太网交换机就是持有多个端口的网桥，它们根据数据链路层中的每个帧的目标MAC地址，决定从哪个网络接口发送数据，这张表叫做地址转发表。其内容不需要使用者在每个终端或交换机上手工设置，而是可以自动生成。</p>
<p>数据链路层的每个通过点在接收到包的时候，会从中将源MAC地址以及曾经接收该地址发送的数据包的接口作为对应关系记录到转发表中。以某个MAC地址作为源地址的包由某一接口接收，实质上可以理解为该MAC地址就是该接口的目标。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331213542976.png" srcset="/img/loading.gif" lazyload alt="MAC地址转发"></p>
<p><strong>交换机的转发方式：</strong><code>存储转发</code>和<code>直通转发</code></p>
<p>存储转发方式检查以太网数据帧末尾的FCS(Frame Cheack Sequence)位再进行转发。因此，可以避免发送由于冲突而被破坏的帧或噪声导致的错误帧。</p>
<p>直通转发方式不需要完全接收就可以转发，具有演示较短的优势，但是同时也不可避免的发送错误帧的可能性。</p>
<h4 id="3-2-2-环路检测技术"><a href="#3-2-2-环路检测技术" class="headerlink" title="3.2.2 环路检测技术"></a>3.2.2 <strong>环路检测技术</strong></h4><p>通过网桥连接网络的时候，一旦出现环路该怎么处理？在计算机网络中，当两个或多个网桥（或交换机）通过多条路径连接时，可能会形成环路。这种情况下，数据包可能会在环路中不断地被转发，从而导致网络出现问题。 具体来说，当一个数据包到达一个环路中的交换机时，交换机会将该数据包向所有的连线端口进行广播。由于环路的存在，某些交换机会将该数据包再次广播到环路的另一个交换机上，这个交换机也会将该数据包再次广播，以此类推，数据包会在环路中不断地循环转发。这种情况下，网络中的带宽会被大量消耗，从而导致网络拥塞、延迟等问题。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331214929385.png" srcset="/img/loading.gif" lazyload alt="环路"></p>
<p>所以必须要解决掉环路的这个问题。</p>
<p><strong>生成树方式</strong></p>
<p>每个网桥必须在每1~10秒内相互交换BPDU包，从而判断哪些端口使用哪些不适用，以便消除环路。一旦发生故障，则自动切换通信线路，利用那些没有被使用的端口继续进行传输。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331215449544.png" srcset="/img/loading.gif" lazyload alt="生成树方式"></p>
<p>弊端在于发生故障切换网络的时候需要几十秒的时间，为了解决这个用时过长的问题，定义了一个叫RSTP的方法，这个方法可以将发生问题的时候恢复时间缩短到几秒内。</p>
<p><strong>源路由法</strong></p>
<p>它允许发送方指定数据包在传输过程中所经过的路由结点，在源路由协议中，每个数据包都携带有完整的路由信息，因此可以避免网络中的路由查找过程，提高了网络传输的效率。即使网桥中出现了环路，数据帧也不会反复转发，可成功地发送到目标地址。</p>
<h4 id="3-2-3-VLAN"><a href="#3-2-3-VLAN" class="headerlink" title="3.2.3 VLAN"></a>3.2.3 VLAN</h4><p>为什么要引入VLAN技术？在大型企业或组织中网络管理和数据传输的问题。在传统的网络结构中，所有设备都连接在同一个广播域内，这会造成很多问题，比如安全性问题，任何一个设备都可以轻易地嗅探到其他设备的数据流，从而造成数据泄露和安全问题。广播风暴问题：当一个设备向广播域内发送广播数据包的时候，所有设备都会接收到该数据包，从而导致网络拥堵和性能下降。网络管理非常困难，常常需要更改网络拓扑结构，所以我们需要引入VLAN技术。</p>
<p>VLAN：虚拟局域网，它将一个物理的广播域划分成多个逻辑上的广播域，使得不同的设备可以被分配到不同的VLAN中，实现更加精细的网络管理和控制。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331221220718.png" srcset="/img/loading.gif" lazyload alt="VLAN"></p>
<p>如果是异构的两个网段之间，就需要利用具有路由功能的交换机(如3层交换机)，异构的两个网段的意思就是指代两个不同类型的网络，例如一个局域网和一个广域网、一个有线网络和一个无线网络。对于这种VLAN进行扩展，又定义了IEEE802.1Q的标准(TAG VLAN)，该标准允许包含跨越异构交换机的网段，TAG VLAN中对每个网段都用一个VLAN ID的标签进行唯一标识。在交换机中传输帧的时候，在以太网首部加入这个VID标签，根据这个值决定将数据帧发送给哪个网段。</p>
<p>使用了VLAN技术，不必再重新修改布线，只要修改网段即可。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331222443473.png" srcset="/img/loading.gif" lazyload alt="VLAN"></p>
<h3 id="3-3-以太网"><a href="#3-3-以太网" class="headerlink" title="3.3 以太网"></a>3.3 以太网</h3><p>最为著名的，使用最为广泛的数据链路—以太网</p>
<p><strong>以太网分类</strong>：通信电缆的速度</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331223320875.png" srcset="/img/loading.gif" lazyload alt="以太网分类"></p>
<h4 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h4><p>以太网帧前端有一个叫做前导码的部分（8字节），由0,1数字交替组合而成。表示一个以太网帧的开始，也是对端网卡能够确保与其同步的标志</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331225136063.png" srcset="/img/loading.gif" lazyload alt="以太网帧前导码"></p>
<p>它可以根据同步码SDF进行同步，前导码的意义不仅仅在于同步，准确定位数据帧的开始位置，并在正确的时间开始接收数据，还可以区分与其他通信协议的冲突，前导码的长度和内容是固定的，因此如果使用其他通信协议的数据帧与以太网数据帧发生冲突时，接收方可以通过前导码来识别这个数据帧不是以太网数据帧，并将其丢弃。</p>
<p>以太网帧本体的前端是以太网的首部，共占14字节，分别是6个字节的目标MAC地址，6个字节的源MAC地址以及2个字节的上层协议类型</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331225901750.png" srcset="/img/loading.gif" lazyload alt="以太网帧结构"></p>
<p>可以根据Type/Length来区分两种帧的格式，如果Type/Length&gt;1500，则是以太网帧体格式；如果Type/Length&lt;1500，则是IEEE802.3以太网帧体格式</p>
<p>Type类型：IP（0x0800)、ARP(0x0806)、RARP(0x8035)、IPv6(0x86DD)</p>
<p>帧最后的FCS可以检查帧时候有所损坏。FCS保存着整个帧除以生成多项式的余数。</p>
<p>在VLAN中，帧的格式又会发生变化</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331231025136.png" srcset="/img/loading.gif" lazyload alt="VLAN中以太网帧格式"></p>
<p><strong>LLC和SNAP</strong></p>
<p>如果对数据链路层分为两层，可以分为介质访问控制层和逻辑链路控制层，介质访问控制层根据以太网或FDDI等不同数据链路所持有的首部信息进行控制，与之相比，逻辑链路层则根据以太网或FDDI等不同数据链路所共有的帧头信息进行控制。当类型字段的值为1500时，表示IEEE802.3以太网帧的长度，此时，即使参考类型对照表也无法确定上层协议的类型，所以就需要根据LLC/SNAP才能判断上层协议的类型。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331231646245.png" srcset="/img/loading.gif" lazyload alt></p>
<h3 id="3-4-无线通信"><a href="#3-4-无线通信" class="headerlink" title="3.4 无线通信"></a>3.4 无线通信</h3><h4 id="3-4-1-无线通信的种类"><a href="#3-4-1-无线通信的种类" class="headerlink" title="3.4.1 无线通信的种类"></a>3.4.1 无线通信的种类</h4><p>根据通信距离进行分类</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401101325216.png" srcset="/img/loading.gif" lazyload alt="分类"></p>
<h4 id="3-4-2-IEEE802-11"><a href="#3-4-2-IEEE802-11" class="headerlink" title="3.4.2 IEEE802.11"></a>3.4.2 IEEE802.11</h4><p>IEEE802.11定义了无线LAN协议中物理层与数据链路层的一部分(MAC层)，MAC层中物理地址与以太网相同，都是用MAC地址，而介质访问上则使用CSAM/CD相似的CSAM/CA方式，通常采用无线基站并通过高基站实现通信。</p>
<p>IEEE802.11在物理层上使用<strong>电磁波或红外线</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401101819535.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="3-4-3-IEEE802-11b和IEEE802-11g"><a href="#3-4-3-IEEE802-11b和IEEE802-11g" class="headerlink" title="3.4.3 IEEE802.11b和IEEE802.11g"></a>3.4.3 IEEE802.11b和IEEE802.11g</h4><p>IEEE802.11b和IEEE802.11g是2.4G频段中的无线局域网标准。最大传输速度可以达到11Mbps和54Mbps，通信距离可达30-50米，与IEEE802.11相似，在介质访问控制层中使用CSMA/CA方式，以基站作为中介进行通信。</p>
<p>CSMA/CA协议的原理如下：</p>
<ol>
<li>载波侦听：当一个终端需要发送数据时，首先要侦听信道上是否有其他终端正在传输数据。如果信道上没有其他终端在发送数据，则该终端可以开始发送数据；如果信道上有其他终端正在发送数据，则该终端需要等待一段时间再重复这个过程。</li>
<li>随机退避：如果两个终端同时开始发送数据，就会发生冲突。当发生冲突时，两个终端都会停止发送数据，并随机等待一段时间后再次尝试发送数据，以避免再次发生冲突。这个等待时间是随机的，并且每次发生冲突后都会加倍。</li>
<li>冲突避免：为了进一步减少冲突的发生，CSMA/CA协议引入了一种称为“RTS/CTS握手”的机制。在发送数据之前，发送端会先发送一个请求发送（RTS）帧给接收端，请求发送端口发送数据。接收端收到请求后，回复一个清除发送（CTS）帧，表示信道空闲，发送端可以开始发送数据。在这个过程中，其他终端都会保持沉默，避免对信道的干扰。</li>
<li>重传机制：如果数据在传输过程中发生错误，接收端会发送一个确认（ACK）帧，表示收到了正确的数据。如果发送端没有收到确认帧，则会认为数据发送失败，需要重新发送数据。</li>
</ol>
<h4 id="3-4-4-IEEE802-11a"><a href="#3-4-4-IEEE802-11a" class="headerlink" title="3.4.4 IEEE802.11a"></a>3.4.4 IEEE802.11a</h4><p>在物理层利用5GHz频段，最大传输速度可达54Mbps的一种无线通信标准，与IEEE802.11b/g存在一定的兼容性问题，但是市场上已经有支持这两方面的基站产品，再加上它不适用2.4GHz频段，因此也不易受干扰</p>
<h4 id="3-4-5-IEEE802-11n"><a href="#3-4-5-IEEE802-11n" class="headerlink" title="3.4.5 IEEE802.11n"></a>3.4.5 IEEE802.11n</h4><p>IEEEE802.11n实在IEEE802.11g和IEEE802.11a的基础上，采用同步多条天线的MIMO技术，实现高速无线通信的一种标准，在物理层使用2.4GHz或5GHz频段。在使用5GHz频段的情况下，如果不受其他2.4GHz频段系统的干扰，IEEE802.11n可以达到IEEE802.11a/b/g的几倍带宽（40MHz)，最大传输速度可以达到150Mps</p>
<h4 id="3-4-6-使用无线LAN时的注意事项"><a href="#3-4-6-使用无线LAN时的注意事项" class="headerlink" title="3.4.6 使用无线LAN时的注意事项"></a>3.4.6 使用无线LAN时的注意事项</h4><p>无线LAN允许使用者可以自由地移动位置、自由地放置设备，通过无线电波实现较广范围的通信，意味着在通信范围内，任何人都可以使用该无线LAN，因此会有被盗听或篡改的危险。</p>
<p>在无线LAN的标准中，为防止盗听或篡改，已定义可以对传输数据进行加密。</p>
<p>此外，无线LAN可以无需牌照使用特定频段，所以可能会受到其他通信设备的干扰，导致信号不稳定。</p>
<h4 id="3-4-7-蓝牙"><a href="#3-4-7-蓝牙" class="headerlink" title="3.4.7 蓝牙"></a>3.4.7 蓝牙</h4><p>蓝牙与IEEE802.11b/g类似，是使用2.4GHz频率无线电波的一种标准</p>
<h4 id="3-4-8-WIMAX"><a href="#3-4-8-WIMAX" class="headerlink" title="3.4.8 WIMAX"></a>3.4.8 WIMAX</h4><p>WiMAX是使用微波在企业或家庭使用无线通信的一种方式。它如DSL或FTTH一样，是实现无线网络关键步骤的一种方式。</p>
<h4 id="3-4-9-ZigBee"><a href="#3-4-9-ZigBee" class="headerlink" title="3.4.9 ZigBee"></a>3.4.9 ZigBee</h4><p>ZigBee主要应用于家电的远程控制，是一种短距离，低功耗的无线通信技术，它最多允许65536个终端之间互连通信。ZigBee的传输速度随着所使用的频率有所变化。</p>
<h3 id="3-5-PPP"><a href="#3-5-PPP" class="headerlink" title="3.5 PPP"></a>3.5 PPP</h3><h4 id="3-5-1-PPP定义"><a href="#3-5-1-PPP定义" class="headerlink" title="3.5.1 PPP定义"></a>3.5.1 PPP定义</h4><p>PPP是指点对点，即1对1连接计算机的协议。PPP相当于位于OSI参考模型第2层的数据链路层。</p>
<p>PPP是纯粹的数据链路层，与物理层没有任何关系。仅有PPP无法实现通信，还需要有物理层的支持。以太网是在物理层和数据链路层上运行的协议。</p>
<h4 id="3-5-2-LCP和NCP"><a href="#3-5-2-LCP和NCP" class="headerlink" title="3.5.2 LCP和NCP"></a>3.5.2 LCP和NCP</h4><p>在开始进行数据传输前，要先建立一个PPP级的连接，当这个连接建立以后就可以进行身份认证、压缩与加密。</p>
<p>在PPP的主要功能中包含两个协议：一个是不依赖上层的LCP协议，另一个是依赖上层的NCP协议，如果上层是IP，此时的NCP也叫做IPCP。</p>
<p>LCP(Link Control Protocol)主要负责建立和断开连接、设置最大接收单元(MRU,Maximum Receive Unit)、设置验证协议(PAP或CHAP)以及设置是否进行通信质量的监控。</p>
<p>IPCP（IP Control Protocol）负责IP地址设置以及是否进行TCP/IP首部压缩等设置</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401110429595.png" srcset="/img/loading.gif" lazyload alt="PPP"></p>
<p>通过PPP连接时，通常需要进行用户名密码的验证，并且对通信两端进行双方向的验证。其验证协议有两种，分别是PAP和CHAP</p>
<p>PAP是PPP连接建立时，需要两次握手进行用户名和密码验证。其中密码是明文方式传输，因此一般用户安全要求并不很高的环境，否则会有窃听或盗用连接的危险。</p>
<p>PAP（Password Authentication Protocol）是PPP协议族中的一种简单的认证协议，用于在PPP链路上进行用户身份验证。它的原理如下：首先被认证方向认证方发送认证请求（包含用户名和密码），以明文形式进行传输，认证方接到认证请求，再根据被认证方发送来的用户名去到自己的数据库认证用户名密码是否正确，如果密码正确，PAP认证通过，如果用户名密码错误，PAP认证未通过。</p>
<p>CHAP则使用一次性密码OTP，可以有效防止窃听。此外，在建立连接后还可以进行定期的密码交换，用来检验对端是否中途被替换。</p>
<p>CHAP原理：<br>在CHAP认证过程中，客户端需要使用自己的密码对服务端发送的挑战值进行计算，生成一个响应值。具体来说，计算的过程如下：</p>
<ol>
<li>客户端接收到服务端发送的挑战值后，将自己的密码和挑战值拼接在一起，使用一个哈希算法（如MD5）对拼接后的字符串进行摘要计算。</li>
<li>客户端将计算出的摘要作为响应值发送给服务端。</li>
<li>服务端接收到客户端发送的响应值后，按照同样的方式计算摘要，并与客户端发送的响应值进行比较。如果两者相同，则认为客户端的身份验证通过，否则认为验证失败。</li>
</ol>
<p>在CHAP认证过程中，客户端不是将自己的密码明文发送给服务端，而是将密码和挑战值进行结合，使用哈希算法计算出一个摘要后发送给服务端。这样做的好处在于，即使攻击者能够截获认证请求，也无法获取密码的明文，从而增加了认证的安全性。</p>
<h4 id="3-5-3-PPP的帧格式"><a href="#3-5-3-PPP的帧格式" class="headerlink" title="3.5.3 PPP的帧格式"></a>3.5.3 PPP的帧格式</h4><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401132318029.png" srcset="/img/loading.gif" lazyload alt="PPP的帧格式"></p>
<p>标志码用来区分每个帧，这一点与HDLC协议非常相似。</p>
<p>HDLC就是在每个帧的前后加上一个8位字节“01111110”用来区分帧。这一个8位字节叫做标志码，在这两个标志码中间不允许出现连续6个以上的“1“，因此在发送帧的时候，当出现连续5个”1“时后面必须插入一个0。而当接收端在接收帧的时候，如果收到连续的5个”1“且后面跟着的是0，就必须删除。由于最多只会出现5个连续的”1“，就可以比较容易地通过标志码区分帧的起始与终止。而PPP标准帧格式完全一致。</p>
<h4 id="3-5-4-PPPoE"><a href="#3-5-4-PPPoE" class="headerlink" title="3.5.4 PPPoE"></a>3.5.4 PPPoE</h4><p>单纯的以太网没有验证功能，也没有建立和断开连接的处理，因此无法按时计费，而如果采用PPPoE管理以太网连接，就可以利用PPP的验证等功能使各家ISP可以有效的管理终端用户的使用。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401133434714.png" srcset="/img/loading.gif" lazyload alt="PPPoE"></p>
<h3 id="3-6-其他数据链路"><a href="#3-6-其他数据链路" class="headerlink" title="3.6 其他数据链路"></a>3.6 其他数据链路</h3><h4 id="3-6-1-ATM"><a href="#3-6-1-ATM" class="headerlink" title="3.6.1 ATM"></a>3.6.1 ATM</h4><p>ATM是以一个叫做信元（5字节首部加48字节数据）的单位进行传输的数据链路，由于其线路占用时间短和能够高效传输大容量数据等特点主要用于广域网络的连接。</p>
<p><strong>ATM的特点：</strong>ATM是面向连接的一种数据链路，因此在进行通信传输之前一定要设置通信线路。ATM中没有类似以太网和FDDI那种发送权限的限制，它允许在任何时候发送任何数据，因此，当大量计算机同时发送大量数据时容易引发网络拥堵甚至使网络进入收敛状态，为了防止这一现象的出现，ATM中增加了限制带宽的功能。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401133857974.png" srcset="/img/loading.gif" lazyload alt="ATM"></p>
<p><strong>同步与异步：</strong>以多个通信设备通过一条电缆相连的情况为例。这样连接的设备叫做TDM（时分复用设备）。TDM通常在两端TDM设备之间同步的同时，按照特定的时间将每个帧分成若干个时隙，按照顺序发送给目标地址。但是可能会造成许多空闲的时隙，利用率比较低。</p>
<p>ATM扩展了TDM，能够有效地提高线路的利用率，ATM在TDM的时隙中放入数据时，并非按照线路的顺序而是按照数据到达的顺序放入。</p>
<p>但是数据包传输顺序并不是简单地按照数据包到达的顺序进行发送，而是要根据VCI/VPI的信息对ATM单元进行排队和调度，排队与调度的原则主要是根据不同的服务质量要求，进行优先级、带宽保障、拥塞控制等方面的设置，从而保证网络的性能和数据流的传输顺序。</p>
<p>但是这样的话接收端必须要能够辨认真正的内容，为此发送端需要附加一个5字节的包首部，包含VPI、VCI等识别码用来标识具体的通信类型。这种VPI与VCI的值只在直连通信的两个ATM交换机之间设置，在其他交换机之间意思则完全不同。</p>
<p>ATM中信元传输所占用的时隙不固定，一个帧所占用的时隙数也不固定，而且时隙之间并不要求连续，这些特点可以有效减少空闲时隙，从而提高线路的利用率，但是需要额外附加5个字节的首部，增加了网络的开销，一定程度上降低了通信速度。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401140455309.png" srcset="/img/loading.gif" lazyload alt="同步与异步"></p>
<p><strong>ATM与上层协议</strong></p>
<p>在以太网中一个帧最大可传输1500字节，FDDI可以最大传输4352字节，而ATM的一个信元只能发送固定的48字节数据。这48字节的数据部分若包含IP首部和TCP首部，则基本无法存放上层的数据，为此一般不会单独使用ATM，而是使用上层的AAL（ATM Adapter Layer)。在上层为IP的情况下，则叫做AAL5。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401135759880.png" srcset="/img/loading.gif" lazyload alt></p>
<p>信元丢失一个，则整个IP包就相当于被损坏。此时，AAL5的帧检查位报错，导致接收端不得不丢弃所有的信元。所以出现丢失就要全部重发，重发的概率很高。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401141501021.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="3-6-2-POS"><a href="#3-6-2-POS" class="headerlink" title="3.6.2 POS"></a>3.6.2 POS</h4><p>POS是一种在SDH上进行包通信的一种协议。SDH是在光纤上传输数字信号的物理层规范。</p>
<h4 id="3-6-3-FDDI"><a href="#3-6-3-FDDI" class="headerlink" title="3.6.3 FDDI"></a>3.6.3 FDDI</h4><p>FDDI叫做分布式光线数据接口，FDDI采用令牌环的访问方式，令牌环访问方式在网络拥堵的情况下极容易导致网络收敛。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401142517793.png" srcset="/img/loading.gif" lazyload alt="FDDI"></p>
<h4 id="3-6-4-Token-Ring"><a href="#3-6-4-Token-Ring" class="headerlink" title="3.6.4 Token Ring"></a>3.6.4 Token Ring</h4><p>令牌环网源自IBM开发的令牌环LAN技术，但是由于价格一直居高不下以及所支持的提供商较少未能得到普及。</p>
<h4 id="3-6-5-100VG-AnyLAN"><a href="#3-6-5-100VG-AnyLAN" class="headerlink" title="3.6.5 100VG-AnyLAN"></a>3.6.5 100VG-AnyLAN</h4><p>它以语音级的3类UTP电缆实现100Mbps的传输速率，它的数据帧格式既能应对以太网又能应对令牌环网。在传输方式上，它采用扩展了令牌传递方式的需求优先访问方式。</p>
<h4 id="3-6-6-光纤通道"><a href="#3-6-6-光纤通道" class="headerlink" title="3.6.6 光纤通道"></a>3.6.6 光纤通道</h4><p>实现数据通信的一种数据链路</p>
<h4 id="3-6-7-HIPPI"><a href="#3-6-7-HIPPI" class="headerlink" title="3.6.7 HIPPI"></a>3.6.7 HIPPI</h4><p>HIPPI用于连接超大型计算机传输速率为800Mbps或1.6Gbps，铜缆的实际传输距离在25米以内，但是光纤作为传输介质时，，可以延长到数公里</p>
<h4 id="3-6-8-IEEE1394"><a href="#3-6-8-IEEE1394" class="headerlink" title="3.6.8 IEEE1394"></a>3.6.8 IEEE1394</h4><p>也叫FireWire或i.Link，是面向家庭的局域网，主要用于连接AV等计算机外围设备。</p>
<h4 id="3-6-9-HDMI"><a href="#3-6-9-HDMI" class="headerlink" title="3.6.9 HDMI"></a>3.6.9 HDMI</h4><p>高清晰度多媒体接口，他可以通过一根缆线实现图像和声音等数字信号的高品质传输，曾主要用于DVD/蓝光播放器……</p>
<h4 id="3-6-19-iSCSI"><a href="#3-6-19-iSCSI" class="headerlink" title="3.6.19 iSCSI"></a>3.6.19 iSCSI</h4><p>它是将个人电脑连接硬盘的SCSI标准应用于TCP/IP网络上的一种标准。它把SCSI的命令和数据包含进IP包内，进行数据传输。由此，人们就可以像使用个人电脑内嵌的SCSI硬盘一样使用网络上直连的大规模硬盘了。</p>
<h4 id="3-6-11-InfiniBand"><a href="#3-6-11-InfiniBand" class="headerlink" title="3.6.11 InfiniBand"></a>3.6.11 InfiniBand</h4><p>InfiniBand是针对高端服务器的一种超高速传输接口技术，它最大的特点是高速，高可靠性以及低延迟。它支持多并发连接，将多个线缆合并为一个线缆。</p>
<h4 id="3-6-12-DOCSIS"><a href="#3-6-12-DOCSIS" class="headerlink" title="3.6.12 DOCSIS"></a>3.6.12 DOCSIS</h4><p>DOCSIS是有线电视传输数据的行业标准，定义了有线电视的同轴电缆与Cable Modem的连接及其与以太网进行转换的具体规范。</p>
<h4 id="3-6-13-高速PLC"><a href="#3-6-13-高速PLC" class="headerlink" title="3.6.13 高速PLC"></a>3.6.13 高速PLC</h4><p>高速PLC是指在家里或办公室内利用电力线上数MHz~数十MHz频带范围，实现数十Mbps-200Mbps传输速率的一种通信方式。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401143741597.png" srcset="/img/loading.gif" lazyload alt></p>
<h2 id="第四章-IP协议"><a href="#第四章-IP协议" class="headerlink" title="第四章 IP协议"></a>第四章 IP协议</h2><p>IP相当于OSI参考模型中的第三层—网络层</p>
<p>网络层的主要作用是“实现终端结点之间的通信”，这种终端结点之间的通信也叫“点对点通信“。</p>
<p>数据链路层的主要作用是在互连同一种数据链路的结点之间进行包传递，而一旦跨越多种数据链路，就需要网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据传输。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402184808012.png" srcset="/img/loading.gif" lazyload alt></p>
<h3 id="4-1-IP基础知识"><a href="#4-1-IP基础知识" class="headerlink" title="4.1 IP基础知识"></a>4.1 <strong>IP基础知识</strong></h3><p>IP大致分成三大作用模块：IP寻址，路由、IP分包与组包。</p>
<p>MAC地址是用来标识同一个链路中不同计算机的一种识别码。</p>
<p>IP地址用于在连接到网络中的所有主机中识别出进行通信的目标地址。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402185345083.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>路由控制</strong></p>
<p>路由控制是指将分组数据发送到最终目标地址的功能。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402185728181.png" srcset="/img/loading.gif" lazyload alt="路由控制"></p>
<p><strong>发送目标数据至最终目标地址：</strong>Hop译为“跳”。它是指网络中的一个区间。IP包正是在网络中一个个跳间被转发。因此IP路由也叫做多跳路由。在每一个区间内决定着包在下一跳被转发的路径。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402185930440.png" srcset="/img/loading.gif" lazyload alt></p>
<p>1跳就是利用数据链路层以下分层的功能传输数据帧的一个区间。</p>
<p>多跳路由是指路由器或主机在转发IP数据包时只指定下一个路由器或主机，而不是将到目标地址为止的所有通路全都指定出来。因为每一个区间在转发IP数据包的时候会分别指定下一跳的操作，直至包达到最终的目标地址。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402190334651.png" srcset="/img/loading.gif" lazyload alt></p>
<p>当某个IP数据包到达路由器时，路由器首先查找其目标地址，从而再决定下一步应该将这个包发往哪个路由器，然后将包发送过去。当这个IP包到达那个路由器之后，会再次经历查找下一目标地址的过程，并由该路由器转发给下一个被找到的路由器，这个过程可能会反复多次，直到找到最终的目标地址将数据包发送给这个结点。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402190643361.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>路由控制表</strong></p>
<p>为了将数据包发给目标主机，所有主机都维护这一张路由控制表，该表记录IP数据在下一步应该发给哪一个路由器，IP包将根据这个路由表在各个数据链路上传输。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402190825932.png" srcset="/img/loading.gif" lazyload alt="路由控制表"></p>
<p>IP是实现多个数据链路之间通信的协议，数据链路根据种类的不同各有特点，对这些不同数据链路的相异特性进行抽象化也是IP的重要作用之一。</p>
<p>不同数据链路最大的区别在于最大传输单元（MTU）不同</p>
<p>在以太网中MTU是1500字节，在FDDI中是4352字节，ATM则是9180字节。IP的上一层可能会要求传送比这些MTU更多字节的数据，因此必须在线路上传送比包长还要小的MTU。</p>
<p>为了解决这个问题，IP进行分片处理。所谓分片处理是指，将较大的IP包分成多个较小的IP包，分片的包到了对端目标地址以后会再被组合起来传给上一层，即从IP的上层来看，它完全可以忽略数据包在途中的各个数据链路上的MTU，而只需按照源地址发送的长度接收数据包。IP就是以这种方式抽象化了数据链路层，使得从上层更不容易看到底层网络构造的细节。</p>
<p><strong>IP属于面向无连接型</strong></p>
<p>为什么IP采用面向无连接呢？</p>
<p>主要原因有两点：一是为了简化，而是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。此外，每次通信之前都要事先建立连接，又会降低处理速度。需要有连接时，可以委托上一层提供此服务，因此，IP为了实现简单化与高速化采用面向无连接的方式。</p>
<p>既然IP已经是提供无连接了，如果需要可靠传输，就需要上一层来做这个服务，所以TCP采用了面向有连接型服务，负责保证对端主机确实接收到数据。</p>
<p><strong>为什么不让IP具有可靠传输的功能，从而把这两种协议合并在一起呢？</strong></p>
<p>如果要一种协议规定所有的功能和作用，那么该协议的具体实施和编程就会变得非常复杂，无法轻易实现。相比之下，按照网络分层，明确定义每层协议的作用和责任以后，针对每层具体的协议进行编程会更加有利于该协议的实现。网络通信中如果能进行有效的分层，就可以明确TCP与IP各自协议的最终目的，也有利于后续对这些协议进行扩展和性能上的优化，分层也简化了每个协议的具体实现。</p>
<h3 id="4-2-IP地址的基础知识"><a href="#4-2-IP地址的基础知识" class="headerlink" title="4.2 IP地址的基础知识"></a>4.2 IP地址的基础知识</h3><p>IP地址（IPv4地址）由32位正整数来表示</p>
<p>IP地址由<strong>网络标识</strong>和<strong>主机标识</strong>两部分组成。</p>
<p>网络标识在数据链路的每个段配置不同的值，网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP地址的主机标识则不允许在同一网段内重复出现。</p>
<p>IP包被转发到途中某个路由器时，正是利用目标IP地址的网络标识进行路由。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402194400904.png" srcset="/img/loading.gif" lazyload alt></p>
<p>现在以子网掩码区分网络标识和主机标识。</p>
<p><strong>IP地址的分类</strong></p>
<p>IP地址地址分成四个级别，分别是A类、B类、C类、D类，根据IP地址中从第1位到第4位的比特列对其网络标识和主机标识进行区分。</p>
<p><strong>A类地址：</strong>是以首位为“0”开头的地址，从第1位到第8位是它的网络标识，用十进制表示的话，0.0.0.0~127.0.0.0是A类的网络地址，A类地址的后24位相当于主机标识。</p>
<p><strong>B类地址：</strong>是前两位以”10”开头的地址。从第1位到第16位是它的网络标识。128.0.0.0~191.255.0.0是B类的网络地址。B类地址的后16位相当于主机标识。</p>
<p><strong>C类地址：</strong>是前三位为“110”的地址，从第1位到第24位是它的网络标识，用十进制表示的话，<strong>192.0.0.0~239.255.255.0</strong>是C类的网络地址，C类地址的后8位相当于主机标识。</p>
<p><strong>D类地址：</strong>D类IP地址是前四位为“1110”的地址，从第1位到第32位是它的网络标识，224.0.0.0~239.255.255.255是D类的网络地址，D类地址没有主机标识，常被用于多播。</p>
<p>表示IP地址的时候，比特位表示主机地址时，不可以全部为0或全部为1，全部为0只有在表示对应的网络地址或IP地址不可获知的情况下才使用，而全部为1的主机地址通常作为广播地址，所以分配的时候，需要去掉这两个情况。</p>
<p><strong>广播地址：</strong>广播地址用于在同一个链路中互相连接的主机之间发送数据包。</p>
<p>广播分为本地广播和直接广播。</p>
<p>在本网络内的广播叫做本地广播，在不同的网络之间的广播叫做直接广播。例如网络地址为192.168.0.0/24的主机向192.168.1.255/24的目标地址发送IP包，收到这个包的路由器，将数据转发给192.168.1.0/24，从而使得所有192.168.1.1~192.168.1.254的主机都能收到这个包。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230403084856420.png" srcset="/img/loading.gif" lazyload alt="本地广播和直接广播"></p>
<p><strong>IP多播：</strong></p>
<p>多播用于将包发送给特定组内的所有主机，这里需要考虑一个效率的问题。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230403085113704.png" srcset="/img/loading.gif" lazyload alt="单播、广播、多播通信"></p>
<p><strong>IP多播与地址</strong></p>
<p>多播使用D类地址，首位开始4位是“1110”，剩下的28位可以成为多播的组编号。从224.0.0.0到239.255.255.255都是多播地址的可用范围，其中从224.0.0.0到224.0.0.255不需要路由控制，在同一个链路中也能实现多播，而在这个范围之外设置多播地址会给全网所有组内成员发送多播的包。</p>
<p><strong>子网掩码</strong></p>
<p>网络标识相同的计算机必须同属于同一个链路。</p>
<p>引入子网后，一个IP地址就有了两种识别码，一个是IP地址本身，另一个是表示网络部的子网掩码。它对应的IP地址网络标识部分的位全部为“1”，对应IP地址主机标识的部分则全部为“0”</p>
<p><strong>CIDR与VLSM</strong></p>
<p>由于向各种组织份分配IP地址都以A类，B类，C类等分类为单位进行，最终的结果就是无法满足需求。</p>
<p>所以采用了任意长度分割IP地址的网络标识和主机标识，这种方式叫做CIDR（无类型域间选路）</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418183136847.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418183144828.png" srcset="/img/loading.gif" lazyload alt></p>
<p>可以将多个C类地址合并为一个网络</p>
<p>但是当网络内部采用固定长度的子网掩码机制的时候，域内所有的子网掩码都得使用同样的长度，但是有些部分可能有500台主机，另一些部分可能只有50台主机，所以采用同样的标准，很难构建一个高效的网络结构，所以出现了<strong>VLSM</strong>(可变长子网掩码)，它可以通过域间路由协议转换为RIP2以及OSPF实现。</p>
<p><strong>全局地址与私有地址</strong></p>
<p>使用唯一地址的话，会有IP地址耗尽的危险，所以出现了一个新技术，不要求为每一台主机或路由器分配一个固定的IP地址，而是在必要的时候只为相应数量的设备分配唯一的IP地址。</p>
<p>对于那些没有连接互联网的独立网络中的主机，只要保证在这个网络内地址唯一，可以不考虑互联网即可配置相应的IP地址，即私有网络的IP地址，如下：</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418184024252.png" srcset="/img/loading.gif" lazyload alt></p>
<p>包含在这个范围内的IP地址都属于私有IP，而在此之外的IP地址称为全局IP，私有IP最早没有计划连接互联网，而只用于互联网之外的独立网络。</p>
<p><strong>私有IP地址结合NAT技术已成为现在解决IP地址分配问题的主流方案</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418184256891.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>全局地址由谁决定</strong></p>
<p>在世界范围内，全局IP由ICANN进行管理，互联网被广泛商用之后，人们向ISP申请接入互联网的同时也会申请全局IP地址</p>
<h3 id="4-3-路由控制"><a href="#4-3-路由控制" class="headerlink" title="4.3 路由控制"></a>4.3 路由控制</h3><p>发送数据包时所使用的地址是网络层的地址，即IP地址，但是仅仅有IP地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于”指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。</p>
<p>该路由控制表的形成方式：<strong>手动设置</strong>和<strong>路由器与其他路由器相互交换信息时自动刷新</strong>，前者也叫静态路由控制，后者叫做动态路由控制</p>
<p><strong>1. IP地址与路由控制</strong></p>
<p>IP地址的网络地址部分用于进行路由控制，路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在发送IP包时，首先需要确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。如果路由器控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</p>
<p><strong>默认路由</strong>：指路由表中任何一个地址都能与之匹配的记录，一般被标记为0.0.0.0/0或default</p>
<p><strong>主机路由</strong>：IP地址/32也被称为主机路由。例如，192.168.153.15/32就是一种主机路由</p>
<p><strong>环回地址</strong>：环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。计算机使用一个特殊的IP地址127.0.0.1作为环回地址，与该地址具有相同意义的是一个叫做localhost的主机名</p>
<p><strong>2. 路由控制表的聚合</strong></p>
<p>能够缩小路由表的大小是它最大的优势，路由表越大，管理它所需要的内存和CPU也就越多，并且查找路由表的时间也会越长，导致转发IP数据包的性能下降，所以路由表的大小很关键。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418190153753.png" srcset="/img/loading.gif" lazyload alt="路由聚合"></p>
<h3 id="4-4-IP分割处理与再构成处理"><a href="#4-4-IP分割处理与再构成处理" class="headerlink" title="4.4 IP分割处理与再构成处理"></a>4.4 IP分割处理与再构成处理</h3><p><strong>1. 数据链路不同，MTU则相异</strong></p>
<p>数据链路的类型不同，使用目的不同，可承载的MTU也就不同，鉴于IP属于数据链路上一层，它必须不受限于不同数据链路的MTU大小，但是IP抽象化了底层的数据链路。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418190300106.png" srcset="/img/loading.gif" lazyload alt><strong>2. IP报文的分片与重组</strong></p>
<p>任何一台主机都有必要对IP分片进行相应的处理，分片往往在网络上遇到比较大的报文无法一下子发送出去才进行处理。</p>
<p>路由器来做分片，目标主机来做重组</p>
<p><strong>为什么？</strong></p>
<p>无法保证IP数据报是否经由同一个路径传送。因此，途中即使等待片刻，数据报也有可能无法到达目的地，因此在途中某一处被重新组装，但如果下一站再经过其他路由时还会面临被分片的可能，这会给路由器带来多余的负担，也会降低网络传送效率，出于这些原因，在终结点端重组分片了的IP数据报成为现行的规范。</p>
<p><strong>3. 路径MTU发现</strong></p>
<p>分片机制也有它的不足。首先，路由器的处理负荷加重，另一方面，随着人们对网络安全的要求提高，路由器需要做的其他处理越来越多，如网络过滤等。其次，在分片处理中，一旦某个分片丢失，则会造成整个IP数据报作废。</p>
<p>所以<strong>路径MTU发现</strong>应运而生</p>
<p>路径MTU是指从发送端主机到接收端主机之间不需要分片时最大MTU的大小，即路径中存在的所有数据链路中最小的MTU，而路径MTU发送从发送主机按照路径MTU的大小将数据报分片后进行发送，进行路径MTU发现，就可以避免在中途的路由器上进行分片处理，也可以在TCP中发送更大的包。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418194932522.png" srcset="/img/loading.gif" lazyload alt="UDP路径MTU发现"></p>
<p><strong>路径MTU发现的工作原理</strong></p>
<p>首先在发送端主机发送IP数据报时将其首部的分片禁止标志位设置为1，根据这个标志位，途中的路由器即使遇到需要分片才能分片处理的大包，也不会分片，而是将包丢弃，随后通过一个ICMP的不可达消息将数据链路上MTU的值发送给主机。</p>
<p>下一次，从发送给同一个目标主机的IP数据报获得ICMP所通知的MTU值以后，将它设置为当前MTU，发送主机根据这个MTU对数据报进行分片处理。如此反复，直到数据报被发送到目标主机为止没有再收到任何ICMP，就认为最后一次ICMP所通知的MTU是一个合适的MTU值。</p>
<p>上面是UDP的例子，在TCP的情况下，根据路径MTU的大小计算出最大段长度，然后再根据这些信息进行数据报的发送。因此在TCP中如果采用MTU发现，IP层则不会再进行分片处理。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418200446401.png" srcset="/img/loading.gif" lazyload alt="TCP路径MTU发现"></p>
<h3 id="4-5-IPv6"><a href="#4-5-IPv6" class="headerlink" title="4.5 IPv6"></a>4.5 IPv6</h3><p>IPv6是为了根本解决IPv4地址耗尽的问题而被标准化的网际协议</p>
<p>IPv4的地址长度为4个8位字节，即32比特</p>
<p>IPv6的地址长度为128位，8个16位字节</p>
<p><strong>IPv6的特点</strong></p>
<p>（1）IP地址的扩大与路由控制表的聚合</p>
<p>（2）性能提升</p>
<p>（3）支持即插即用功能</p>
<p>（4）采用认证与加密功能</p>
<p>（5）多播、Mobile IP成为扩展功能</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418202416790.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>全局单播地址</strong></p>
<p>n=48，m=16（下图貌似有误）</p>
<p>前64位为网络标识，后64位为主机标识</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418202601706.png" srcset="/img/loading.gif" lazyload alt="全局单播地址"></p>
<p><strong>链路本地单播地址</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418202825142.png" srcset="/img/loading.gif" lazyload alt="链路本地单播地址"></p>
<p>在同一个链路中的通信，通常接口ID保存64比特版的MAC地址</p>
<p><strong>唯一本地地址</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418203844341.png" srcset="/img/loading.gif" lazyload alt="唯一本地地址"></p>
<p>唯一本地地址是不进行互联网通信时所使用的地址。设备控制的限制型网络以及金融机关的核心网等会与互联网隔离。为了提高安全性，企业内部的网络与互联网通信时通常会通过NAT或网关进行。</p>
<p><strong>IPv6分段处理</strong></p>
<p>IPv6的分片处理只在作为起点的发送端主机上进行，路由器不参与分片，这也是为了减少路由器的负荷，提高网速。</p>
<h3 id="4-6-IPv4首部"><a href="#4-6-IPv4首部" class="headerlink" title="4.6 IPv4首部"></a>4.6 IPv4首部</h3><p>通过IP进行通信的时候，需要在数据的前面加入IP首部信息。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418204307327.png" srcset="/img/loading.gif" lazyload alt="IPv4首部"></p>
<p><strong>版本</strong>：4比特，表示表示IP首部的版本号，IPv4的版本号即为4</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418204415166.png" srcset="/img/loading.gif" lazyload alt="版本"></p>
<p><strong>首部长度：</strong>4比特构成，表明IP首部的大小，单位为4字节。对于没有可选项的IP包，首部长度则设置为“5”，也就是说，当没选项时，IP首部的长度为20字节</p>
<p><strong>区分服务</strong>：8比特构成（TOS：Type of service），用来表明服务质量</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418204750215.png" srcset="/img/loading.gif" lazyload alt="区分服务"></p>
<p>这个值通常由应用指定，但是现在也鼓励这种结合应用的特性设定TOS的方法，然而在目前，几乎所有的网络都无视这些字段。这不仅仅是因为在符合质量的情况下按其要求发送本身的功能实现起来十分困难，还因为若不符合质量要求就可能会产生不公平的现象，所以基本不咋用，有人提出将这个字段本身再划分为DSCP何ECN两个字段</p>
<p><strong>DSCP段和ECN段</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418205152904.png" srcset="/img/loading.gif" lazyload alt="DSCP段和ECN段"></p>
<p>DSCP，用来进行质量控制；</p>
<p>如果3-5位的值为0,0-2位则被称为类别选择代码点。这样就可以像TOS的优先度那样提供8种类型的质量控级别，对于每一种级别所采取的措施则由提供DiffServ的运营管理者制定。为了与TOS保持一致，值越大优先度也越高，如果第5位为1，表示实验或本地使用的意思。</p>
<p>ECN（显式拥塞通告）用来报告网络拥堵情况，由两个比特构成</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418205813198.png" srcset="/img/loading.gif" lazyload alt="ECN"></p>
<p>第6位的ECT用以通告上层TCP层协议是否处理ECN，当路由器在转发ECN为1的包的过程中，如果出现网络拥堵的情况，就将CE位设置为1</p>
<p><strong>总长度</strong></p>
<p>表示IP首部与数据部分合起来的总字节数，该字段长16比特，因此IP包的最大长度为65535字节</p>
<p><strong>标识</strong></p>
<p>16比特构成，用于分片重组</p>
<p><strong>标志</strong></p>
<p>3比特构成，表示包被分片的相关信息</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418210041270.png" srcset="/img/loading.gif" lazyload alt="标志"></p>
<p><strong>片偏移（FO：Fragment Offset）</strong>：</p>
<p>由13比特构成，用来标识被分片的每一个分段相对于原始数据的位置。第一个分片对应的位置的值为0，由于FO域占13位，因此最多可以表示8192个相对位置，单位为8字节，因此最多可以表示8*8192=65536字节的位置</p>
<p><strong>生存时间（TTL：Time To Live）：</strong></p>
<p>8比特构成，以秒为单位记录当前包在网络上应该生存的期限，然而在实际中它是指可以中转多少个路由器的意思。每经过一个路由器，TTL会减少1，直到变成0则丢弃该包</p>
<p><strong>协议</strong>：8比特构成，表示IP首部的下一个首部隶属于哪一个协议</p>
<p>如4代表IP，6代表TCP，17代表UDP</p>
<p><strong>首部校验和（Header Checksum)：</strong></p>
<p>由16比特构成，也叫IP首部校验和。该字段只校验数据报的首部，不校验数据部分，用来确认IP数据报不被破坏。</p>
<p><strong>源地址</strong>：32比特，表示发送端IP地址</p>
<p><strong>目标地址</strong>：32比特，表示接收端IP地址</p>
<p><strong>可选项</strong>：长度可变，通常在进行实验或诊断时使用。包含如下几点信息：</p>
<p>（1）安全级别</p>
<p>（2）源路径</p>
<p>（3）路径记录</p>
<p>（4）时间戳</p>
<p><strong>填充</strong>：也称作填充物。在有可选项的情况下，首部长度可能不是32比特的整数倍，通过向字段填充0，调整为32比特的整数倍</p>
<p><strong>数据：</strong>存入数据，将IP上层协议的首部也作为数据进行处理</p>
<h3 id="4-7-IPv6首部"><a href="#4-7-IPv6首部" class="headerlink" title="4.7 IPv6首部"></a>4.7 IPv6首部</h3><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418211122022.png" srcset="/img/loading.gif" lazyload alt="IPv6首部"></p>
<p>省略了首部校验和字段，因此路由器不再计算校验和，提高了包的转发效率。</p>
<p><strong>版本</strong>：与IPv4一样，4比特</p>
<p><strong>通信量类：</strong>相当于IPv4中的TOS字段，8比特</p>
<p><strong>流标号：</strong>20比特，准备用于服务质量控制。不使用Qos时每一位全部设置为0。</p>
<p>在进行服务质量控制时，将流标号设置为一个随机数，然后利用一种可以设置流的协议RSVP在路由器上进行Qos设置。当某个包在发送途中需要Qos时，需要附上RSVP预想的流标号。路由器接收到这样的IP包先后将流标号作为查找关键字，迅速从服务质量控制信息中查找并做相应处理。</p>
<p><strong>有效载荷长度：</strong>有效载荷是指包的数据部分。IPv4的TL是指包括首部在内的所有长度，然而IPv6中的这个Playload Length不包括首部，只表示数据部分的长度。</p>
<p><strong>下一个首部：</strong>相当于IPv4的协议字段，由8比特构成</p>
<p><strong>跳数限制：</strong>8比特构成，与IPv4中的TTL意思相同</p>
<p><strong>源地址：</strong>由128比特构成，表示发送端IP地址</p>
<p><strong>目标地址：</strong>128比特构成，表示接收端IP地址</p>
<p><strong>IPv6扩展首部</strong>：扩展首部通常介于IPv6首部与TCP/UDP首部中间。在IPv4中可选项长度固定为40字节，但是在IPv6中没有这样的限制，也就是说，IPv6的扩展首部可以是任意长度。扩展首部当中还可以包含扩展首部协议以及下一个扩展首部字段。</p>
<p>IPv6首部中没有标识以及标志字段，在需要对IP数据报进行分片时，可以使用扩展首部。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418212635557.png" srcset="/img/loading.gif" lazyload alt="扩展首部-1"></p>
<p>具体的扩展首部如下，当需要对IPv6的数据报进行分片时，可以设置为扩展域为44，使用IPsec时，可以使用50,51的ESP、AH</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418212805812.png" srcset="/img/loading.gif" lazyload alt="扩展首部-2"></p>
<h2 id="第5章-IP协议相关技术"><a href="#第5章-IP协议相关技术" class="headerlink" title="第5章 IP协议相关技术"></a>第5章 IP协议相关技术</h2><p>IP旨在让最终目标主机收到数据包，但是在这一过程中仅仅有IP是无法实现通信的，必须还要能够解析主机名称和MAC地址的功能，以及数据包在发送过程中异常情况处理的功能。此外还会涉及IP必不可少的其他功能。</p>
<h3 id="5-1-DNS"><a href="#5-1-DNS" class="headerlink" title="5.1 DNS"></a>5.1 DNS</h3><p>IP地址是由一串数据序列组成，不好记，所以引入一个叫做主机标识码的东西。这种识别方式是指为每台计算机赋以唯一的主机名，在进行网络通信的时候可以直接使用主机名称而无需输入一大串的IP地址，此时，系统自动将主机名转换为具体的IP地址。</p>
<p>DNS系统就是用于管理主机名和IP地址之间对应关系的系统，换句话说就是可以维护一个用来表示组织内部主机名和IP地址之间的对应关系的数据库。</p>
<p><strong>域名服务器</strong>是指管理域名的主机和相应的软件，可以管理所在分层的域的相关信息。</p>
<p>域名和域名服务器需要按照分层进行设置，如果域名服务器宕机，那么针对该域的DNS服务器查询也就无法正常工作。因此为了提高容灾能力，一般会设置至少两个以上的域名服务器，一旦第一个域名服务器无法提供查询的时候，就会自动转到第二个甚至第三个域名服务器上进行，以此可以按照顺序进行灾备处理。</p>
<p><strong>解析器：</strong>进行DNS查询的主机和软件叫做DNS解析器。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419203908483.png" srcset="/img/loading.gif" lazyload alt="DNS查询"></p>
<p>解析器为了调查IP地址，向域名服务器进行查询处理。接收这个查询请求的域名服务器首先会在自己的数据库进行查找。如果有该域名所对应的IP地址就返回。如果没有，则根开始对这棵树按照顺序进行遍历，直到找到指定的域名服务器。解析器和域名服务器将最新了解到的信息暂时保存在缓存里，这样可以减少每次查询时的性能消耗。</p>
<h3 id="5-2-ARP"><a href="#5-2-ARP" class="headerlink" title="5.2 ARP"></a>5.2 ARP</h3><p>在数据链路层，进行实际通信需要了解每个IP地址所对应的MAC地址</p>
<p><strong>ARP</strong>是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不在同一个链路上时，可以通过ARP查找下一跳路由器的MAC地址，不过ARP只适用于IPv4，不能用于IPv6。</p>
<p>假定主机A向同一链路上的主机B发送IP包，主机A的IP地址为172.20.1.1，主机B的IP地址为172.20.1.2，它们互不知道对方的MAC地址。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419204758212.png" srcset="/img/loading.gif" lazyload alt="主机A给主机B发送IP包"></p>
<p>主机A为了获得主机B的MAC地址，初始要通过广播发送一个ARP请求包，这个包中包含了想要了解其MAC地址的主机IP地址。如果ARP的请求包中的目标IP地址与自己的IP地址一致，那么这个节点就将自己的MAC地址塞入ARP响应包返回给主机A。</p>
<p>但是每发送一个IP数据报都要进行一次ARP请求以此确定MAC地址，那将会造成不必要的网络流量，因此，通常的做法是把获取到的MAC地址缓存一段时间。即把第一次通过ARP获取到的MAC地址作为IP对MAC的映射关系记忆到一个ARP缓存表中，下一次再向这个IP数据发送数据报时不需再重新发送ARP请求，而是直接使用这个缓存表当中的MAC地址进行数据报的发送。每执行一次ARP就可以获取想要的MAC地址。这样，在一定程度上防止了ARP包在网络上被大量广播的可能性。</p>
<p>MAC地址的缓存是有一定的期限的，超过这个期限，缓存的内容将被清除。这使得MAC地址与IP地址对应关系即使发生了变化，也依然能够将数据包正确地发送给目标地址。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419205513112.png" srcset="/img/loading.gif" lazyload alt="ARP"></p>
<p><strong>有了IP地址，为什么还需要MAC地址？</strong></p>
<p>考虑发送给其他数据链路中某一个主机时的情况</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419205850158.png" srcset="/img/loading.gif" lazyload alt="IP？MAC?"></p>
<p>主机A要给主机B发送数据，已知主机B的MAC地址，这样是无法将数据包发送过去的，因此路由器C会隔断两个网络，无法实现直接从主机A发送数据报给主机B。主机A必须要先将数据报发送给路由器C的MAC地址C1。而且，假定MAC地址用广播地址，那么路由器D也将会收到该广播消息，于是路由器D又将该消息发送给路由器C，导致数据包被重复发送两次。</p>
<p>所以IP地址和MAC地址缺一不可，同时也就有了将他们关联起来的ARP协议。</p>
<p><strong>RARP</strong>：顾明思意，将ARP反过来，从MAC地址定位IP地址的一种协议。</p>
<p>对于个人主机来说，可以自己设置IP地址，也可以通过DHCP自动分配获取IP地址，然后对于嵌入式设备来说，会遇到没有任何输入接口或无法通过DHCP动态获取IP地址的情况。</p>
<p>这时候需要RARP，架设一台RARP服务器，从而再这个服务器上注册设备的MAC地址及其IP地址，然后将这个设备接入到网络，插电启动设备时，该设备发送一条“我的MAC地址是<em>*</em>，请告诉我，我的IP地址应该是什么“的请求信息。RARP服务器接到这个消息后返回类似于”MAC地址为XXX的设备，IP地址为XXX“的信息给这个设备，而设备就根据从RARP服务器收到的应答消息设置自己的IP地址。</p>
<p><strong>代理ARP：</strong>通常ARP包会被路由器隔离，但是采用代理ARP的路由器可以将ARP请求转发给邻近的网段。由此，两个以上网段的节点之间可以像在同一个网段中一样进行通信。</p>
<h3 id="5-3-ICMP"><a href="#5-3-ICMP" class="headerlink" title="5.3 ICMP"></a>5.3 ICMP</h3><p>为了确保网络能够按照预期正常工作，一旦遇到什么问题需要立即制止问题的蔓延，为了减轻网络管理员的负担，ICMP应运而生。</p>
<p><strong>ICMP的主要功能：</strong>确认IP包时候成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网络设置等。有了这些功能，就可以获得网络是否正常、设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断。</p>
<p><strong>ICMP的消息大致分为两类：</strong>一类是通知出错原因的错误消息，另一类是用于诊断的查询消息。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419212039091.png" srcset="/img/loading.gif" lazyload alt="ICMP消息类型"></p>
<p><strong>主要的ICMP消息</strong></p>
<p><strong>ICMP目标不可达消息</strong>：IP路由器无法将IP数据包发送给目标地址时，会给发送端主机返回一个目标不可达的ICMP消息，并在这个消息中显示不可达的具体原因。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419212340609.png" srcset="/img/loading.gif" lazyload alt="ICMP目标消息不可达类型"></p>
<p>在实际中，经常会遇到错误代码是1，表示主机不可达，它是指路由表中没有该主机的信息，或者该主机没有连接到网络的意思。</p>
<p><strong>ICMP重定向消息</strong>：如果路由器发现发送端主机使用了次优的路径发送数据，那么它会返回一个ICMP重定向的消息给这个主机。在这个消息中包含了最合适的路由信息和源数据。这主要发生在路由器持有更好的路由信息的情况下，路由器会通过这样的ICMP消息给发送端主机一个更合适的发送路由。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419213008806.png" srcset="/img/loading.gif" lazyload alt="ICMP重定向消息"></p>
<p><strong>ICMP超时消息</strong>：IP包中的TTL字段减为0时该IP包被丢弃，此时IP路由器将会发送一个ICMP超时的消息给发送端主机，并通知该包已被丢弃。设置IP包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免IP包无休止地在网络上被转发。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419213215370.png" srcset="/img/loading.gif" lazyload alt="ICMP超时消息"></p>
<p><strong>ICMP回送消息：</strong>用于进行通信的主机或路由器之间，判断所发送的数据包是否成功到达对端的一种消息。</p>
<p><strong>ICMP原点抑制消息：</strong>在低速广域线路的情况下，连接WAN的路由器可能会遇到网络拥堵的问题，ICMP原点抑制消息就是为了缓和这种情况，当路由器向低速线路发送数据时，其发送队列的残存变为零而无法发送出去时，可以向IP包的源地址发送一个ICMP原点抑制消息。收到这个消息的主机借此了解在整个线路的某一处发生了拥堵，从而打开IP包的传输间隔，然而由于这种ICMP可能会引入不公平的网络通信，一般不被使用。</p>
<p><strong>ICMP路由器探索消息</strong>：主要用于发现与自己相连的网络中的路由器。</p>
<p><strong>ICMP地址掩码消息：</strong>主要用于主机或路由器想要了解子网掩码的情况。可以向那些目标主机或路由器发送ICMP地址掩码请求消息，然后通过接收ICMP地址掩码应答消息获取子网掩码的信息。</p>
<p><strong>ICMPv6</strong></p>
<p>IPv4中ICMP仅作为一个辅助作用支持IPv4。也就是说，在IPv4时期，即使没有ICMP，仍然可以实现IP通信。然而在IPv6中，ICMP的作用被扩大，如果没有ICMPv6，IPv6就无法正常通信。</p>
<p>尤其在IPv6中，从IP地址定位MAC地址的协议从ARP转为ICMP的邻居探索消息，这种邻居探索消息融合了IPv4的ARP、ICMP重定向以及ICMP路由器选择消息等功能于一体，甚至还提供自动设置IP地址的功能</p>
<p><strong>ICMPv6中将ICMP大致分为两类：一类是错误消息，另一类是信息消息，类型0-127属于错误消息，128-255属于信息消息</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230420142727505.png" srcset="/img/loading.gif" lazyload alt="消息类型"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230420142739083.png" srcset="/img/loading.gif" lazyload alt="消息类型(续)"></p>
<p><strong>邻居探索：</strong>ICMPv6中从类型133至137的消息叫做邻居探索消息。这种邻居探索消息对于IPv6通信起着举足轻重的作用。邻居请求消息用于查询IPv6的地址与MAC地址的对应关系，并由邻居宣告消息得知MAC地址。</p>
<p>此外，实现了即插即用的功能，在没有DHCP服务器的环境下也能实现IP地址的自动获取。如果是一个没有路由器的网络，就使用MAC地址作为链路本地单播地址。而在一个有路由器的网络环境中，可以从路由器获得IPv6地址的前面部分，后面部分则由MAC地址进行设置。此时可以利用路由器请求消息和路由器宣告消息进行设置。</p>
<h3 id="5-4-DHCP"><a href="#5-4-DHCP" class="headerlink" title="5.4 DHCP"></a>5.4 DHCP</h3><p><strong>1. DHCP实现即插即用</strong></p>
<p>如果逐一为每一台主机设置IP地址会非常繁琐。特别是笔记本电脑、智能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置IP地址。</p>
<p>所以为了实现自动设置IP地址、统一管理IP地址分配，就产生了DHCP协议。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230420203355719.png" srcset="/img/loading.gif" lazyload alt="DHCP"></p>
<p><strong>2. DHCP的工作机制</strong></p>
<p>需要架设一台DHCP服务器，然后将DHCP所要分配的IP地址设置到服务器上。此外，还需要将相应的子网掩码、路由控制信息以及DNS服务器的地址等设置到服务器上。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230420231922035.png" srcset="/img/loading.gif" lazyload alt="DHCP的工作机制"></p>
<p>在使用DHCP的时候，如果DHCP服务器遇到故障，将导致无法自动分配IP地址，从而也导致网段内所有主机之间无法进行TCP/IP通信。为了避免此类问题，通常需要两台及以上的DHCP服务器。</p>
<p>但是这样可能会导致几处分配的IP地址相互冲突，所以必须要检查：</p>
<p><strong>DHCP服务端：</strong>在分配IP地址前发送ICMP回送请求包，确认没有返回应答。</p>
<p><strong>DHCP客户端：</strong>针对从DHCP那里获得的IP地址发送ARP请求包，确认没有返回应答。</p>
<p><strong>3. DHCP中继代理：</strong>家庭网络大多都只有一个以太网的网段，与其连接的主机台数也不会太多。因此，只要有一台DHCP服务器就足以应对IP地址分配的需求，而大多数情况下都由宽带路由器充当这个DHCP角色。</p>
<p>如果一个网段中设置DHCP服务器将会是个庞大的工程，即使路由器可以分担DHCP的功能，如果网络中有不下100个路由器，就要为100个路由器设置它们各自可分配IP地址的范围，并对这些范围进行后续的变更维护，这将是一个极其耗时和难于管理的工作。</p>
<p>所以需要一个<strong>DHCP中继代理</strong>来做这个事情。它可以设置DHCP服务器的IP地址，从而可以在DHCP服务器上为每一个网段注册IP地址的分配范围。</p>
<p>DHCP客户端会向DHCP中继代理发送DHCP请求包，而DHCP中继代理在收到这个广播包以后再以单播的形式发给DHCP服务器。服务器端收到该包以后再向DHCP中继代理返回应答，并由DHCP中继代理将此包转发给DHCP客户端。由此，DHCP服务器即使不在统一个链路上也可以实现统一分配和管理IP地址。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230420234915343.png" srcset="/img/loading.gif" lazyload alt="DHCP中继代理"></p>
<h3 id="5-5-NAT"><a href="#5-5-NAT" class="headerlink" title="5.5 NAT"></a>5.5 NAT</h3><p><strong>1. NAT定义</strong></p>
<p>NAT技术是用于在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。除转换IP地址外，还出现了可以转换TCP、UDP端口号的NAPT技术，由此可以实现用一个全局IP地址与多个主机的通信。</p>
<p>NAT是为正在面临地址枯竭的IPv4而开发的技术。</p>
<p><strong>2. NAT的工作机制</strong></p>
<p>局域网内设置为私有IP地址，在于外部通信时被替换成全局IP地址</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230420235541551.png" srcset="/img/loading.gif" lazyload alt="NAT的工作机制"></p>
<p>在NAT路由器的内部，有一张自动生成的用来转换地址的表。</p>
<p>当私有网络内的多台机器同时都要与外部进行通信的时候，仅仅转换IP地址，可能会出现全局IP地址不够用的问题。所以出现了包含端口号一起转换的方式（NAPT）来解决这个问题。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421002004708.png" srcset="/img/loading.gif" lazyload alt="NAPT"></p>
<p>也是实际上两个客户端A和B，但是NAPT进行这个转换，转换后IP地址是一致的，但是端口不一致。</p>
<p>这个转换表在NAT路由器上自动生成，在建立TCP连接首次握手时的SYN包一经发出，就会生成这个表，而后又随着收到关闭连接时发出FIN包的确认应答从表中被删除。</p>
<p><strong>3. NAT-PT</strong></p>
<p>为了让服务在IPv6上也能正常使用，产生了NAT-PT（NAPT-PT)规范。NAT-PT是将IPv6的首部转换为IPv4的首部的一种技术，有了这种技术，那些只有IPv6地址的主机也就是能够与IPv4地址的其他主机进行通信了。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421002447565.png" srcset="/img/loading.gif" lazyload alt="NAT-PT"></p>
<p><strong>4. NAT的潜在问题</strong></p>
<p>由于NAT都依赖于自己的转换表，因此会有如下几点限制：</p>
<p>（1）无法从NAT的外部向内部服务器建立连接</p>
<p>（2）转换表的生成与转换操作都会产生一定的开销</p>
<p>（3）通信过程中一旦NAT遇到异常需要重新启动时，所有的TCP连接都将被重置</p>
<p>（4）即使备置两台NAT做容灾备份，TCP连接还是会断开</p>
<p><strong>5. 解决NAT的潜在问题与NAT穿越</strong></p>
<p><strong>改用IPv6</strong>：如果使用IPv6地址，可用的IP地址范围有了极大的扩展，所有的主机都可以配置一个全局的IP地址</p>
<p><strong>依据应用，用户忽略NAT的存在而进行通信</strong>：在NAT内侧（私有IP地址的一边）主机上运行的应用为了生成NAT转换表，需要先发送一个虚拟的网络包给NAT的外侧。而NAT并不知道这个虚拟的包是什么，还是会照样读取包首部中的内容并自动生成一个转换表。这时如果转换表构造合理，那么还能实现NAT外侧的主机与内侧的主机连接进行通信。此外，应用还可以与NAT路由器进行通信生成NAT表，并通过一定的方法将NAT路由器上附属的全局IP地址传给应用。</p>
<p>如此，NAT外侧和内侧可以进行通信，这种现象叫做“NAT穿越”</p>
<h3 id="5-6-IP隧道"><a href="#5-6-IP隧道" class="headerlink" title="5.6 IP隧道"></a>5.6 IP隧道</h3><p>如果有两个网络A,B使用的是IPv6，如果处于中间位置的网络C支持使用IPv4的话，网络A和网络B之间无法直接进行通信，为了正常通信，就必须采用IP隧道的功能。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421083259517.png" srcset="/img/loading.gif" lazyload alt="IP隧道"></p>
<p>IP隧道中可以将那些从网络A发过来的IPv6的包统和为一个数据，再为之追加一个IPv4的首部以后转发给网络C。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421083433191.png" srcset="/img/loading.gif" lazyload alt="首部添加"></p>
<h3 id="5-7-其他IP相关技术"><a href="#5-7-其他IP相关技术" class="headerlink" title="5.7 其他IP相关技术"></a>5.7 其他IP相关技术</h3><p><strong>1. IP多播相关技术</strong></p>
<p>在多播通信中，确认接收端是否存在非常重要，如果没有接收端，发送多播消息将会造成网络流量的浪费。而确认是否有接收端，通过MLD（Multicast Listener Discovery）实现，它是IPv4中IGMP和IPv6中IGMPv6的重要功能之一。</p>
<p><strong>IGMP主要两大作用：</strong></p>
<p>（1）向路由器表明想要接收多播消息</p>
<p>（2）向交换集线器通知想要接收多播的地址</p>
<p>首先，路由器根据第1个作用，了解到想要接收多播的主机，并将这个信息告知给其他的路由器，准备接收多播消息。而多播消息的发送路径则由PIM-SM、PIM-DM、DVMRP、DOOSPF等多播路由协议决定</p>
<p>其次，第2个作用也被称为IGMP（MLD）侦听。通常交换集线器只会习得单播地址。而多播帧则跟广播帧一样不经过滤就会全部被拷贝到端口上。这回导致网络负荷加重，甚至给那些通过多播实现高质量图像传播的广播电视带来严重影响。为了解决这个问题，采用作为第二个作用的IGMP探听。支持IGMP探听的交换集线器可以过滤多播帧，从而也能降低网络的负荷。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421085335430.png" srcset="/img/loading.gif" lazyload alt="IGMP(MLD)的多播实现"></p>
<p><strong>2. IP任播</strong></p>
<p>IP任播主要用于报警电话110与消防电话119系统。</p>
<p>IP任播是指为那些提供同一种服务的服务器配置同一个IP地址，并与最近的服务器进行通信的一种方法，可适用于IPv4和IPv6</p>
<p>DNS根域名服务器就用到了IP任播。IP 任播通常用于将 DNS 服务器配置为同一 IP 地址，从而使得客户端请求时可以被路由到最近的 DNS 服务器。这样可以提高 DNS 的响应速度，并减轻 DNS 服务的负担。当一个客户端需要访问某个域名时，它将请求发送到 DNS 服务器的 IP 地址。这个请求将被路由到最近的 DNS 服务器，该服务器会向上级 DNS 服务器请求 DNS 解析，并将解析结果返回给客户端。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421085801793.png" srcset="/img/loading.gif" lazyload alt="DNS中的IP任播"></p>
<p><strong>3. 通信质量控制</strong></p>
<p><strong>控制通信质量</strong>的工作机制是对于需要保证通信质量的包，路由器会进行特殊处理，并且在力所能及的范围之内对其进行优先处理。</p>
<p>通信质量包括带宽，延迟，时延波动等内容。路由器在内部的队列中可以优先处理这些要求保证通信质量的包，有时甚至不得不丢弃那些没有优先级的包以保证通信质量。</p>
<p>为了控制通信质量，人们提出了RSVP技术，它包括两个内容，一是提供点对点的详细优先控制，另一个是提供相对较粗粒度的优先控制。</p>
<p><strong>IntServ</strong></p>
<p>IntServ是针对特定应用之间的通信进行质量控制的一种机制。这里的特定的应用是指源IP地址、目标IP地址、源端口、目标端口以及协议号五项完全内容一致。它是针对应用的连接进行详细的通信质量控制。</p>
<p><strong>DiffServ</strong></p>
<p>针对特定的网络进行较粗粒度的通信质量控制。例如：针对某个特定的供应商进行顾客排名，从而进行数据包的优先处理。</p>
<p>进入DiffServ质量控制的网络叫做DiffServ域。在DiffServ域中的路由器会对所有进入该域IP包首部中的DSCP字段进行替换。对于期望被优先处理的包设置一个有限制， 对于没有这种期望的包设置无需优先的值。DiffServ域内部的路由器则根据IP首部的DSCP字段的值有选择性的进行优先处理。在发生网络拥堵时还可以丢弃优先级较低的包。</p>
<p>IntServ中每进行一次通信都要设置一次流量设置。路由器也必须得针对不同流量进行质量控制，因此机制太过复杂，影响了实用性。而DiffServ则根据供应商的合约要求以及较粗粒度进行质量控制，机制相对简单，实用性较好。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421091228531.png" srcset="/img/loading.gif" lazyload alt="DiffServ"></p>
<p><strong>4. 显式拥塞通知</strong></p>
<p>尽管TCP也能控制网络拥塞，不过它是通过数据包的实际损坏情况来判断是否发生拥塞。然而这种方法并不能在数据包损坏之前减少数据包的发送量。为了解决这个问题，在IP层新增阿了一种使用显示拥塞通知的机制，即ECN。</p>
<p>ECN为实现拥塞通知的功能，将IP首部的TOS字段替换为ENC字段，并在TCP首部的保留位中追加CWR标志和ECE标志</p>
<p>ECN的机制就是在发送包的IP首部中记录路由器是否遇到拥塞，并在返回包的TCP首部中通知是否发生过拥塞。拥塞检查在网络层进行，而拥塞通知则在传输层进行，这两层的互相协助实现了拥塞通知的功能。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421092107136.png" srcset="/img/loading.gif" lazyload alt="ECN机制"></p>
<p><strong>Mobile IP</strong></p>
<p>对于移动设备来说，进行通信，一旦所连接的子网发生变化，则无法通过TCP继续通信，因为TCP是面向连接的协议，自始至终都需要发送端和接收端主机的IP地址不发生变化。在UDP的情况下，也无法继续通信，不过鉴于UDP是面向非连接的协议，或许可以在应用层面上处理变更IP地址的问题，但是改造所有的应该让其适应IP地址变更不是容易的事情，所以Mobile IP出现了</p>
<p>这种技术在主机所连接的IP发生变化时，主机IP地址仍保持不变，应用不需做任何改变，即使是在IP地址发生变化的环境，通信也可以继续。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421093054816.png" srcset="/img/loading.gif" lazyload alt="Mobile IP"></p>
<p>移动主机：是指那些移动了位置，IP地址却不变的设备，在没移动的时候，所连接的网络叫做归属网络，IP地址叫做归属地址。归属地址如同一个人的户籍，移动也不会改变地址。</p>
<p>归属代理：在归属网络下，可监控移动设备的位置，并转发数据包给移动主机。</p>
<p>外部代理：使用于支持移动主机的移动设备，所有需要接入网络的移动主机都需要它。</p>
<p><strong>Mobile IPv6</strong></p>
<p>（1）没有外部代理的网络不能通信</p>
<p>（2）IP包呈三角形路径被转发而因此效率不高</p>
<p>（3）为提高安全，一个域可以做这样的设置，即如果从自己的域向外部发送包的源地址不是本域在用的IP地址，则丢弃该包。而且这种设置可以越来越多。是因为从移动主机发给通信对端的IP包的源地址是归属地址，与另一个域的IP地址不符，因此目的地路由器可能会丢弃这个包。</p>
<p>以上问题在Mobile IPv6中已经得到了相应的解决。</p>
<p>（1）外部代理的功能由市县Mobile IPv6的移动主机自己承担</p>
<p>（2）考虑路径最优化，可以不用经过归属代理进行直接通信</p>
<p>（3）IPv6首部的源地址中赋与移动地址，不让防火墙丢弃</p>
<h2 id="第6章-TCP与UDP"><a href="#第6章-TCP与UDP" class="headerlink" title="第6章 TCP与UDP"></a>第6章 TCP与UDP</h2><h3 id="6-1-传输层的作用"><a href="#6-1-传输层的作用" class="headerlink" title="6.1 传输层的作用"></a>6.1 传输层的作用</h3><p>传输层的TCP和UDP，为了识别自己所传输的数据部分究竟应该发给哪个应用，也设定了这样一个编号（端口号）。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421095316603.png" srcset="/img/loading.gif" lazyload alt="http请求"></p>
<p>TCP/IP的众多应用协议大多以客户端/服务端的形式运行。客户端类似于客户的意思，是请求的发起端，而服务端则表示提供服务的意思，是请求的处理端。另外，作为服务端的程序有必要提前启动，准备接收客户端的请求，否则即使有客户端的请求发过来，也无法做到相应的处理。</p>
<p>这些服务端程序在UNIX系统中叫做守护进程，例如Http的服务端程序是httpd，而ssh的服务端程序是sshd。</p>
<p>确定一个请求究竟是发给的哪个服务端，可以通过所收到数据包的目标端口号识别。</p>
<p><strong>1. 两种传输层协议TCP和UDP</strong></p>
<p><strong>TCP：</strong>面向连接的、可靠的流协议。流就是指不间断的数据结构。</p>
<p>TCP为提供可靠性传输，实行顺序控制或重发控制机制。此外还具备流控制、拥塞控制、提高网络利用率等众多功能。</p>
<p><strong>UDP：</strong>不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在UDP的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p>
<p><strong>2. TCP与UDP区分</strong></p>
<p>TCP用于传输层有必要实现可靠传输的情况。由于它是面向连接并具备顺序控制、重发控制等机制的，所以它可以为应用提供可靠传输。</p>
<p>而在另一方面，UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。以IP电话进行通话为例，如果使用TCP，数据在传送途中如果丢失会被重发，但是这样无法流畅的传输通话人的声音会导致无法进行正常交流。而采用UDP，他不会进行重发处理，从而也就不会有声音大幅度延迟到达的问题，即使有部分数据丢失，也只是会影响某一小部分的通话。此外，在多播与广播通信中也使用UDP而不是TCP。</p>
<h3 id="6-2-端口号"><a href="#6-2-端口号" class="headerlink" title="6.2 端口号"></a>6.2 端口号</h3><p><strong>1. 端口号定义</strong></p>
<p>数据链路和IP中的地址，分别指的是MAC地址和IP地址。前者用来识别同一链路中不同的计算机，后者用来识别TCP/IP网络中互连的主机和路由器。在传输层中也有这种概念，就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。</p>
<p><strong>2. 根据端口号识别应用</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421101546644.png" srcset="/img/loading.gif" lazyload alt="端口号识别应用"></p>
<p><strong>3. 通过IP地址、端口号、协议号进行通信识别</strong></p>
<p>在TCP/IP或UDP/IP通信中通常采用5个信息来识别一个通信。它们是“源IP地址”、“目标IP地址”、”协议号“、”源端口号“、”目标端口号“</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421101838086.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>4. 端口号的确定</strong></p>
<p><strong>（1）标准既定的端口号</strong>，静态方法，为每个应用程序都指定一个固定的端口号。如HTTP就是80、SMTP就是25，这些知名端口一般由0-1023的数字分配而成。</p>
<p><strong>（2）时序分配法</strong>，动态方法，由操作系统进行分配，操作系统可以为每个应用分配互不冲突的端口号，例如，每需要一个新的端口号时，就在之前分配号码的基础上加1，这样操作系统就可以动态地管理端口号。根据这种动态分配端口号的机制，即使是同一个客户端程序发起的多个TCP连接，识别这些通信连接的5部分数字也不会全部相同。</p>
<p>动态分配的端口号取值范围在49152到65535之间</p>
<h3 id="6-3-UDP"><a href="#6-3-UDP" class="headerlink" title="6.3 UDP"></a>6.3 UDP</h3><p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务，并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。</p>
<p>UDP面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用以以下几个方面</p>
<p>（1）包总量较少的通信（DNS、SNMP等）</p>
<p>（2）视频、音频等多媒体通信（即时通信）</p>
<p>（3）限定于LAN等特定网络中的应用通信</p>
<p>（4）广播通信（广播、多播）</p>
<h3 id="6-4-TCP"><a href="#6-4-TCP" class="headerlink" title="6.4 TCP"></a>6.4 TCP</h3><p>它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有，此外,TCP作为一种面向有连接的协议，只有在确定通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</p>
<p><strong>1. 通过序列号与确认应答提高可靠性</strong></p>
<p>在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到的消息的通知，这个消息叫做确认应答（ACK)。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421104732646.png" srcset="/img/loading.gif" lazyload alt="ACK"></p>
<p>TCP通过肯定的确认应答（ACK）实现可靠的数据传输，当发送端数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。</p>
<p>在一定时间内没有等到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能保证数据能够到达对端，实现可靠传输。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421104955365.png" srcset="/img/loading.gif" lazyload alt="数据包丢失"></p>
<p>未收到确认应答并不意味着数据一定丢失，也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421105131343.png" srcset="/img/loading.gif" lazyload alt="应答包丢失"></p>
<p>也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源发送主机只要按照机制重发数据即可。但是对于目标主机来说，这简直是一种“灾难”，它会反复收到相同的数据。而为了对上层应用提供可靠的传输，必须得放弃重复的数据包，为此，就必须引入一种机制，它能够识别是否已经接收数据，又能判断是否需要接收。</p>
<p>上述这些确认应答处理，重发控制以及重复控制等功能都可以通过序列号实现。序列号是按顺序给发送数据的每一个字节都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据长度，将自己的下一步应该接收的序号最为确认应答返送回去。通过序列号和确认应答号，TCP可以实现可靠传输。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421105845628.png" srcset="/img/loading.gif" lazyload alt="序列号机制"></p>
<p><strong>2. 重发超时如何确定</strong></p>
<p>重发超时是指重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过了这个时间仍未收到确认应答，发送端将进行数据重发。</p>
<p>找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”，然而这个时间长短随着数据包途径的网络环境的不同而有所变化。所以它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差相加重发超时的时间，就是比这个总和要稍大一点的值。</p>
<p><strong>3. 连接管理</strong></p>
<p>TCP提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好通信两端之间的准备工作</p>
<p>可以使用TCP首部用于控制的字段来管理TCP连接，一个连接的建立与断开，正常过程至少需要来回发送7个包才能完成。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421111817969.png" srcset="/img/loading.gif" lazyload alt="TCP连接"></p>
<p><strong>4. TCP以段为单位发送数据</strong></p>
<p>在建立TCP连接的同时，也可以确定发送数据包的单位，我们也可以称其为最大消息长度(MSS)。而MSS是在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求是，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS的大小，然后再挑选一个较小的值投入使用。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421112530814.png" srcset="/img/loading.gif" lazyload alt="MSS"></p>
<p><strong>5. 利用窗口控制提高速度</strong></p>
<p>TCP以1个段为单位，每发一个段进行一次确认应答的处理，这样传输的缺点就是，包的往返时间越长通信性能就越低。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421135159912.png" srcset="/img/loading.gif" lazyload alt></p>
<p>为了解决这个问题，TCP就引入了<strong>窗口</strong>的概念。</p>
<p>确认应答的不再是每个分段，而是以更大的单位进行确认时，转发时间将会被大幅度的缩短，也就是说，发送端主机在发送了一个段以后不必要一直等待确认应答，而是继续发送。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421135350011.png" srcset="/img/loading.gif" lazyload alt="窗口"></p>
<p>窗口大小就是无需等待确认应答而可以继续发送数据的最大值</p>
<p>这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421135616982.png" srcset="/img/loading.gif" lazyload alt="窗口机制"></p>
<p>当数据发出后若如期收到确认应答就可以不再进行重发，此时数据就可以从缓存区清除，收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地对多个段同时发送提供通信性能。这种机制也被称为滑动窗口控制。</p>
<p><strong>6. 窗口控制与重发控制</strong></p>
<p>如果出现了段丢失该怎么办？</p>
<p><strong>（1）确认应答未能返回</strong></p>
<p>在这种情况下，数据已经到达对端是不需要再进行重发的。但是，在没有使用窗口控制的时候，没有收到确认应答的数据都会被重发，而使用了窗口控制，某些确认应答即使丢失也无需重发，可以通过下一个确认应答进行确认。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421140058907.png" srcset="/img/loading.gif" lazyload alt="确认应答未能返回"></p>
<p><strong>（2）报文段丢失</strong></p>
<p>当某一报文段丢失之后，发送端会一直收到序号为1001的确认应答，这个确认应答好像是在提醒发送端“我想接收的是从1001开始的数据”。因此，在窗口比较大的时候，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回，而发送端主机如果连续3次收到同一个确认应答，就会将其所对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称作高速重发控制。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421140310407.png" srcset="/img/loading.gif" lazyload alt="报文段丢失"></p>
<p><strong>7. 流控制</strong></p>
<p>发送端根据自己的实际情况发送数据。但是接收端可能收到的是一个毫无关系的数据包又可能会在处理其他时间上花费一些时间。因此在为这个数据包做其他处理时会耗费一些时间，甚至在高负荷的情况下无法接收任何数据。如此一来，如果接收端将本应该接收的数据丢弃的话，就又会触发重发机制，从而导致网络流量的无端浪费。</p>
<p>为了防止这种现象，TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量，这就是<strong>流控制</strong>。</p>
<p>具体操作：接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端发送不超过这个限度的数据。该大小限度就被称作窗口大小。</p>
<p>TCP首部中，专门有一个字段用来通知窗口大小，接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端。这个字段的值越大，说明网络的吞吐量越高。</p>
<p>不过接收端的这个缓冲区一旦面临数据溢出时，窗口的大小的值也会被随设置为一个更小的值通知给发送端，从而控制数据发送量。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421141147751.png" srcset="/img/loading.gif" lazyload alt="流控制"></p>
<p><strong>8. 拥塞控制</strong></p>
<p>有了TCP的窗口控制，收发主机之间即使不再以一个数据段为单位发送确认应答，也能连续发送大量的数据包。然而，如果在通信刚开始就发送大量的数据，会发生网络拥堵，可能会导致整个网络的瘫痪。</p>
<p>为了防止这个问题，在通信一开始的时候就会通过一个叫做慢启动的算法得出数值，对发送数据量进行控制。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421141436915.png" srcset="/img/loading.gif" lazyload alt="拥塞控制"></p>
<p>定义了一个叫做<strong>拥塞窗口</strong>的概念。</p>
<p>于是在慢启动的时候，将这个拥塞窗口的大小设置为1个数据段发送数据，之后每收到一次确认应答，拥塞窗口的值就加1，1-&gt;2-&gt;4-&gt;8……在发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，然后按照他们当中较小的值，发送比其还要小的数据量。</p>
<p>但是为了防止拥堵状况激增甚至导致网络拥堵的发生。为了防止这些，引入了慢启动阈值的概念。只要拥塞窗口的值超过这个阈值，在每收到一次确认应答时，只允许以下面的比例放大拥塞窗口</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421141906928.png" srcset="/img/loading.gif" lazyload alt></p>
<p>拥塞窗口越大，确认应答的数目也会增大。不过随着每收到一个确认应答，其涨幅也会逐渐减少</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421143649314.png" srcset="/img/loading.gif" lazyload alt="TCP窗口变化"></p>
<p>TCP在刚建立连接完成后，并没有设置相应的慢启动阈值，而是在超时重发的时候，才会设置为当时拥塞窗口一半的大小。</p>
<p>首先是慢启动的过程，当发送方每收到一个ACK，拥塞窗口cwnd的大小就会加1（1-&gt;2-&gt;4-&gt;8)，此时超时，设置慢启动的阈值为当前拥塞窗口的一半。</p>
<p>然后再次慢启动，达到慢启动阈值之后，使用<strong>拥塞避免</strong>算法</p>
<p>每收到一个ack时，拥塞窗口增加：<strong>1/拥塞窗口</strong>，就是线性增长。</p>
<p>如果发生了重复确认应答进行高速重发控制的时候，慢启动阈值的大小被设置为当时窗口大小的一半，然后将窗口的大小设置为<strong>该慢启动阈值+3个数据段的大小</strong>。</p>
<p>以上就是拥塞窗口变化的全过程。</p>
<p><strong>9. 提高网络利用率的规范</strong></p>
<p><strong>Nagle算法</strong>是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制。</p>
<p>具体来说，就是需要满足一定的条件，才能发送数据。</p>
<p>如果两个条件都不满足，那么暂停等待一段时间以后再进行数据发送</p>
<p>（1）已发送的数据都已收到确认应答</p>
<p>（2）可以发送最大段长度（MSS)的数据时</p>
<p>这个算法虽然可以提高网络利用率，但是可能会发生某种程度的延迟。为此，在窗口系统以及机械控制等领域中使用TCP时，往往会关闭该算法的启用。</p>
<p><strong>延迟确认应答</strong></p>
<p>接收数据的主机如果每次都立刻回复确认应答的话，可能会返回一个较小的窗口。那是因为刚接收完数据，缓冲区已满。</p>
<p>当某个接收端收到这个小窗口的通知以后，会以它为上限发送数据，从而又降低了网络的利用率。为此，引入了一个方法，那就是收到数据以后并不立即返回确认应答，而是延迟一段时间的机制。</p>
<p>（1）在没有收到2×最大段长度的数据为止不做确认应答</p>
<p>（2）其他情况下，最大延迟0.5秒发送确认应答</p>
<p>正如滑动窗口的控制机制，确认应答少一些也无妨。TCP文件传输中，绝大多数是每两个数据段返回一次确认应答。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421151327750.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>捎带应答</strong></p>
<p>根据应用层协议，发送出去的消息到达对端，对端进行处理以后，会返回一个回执。</p>
<p>TCP的确认应答和回执数据可以通过一个包发送，这种方式叫做捎带应答，通过这种机制，可以使收发的数据量减少。</p>
<p>另外，接收数据以后如果立刻返回确认应答，就无法实现捎带应答。而是将所接收的数据传给应用处理生成返回数据以后进而再进行发送请求为止，必须一直等待确认应答的发送</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421152023734.png" srcset="/img/loading.gif" lazyload alt="捎带应答"></p>
<h3 id="6-5-其他传输层协议"><a href="#6-5-其他传输层协议" class="headerlink" title="6.5 其他传输层协议"></a>6.5 其他传输层协议</h3><p><strong>1. UDP-Lite</strong></p>
<p>UDP-Lite是扩展UDP机能的一种传输层协议。在基于UDP的通信当中如果出现校验和出现错误，所收到的包将被全部丢弃。然而，现实操作中，有些应用在面对这种情况时并不希望把已经收到的所有包丢弃。</p>
<p>如果将UDP中校验和设置为无效，那么即使数据的一部分发生错误也不会将整个包废弃。不过，这不是一个很好的办法，因为如果发生的错误有可能是UDP首部中的端口号被破坏或时IP首部中的IP地址被破坏，就会产生严重后果。</p>
<p><strong>2. SCTP</strong></p>
<p><strong>SCTP（流控制传输协议）</strong>与TCP一样，都是对一种提供数据到达与否相关可靠性检查的传输层协议。</p>
<p>（1）以消息为单位收发：TCP中接收端并不知道发送端应用所决定的消息大小，在SCTP中却可以。</p>
<p>（2）支持多重宿主：在有多个NIC的主机中，即使其中能够使用的NIC发生变化，也仍然可以继续通信。</p>
<p>（3）支持多数据流通信：TCP中建立多个连接以后才能进行通信的效果，在SCTP中一个连接就可以。</p>
<p>（4）可以定义消息的生存期限：超过生存期限的消息，不会被重发</p>
<p>SCTP主要用于进行通信的应用之间发送众多较小消息的情况。这些较小的应用消息被称作数据块，多个数据块组成一个数据包。</p>
<p>此外，SCTP具有支持多重宿主以及设定多个IP地址的特点。多重宿主是指同一台主机具备多种网络的接口。</p>
<p><strong>3. DCCP</strong></p>
<p>DCCP（数据报拥塞控制协议）是一个辅助UDP的崭新的传输层协议。UDP没有拥塞控制机制。为此，当应用使用UDP发送大量数据包时极容易出现问题，于是出现了DCCP这样的规范。</p>
<p>（1）与UDP一样，不能提供发送数据的可靠性传输</p>
<p>（2）它面向连接，具备建立连接与断开连接的处理。在建立和断开连接上是具有可靠性。</p>
<p>（3）能够根据网络拥堵情况进行拥塞控制</p>
<p>（4）为了进行拥塞控制，接收端收到包以后返回确认应答。</p>
<h3 id="6-6-UDP首部的格式"><a href="#6-6-UDP首部的格式" class="headerlink" title="6.6 UDP首部的格式"></a>6.6 UDP首部的格式</h3><p>UDP首部由源端口号，目标端口号，包长和校验和组成</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421153633081.png" srcset="/img/loading.gif" lazyload alt="UDP首部"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422133035551.png" srcset="/img/loading.gif" lazyload alt="伪首部"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422132500595.png" srcset="/img/loading.gif" lazyload alt="UDP字段"></p>
<p>UDP的校验和需要计算UDP首部加数据荷载部分，同时也需要加上UDP伪首部。</p>
<p>UDP校验和计算：</p>
<p>如果UDP数据报部分不是偶数个字节，则要在数据部分末尾增加一个全零字节。</p>
<p>（1）按每16位求和得到一个32位的数；</p>
<p>（2）如果这个32位的数，高16位不为0，则高16位加低16位再得到一个32位的数</p>
<p>（3）重复第二步直到高16位为0，将低16位取反，得到校验和</p>
<p>填好校验和之后就将伪首部去掉。</p>
<p>接收主机在收到UDP数据报以后，从IP首部得知IP地址信息构造UDP伪首部，再进行校验和计算。校验和字段的值是校验和字段以外剩下部分的1的补码和。只有计算结果和校验和字段的值是一致的才会被认为所收到的数据是正确。</p>
<p><strong>校验和计算中计算UDP伪首部的理由</strong></p>
<p>因为TCP/IP中识别一个进行通信的应用需要5大要素，分别是“源IP地址”、“目标IP地址”、“源端口”、“目标端口”、“协议号”。然而，如果在UDP的首部中只包含了它们中的两项。如果其余3项被破坏了，那么就会导致应该收包的应用收不到包，不该收到包的应用却收到了包。</p>
<h3 id="6-7-TCP首部格式"><a href="#6-7-TCP首部格式" class="headerlink" title="6.7 TCP首部格式"></a>6.7 TCP首部格式</h3><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422135345677.png" srcset="/img/loading.gif" lazyload alt="TCP首部格式"></p>
<p><strong>序列号</strong>不会从0或1开始，而是在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机。然后再将每转发过去的字节数累加到初始值上表示数据的位置。此外，在建立连接和断开连接时发送的SYN包和FIN包虽然并不携带数据，但是也会作为一个字节增加对应的序列号。</p>
<p><strong>确认应答号</strong>是指下一次应该收到的数据的序列号。实际上，它是指已收到确认应答号减一为止的数据。发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。</p>
<p><strong>数据偏移</strong>表示TCP所传输的数据部分应该从TCP包的哪个位开始计算，当然可以把它当做TCP首部的长度，长4位，单位为4字节。不包括选项字段的话，TCP首部的长度为20字节长，因此数据偏移字段可以设置为5。意为从TCP包最一开始到20字节都是首部，余下部分是TCP数据。</p>
<p><strong>保留</strong>是为了以后扩展使用，其长度为4位。一般设置为0，但即使收到的包在该字段不为0，此包也不会被丢弃。</p>
<p><strong>控制位</strong>字段长度为8位，每一位从左到右分别是CWR、ECE、URG、ACK、PSH、RST、SYN、FIN</p>
<p><strong>CWR：</strong>CWR标志与后面的ECE标志都用于IP首部的ECN字段。ECE标志为1时，则通知对方已将拥塞窗口缩小。</p>
<p><strong>ECE：</strong>表示ECN-Echo。置为1会通知通信对方，从对方到这边的网络有拥堵。在收到数据包的IP首部中ECN为1时将TCP首部中的ECE设置为1。</p>
<p><strong>URG：</strong>表示包中有紧急处理的数据</p>
<p><strong>ACK：</strong>确认应答的字段变为有效。TCP规定除了最初建立连接时的SYN包之外该位必须设置为1</p>
<p><strong>PSH：</strong>表示需要将受到的数据立刻传给上层应用协议。PSH为0时，则不需要立即传而是先进行缓存。</p>
<p><strong>RST：</strong>表示TCP连接中出现异常必须强制断开连接</p>
<p><strong>SYN：</strong>用于建立连接。SYN为1表示希望建立连接</p>
<p><strong>FIN：</strong>表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以互相交换FIN位置为1的TCP段。</p>
<p><strong>窗口大小：</strong>用于通知从相同TCP首部的确认应答号所指位置开始能够接收的数据大小。TCP不允许发送超过此处所示大小的数据。不过如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小。</p>
<p><strong>校验和：</strong>与UDP类似，区别在于TCP的校验和无法关闭。</p>
<p>同样需要使用TCP伪首部，同样不是16位的整数倍，需要进行填充。</p>
<p><strong>使用校验和的目的是什么？</strong></p>
<p>有噪声干扰的通信途中如果出现位错误，可以由数据链路的FCS检查出来。那么为什么TCP或UDP中也需要校验和？</p>
<p>因为TCP或UDP的校验和是一种进行路由器内存故障或程序漏洞导致的数据是否被破坏的检查。如果指针使用不当，极有可能会破坏内存中的数据结构。路由器的程序中也有可能会存在漏洞，或程序异常宕掉的可能。在互联网中发送数据包要经由好多个路由器，一旦在发送途中的某一个路由器发生故障，经过此路由器的包、协议首部或数据就极有可能被破坏。即使在这种情况下，TCP或UDP如果能够提供校验和计算，也可以判断协议首部和数据是否被破坏。</p>
<p><strong>紧急指针</strong>只有在URG控制位为1时有效，该字段的数值表示本报文段中紧急数据的指针。正确来讲，从数据部分的首位到紧急指针所只是的位置为止为紧急数据。</p>
<p><strong>选项</strong>用于提高TCP的传输性能。因为根据数据偏移进行控制，所以其长度最大为40字节。（数据偏移最大为15*4=60字节，减去前面的20字节，剩下的还有40字节全部为选项）</p>
<p>选项字段尽量调整其为32位的整数倍。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422151642740.png" srcset="/img/loading.gif" lazyload alt="选项"></p>
<p>类型2的MSS选项用于在建立连接时决定最大段长度的情况。这选项用于大部分的操作系统。</p>
<p>类型3的窗口扩大是一个用来改善TCP吞吐量的选项。正常安全窗口大小字段，最大也只能发送64KB的数据，如果采用了这个选项，窗口的最大值可以扩展到1G字节。</p>
<p>类型8的时间戳字段选项，用于高速通信中对序列号的管理。</p>
<p><strong>吞吐量由窗口大小和往返时间决定</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422152113438.png" srcset="/img/loading.gif" lazyload alt="最大吞吐量"></p>
<p>W是窗口大小，RTT是往返时间</p>
<h2 id="第7章-路由协议"><a href="#第7章-路由协议" class="headerlink" title="第7章 路由协议"></a>第7章 路由协议</h2><h3 id="7-1-路由控制的定义"><a href="#7-1-路由控制的定义" class="headerlink" title="7.1 路由控制的定义"></a>7.1 路由控制的定义</h3><p>为了能让数据包正确到达目的地，路由器必须在途中进行正确的转发。这种正确的方向转发数据所进行的处理就叫做路由控制或路由。</p>
<p><strong>1. 静态路由与动态路由</strong></p>
<p>静态路由是指事先设置好路由器和主机中并将路由信息固定的一种方法</p>
<p>动态路由是指让路由协议在运行过程中自动地设置路由控制信息的一种方法。</p>
<p><strong>静态路由</strong>的设置通常需要使用者手工设置，因此会给管理者带来很大的负担，而且一旦某个路由器发生故障，基本上无法自动绕过发生故障的节点，只有在管理员手工设置以后才能恢复正常。</p>
<p><strong>动态路由</strong>的设置，管理员必须设置好路由协议，设定过程的复杂程度与具体要设置路由协议的类型有直接关系。</p>
<p>如果有一个新的网络被追加到原有的网络中时，只要在新增加网络的路由器上进行一个动态路由的设置即可。减轻了管理员负担，而且网络上一旦发生故障，只要有一个可绕的其他路径，那么数据包就会自动选择这个路径，路由器的设置也会自动重置。</p>
<p>但是定期相互交换路由控制信息，会与相邻的路由器之间互发消息，会给网络带来一定程度的负荷。</p>
<p><strong>2. 动态路由的基础</strong></p>
<p>动态路由会给相邻路由器发送自己已知的网络连接信息，而这些信息又像接力一样依次传递给其他路由器，直至整个网络都了解时，路由控制表，也就制作完成了。而此时也就可以正确转发IP数据包。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422153204830.png" srcset="/img/loading.gif" lazyload alt="动态路由"></p>
<h3 id="7-2-路由控制范围"><a href="#7-2-路由控制范围" class="headerlink" title="7.2 路由控制范围"></a>7.2 路由控制范围</h3><p>因为随着IP网络的发展，想要对所有网络统一管理是不可能的事。因此，人们根据路由控制的范围常使用IGP和EGP两种类型的路由协议</p>
<p><strong>自治系统与路由协议</strong></p>
<p>企业内部网络的管理方针，往往由该企业组织内部自行决定。因此每个企业或组织结构对网络管理和运维的方法都不尽相同。制定自己的路由策略，并以此为准在一个或多个网络群体中采用的小型单位叫做<strong>自治系统（AS：Autonomous System）或路由选择域（Routing Domain）</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422154407889.png" srcset="/img/loading.gif" lazyload alt="自治系统和路由协议"></p>
<p>自治系统内部动态路由采用的协议使域内路由协议，即IGP，而自治系统之间的路由控制采用的是域间路由协议，即EGP</p>
<p><strong>IGP和EGP</strong></p>
<p>路由协议分为两类：一类是外部网关协议EGP，另一类是内部网关协议IGP。</p>
<p>IGP中还可以使用RIP、RIP2、OSPF等众多协议。</p>
<p>EGP可以使用BGP协议</p>
<h3 id="7-3-路由算法"><a href="#7-3-路由算法" class="headerlink" title="7.3 路由算法"></a>7.3 路由算法</h3><p>路由控制有各种各样的算法，其中最具有代表性的有两种，是距离向量算法和链路状态算法。</p>
<p><strong>1. 距离向量算法</strong></p>
<p>距离向量算法（DV）是指根据距离和方向决定目标网络或目标主机位置的一种方法。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422192205004.png" srcset="/img/loading.gif" lazyload alt="距离向量算法"></p>
<p>路由器之间可以互换目标网络的方向及其距离的相关信息，并以这些信息为基础制作路由控制表。</p>
<p>但是问题在于只有距离和方向的信息，所以当网络构造变得分外复杂时，在获得稳定的路由信息之前，需要消耗一定的时间，也极易发生路由循环等问题。</p>
<p><strong>2. 链路状态算法</strong></p>
<p>链路状态算法是路由器在了解网络整体连接状态的基础上生成路由控制表的一种方法。</p>
<p><strong>距离向量算法</strong>中每个路由器掌握的信息都不相同。通往每个网络所耗的距离也根据路由器的不同而不同。因此，该算法的一个缺点就是不太容易判断每个路由器上的信息是否正确。</p>
<p><strong>链路状态算法</strong>中所有路由器持有相同的信息。对于任何一台路由器，网络拓扑都完全一致。因此，只要某一台路由器与其他路由器保持同样的路由控制信息，就意味着该路由器上的路由信息是正确的。只要每个路由器尽快地与其他路由器同步路由信息，就可以使路由信息达到一个稳定的状态。</p>
<p>因此，它的优势在于即使网络结构变得复杂，每个路由器也能够保持正确的路由信息、进行稳定的路由选择。</p>
<p>但是弊端也是在于如何从网络代理获取路由信息表。这一过程相当复杂，特别是在一个规模巨大而又复杂的网络结构中，管理和处理代理信息需要高速CPU处理能力和大量的内存。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422193132717.png" srcset="/img/loading.gif" lazyload alt="链路状态算法"></p>
<p><strong>3. 主要路由协议</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422193229920.png" srcset="/img/loading.gif" lazyload alt="路由协议"></p>
<h3 id="7-4-RIP"><a href="#7-4-RIP" class="headerlink" title="7.4 RIP"></a>7.4 RIP</h3><p>RIP是距离向量型的一种路由协议，广泛用于LAN。</p>
<p><strong>1， 广播路由控制信息</strong></p>
<p>RIP将路由控制信息定期（30秒）向全网广播。如果没有收到路由控制信息，连接就会断开。不过，这有可能是由于丢包导致的，因此RIP规定等待5次。如果等了6次仍未收到路由信息，才会真正关闭连接。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422200129303.png" srcset="/img/loading.gif" lazyload alt="RIP"></p>
<p><strong>2. 根据距离向量确定路由</strong></p>
<p>RIP基于距离向量算法决定路径。距离的单位为“跳数”。跳数是指所经过的路由器的个数。RIP希望尽可能少通过路由器将数据包转发到目标IP地址</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422201144959.png" srcset="/img/loading.gif" lazyload alt="根据距离向量确定路由"></p>
<p><strong>3. 使用子网掩码时的RIP处理</strong></p>
<p>RIP虽然不交换子网掩码，但可以用于使用子网掩码的网络环境。但是需要注意以下几点：</p>
<p>（1）从接口的IP地址对应分类得出网络地址后，与根据路由控制信息流过此路由器包中的IP地址对应的分类得出的网络地址进行比较。如果两者的网络地址相同，那么就以接口的网络地址长度为准。</p>
<p>（2）如果两者的网络地址不同，那么以IP地址的分类所确定的网络地址长度为准。</p>
<p><strong>因此，采用RIP进行路由控制的范围内必须注意两点：一是，因IP地址的分类而产生不同的网络地址时；二是，构造网络地址长度不同的网络环境时。</strong></p>
<p><strong>4. RIP中路由变更时的处理</strong></p>
<p>RIP的基本行为可归纳为如下两点</p>
<p>（1）将自己所知道的路由信息定期进行广播</p>
<p>（2）一旦认为网络被断开，数据将无法流过此路由器，其他路由器也就可以得知网络已经断开</p>
<p>但是存在着问题，路由器A虽然察觉到自己与网络A的连接已经断开，无法将网络A的信息发送给路由器B，但是它会收到路由器B曾经获知的消息。这就使得路由器A误以为自己的信息还可以通过路由器B到达网络A。</p>
<p>像这样收到自己发出去的消息，这个问题被称为<strong>无限计数</strong>。</p>
<p><strong>解决办法：</strong></p>
<p>1、最长距离不超过16，由此即使发生了无限计数的问题，也可以从时间上进行控制。</p>
<p>2、规定路由器不再把所收到的路由消息原路返回给发送端。这也叫做水平分割。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423104848747.png" srcset="/img/loading.gif" lazyload alt="无限计数问题"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423104902992.png" srcset="/img/loading.gif" lazyload alt="水平分割"></p>
<p>但是水平分割无法解决<strong>网络本身有环路</strong>的问题</p>
<p>对于网络本身有环路的问题，提出了“<strong>毒性逆转</strong>”和“<strong>触发更新</strong>”</p>
<p><strong>毒性逆转</strong>是指当网络中发生链路被断开的时候，将无法通信的这个消息传播出去，即发生一个距离为16的消息。</p>
<p><strong>触发更新</strong>是指当路由器信息发生变化的时候，不等待30秒而是立刻发送出去的一种方法。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423105358597.png" srcset="/img/loading.gif" lazyload alt="触发更新"></p>
<p>有了这两种机制，在链路不通的时候，可以迅速传送消息以使路由信息尽快收敛。</p>
<p><strong>5. RIP2</strong></p>
<p>更新点：</p>
<p><strong>（1）使用多播</strong>：RIP中当路由器之间交换路由信息时采用广播的形式，然而在RIP2中改用了多播，这样可以减少网络的流量，还缩小了对无关主机的影响。</p>
<p><strong>（2）支持子网掩码：</strong>RIP2支持在其交换的路由信息中加入子网掩码信息。</p>
<p><strong>（3）路由选择域：</strong>与OSPF的区域类似，在同一个网络中可以使用逻辑上独立的多个RIP。</p>
<p><strong>（4）外部路由标志：</strong>通常用于把从BGP等获得的路由控制信息通过RIP传递给AS内。</p>
<p><strong>（5）身份验证密钥：</strong>与OSPF一样，RIP包中携带密码。只有在自己能够识别这个密码时才接收数据，否则忽略这个RIP包。</p>
<h3 id="7-5-OSPF"><a href="#7-5-OSPF" class="headerlink" title="7.5 OSPF"></a>7.5 OSPF</h3><p>OSPF是根据OSI的IS-IS协议而提出的一种链路状态型路由协议。由于采用链路状态类型，所以即使网络中有环路，也能够进行稳定的路由控制。</p>
<p>OSPF支持子网掩码。由此，曾经在RIP中无法实现的可变长度子网结构的网络路由控制成为现实。</p>
<p><strong>1. OSPF是链路状态型路由协议</strong></p>
<p>路由器之间交换链路状态生成网络拓扑信息，然后再根据这个拓扑信息生成路由控制表。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423134559687.png" srcset="/img/loading.gif" lazyload alt="由链路状态确定路由"></p>
<p>RIP的路由选择要求途中所经过的路由器个数越少越好。与之相比，OSPF可以给每条链路赋予一个权重，并始终选择一个权重最小的路径作为最终路由。也就是说OSPF以每个链路上的代价为度量准备，始终选择一个总的代价最小的路径。</p>
<p><strong>2. OSPF基础知识</strong></p>
<p>在OSPF中，把连接到同一个链路的路由器称作相邻路由器。在一个相对简单的网络结构中，相邻路由器之间可相互交换路由信息。但是在一个比较复杂耳朵网络中就不需要在所有相邻的路由器之间都进行控制信息的交换，而是确定一个指定路由器，并以它为中心交换路由信息即可。</p>
<p><strong>RIP</strong>中包的类型只有一种。它利用路由控制信息，一边确认是否连接了网络，一边传送着网络信息。</p>
<p>但是如果网络的个数很多，那么每次要交换的路由控制信息就越大。而且当网络已经处于比较稳定的、没有什么变化的状态的时候，还要定期交换相同的路由控制信息，一定程度上浪费了网络带宽。</p>
<p><strong>OSPF</strong>中，根据作用的不同可以分为5种类型的包。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423151632349.png" srcset="/img/loading.gif" lazyload alt="OSPF"></p>
<p>问候包确认是否连接。</p>
<p>数据库描述包相互发送摘要信息和版本信息来同步路由控制信息。</p>
<p>链路状态请求包请求路由控制信息</p>
<p>链路状态更新包接收路由状态信息</p>
<p>链路状态确认包通知大家本地已经接收到了路由控制信息。</p>
<p><strong>3. OSPF工作原理概述</strong></p>
<p>OSPF中进行连接确认的协议叫做HELLO协议。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423152002055.png" srcset="/img/loading.gif" lazyload alt="OSPF中根据链路状态生成路由控制表"></p>
<p>LAN中每10秒发送一个HELLO包。如果没有HELLO包到达，则进行连接是否断开的连接。具体为，允许空等3次，直到第4次（40秒后）仍无任何反馈就认为连接已经断开。之后在进行连接断开或恢复连接操作时，由于链路状态发生变化，路由器会发送一个链路状态更新包通知其他路由器网络状态的变化。</p>
<p>链路状态更新包所要传达的消息大致分为两类：一是网络LSA，另一个是路由器LSA。</p>
<p>网络LSA是以网络为中心生成的信息，表示这个网络都与哪些路由器相连接。而路由器LSA是以路由器为中心生成的信息，表示这个路由器与哪些网络相连接。</p>
<p>根据<strong>网络LSA</strong>和<strong>路由器LSA</strong>这两种信息，每个路由器就可以生成一个表示网络结构的链路状态数据库。根据这个数据库，可以采用Dijkstra算法生成相应的路由控制表。</p>
<p>相比距离向量，由上述过程所生成的路由控制表更加清晰不容易混淆，还可以有效降低无限循环问题的发生。</p>
<p>但是当网络规模逐渐变大的时候，最短路径优先算法的处理时间就会变得越长，对CPU和内存的消耗也就越大。</p>
<p><strong>4. 将区域分层化进行细分管理</strong></p>
<p>链路状态型路由协议的潜在问题在于，当网络规模越来越大的时候，表示链路状态的拓扑数据库就变得越来越大，路由控制信息的计算也就越来越困难。</p>
<p>所以引入了<strong>区域</strong>的概念</p>
<p>区域是指将连接在一起的网络和主机划分成小组，使一个自治系统内可以拥有多个区域。不过具有多个区域的自治系统必须要有一个主干区域，并且所有其他区域必须都与这个主干区域相连接。</p>
<p>连接区域与主干区域的路由器称作区域边界路由器；而区域内部的路由器叫做内部路由器；只与主干区域内连接的路由器叫做主干路由器；与外部相连接的路由器就是AS边界路由器。</p>
<p>每个区域内的路由器都持有本区域网络拓扑的数据库。然而，关于区域之外的路径消息，只能从区域边界路由器那里获知它们的距离。区域边界路由器也不会将区域内的链路状态信息全部鸳鸯发送给其他区域，只会发送自己到达这些路由器的距离信息，内部路由器所持有的网络拓扑数据库就会明显小很多。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423162411001.png" srcset="/img/loading.gif" lazyload alt="OSPF的路由器种类"></p>
<h3 id="7-6-BGP"><a href="#7-6-BGP" class="headerlink" title="7.6 BGP"></a>7.6 BGP</h3><p>BGP，边界网关协议使连接不同自治系统的一种协议，属于外部网关协议。具体划分，它主要用于ISP之间相连接的部分，只有BGP、RIP、OSPF共同进行路由控制，才能够进行整个互联网的路由控制。</p>
<p><strong>1. BGP与AS号</strong></p>
<p>在RIP和OSPF中利用IP的网络地址部分进行路由控制，然而BGP则需要放眼整个互联网进行路由控制。BGP的最终路由控制表由网络地址和下一站的路由器组来表示，不过它会根据所要经过的AS个数进行路由控制。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423164222584.png" srcset="/img/loading.gif" lazyload alt="BGP使用AS号管理网络信息"></p>
<p>ISP、区域网络等会将每个网络域编配成一个个自治系统进行管理。它们为每一个自治系统分配一个16比特的AS编号。BGP就是根据这个编号进行相应的路由控制。</p>
<p><strong>2. BGP是路径向量协议</strong></p>
<p>根据BGP交换路由控制信息的路由器叫做BGP扬声器。BGP扬声器为了在AS之间交换BGP信息，必须与所有AS建立对等的BGP连接。</p>
<p>如果AS内部有多个BGP扬声器，则也需要建立BGP连接。</p>
<p>BGP中数据包送达目标网络时，会生成一个中途经过所有AS的编号列表。这个表格也叫做AS路径信息访问列表。如果针对同一个目标地址出现多条路径时，BGP会从AS路径信息访问列表中选择一个较短的路由。</p>
<p>在做路由选择的度量的区别：</p>
<p><strong>RIP：路由器个数</strong></p>
<p><strong>OSPF：每个子网的成本</strong></p>
<p><strong>BGP：AS进行度量标准</strong></p>
<p>RIP和OSPF本着提高转发效率为目的，考虑到了网络的跳数和网络的带宽。BGP则基于AS之间的合约进行数据包的转发。BGP一般选择AS数最少的路径，不过仍然要遵循各个AS之间签约的细节进行更细粒度的路由选择。</p>
<p><strong>AS路径信息访问列表中不仅包含转发方向和距离，还涵盖了途径所有AS的编号，对网络构造仅用一元化表示</strong>，所以既不是距离向量型协议，也不是链路状态型协议。<strong>它属于路径向量型协议</strong></p>
<h3 id="7-7-MPLS"><a href="#7-7-MPLS" class="headerlink" title="7.7 MPLS"></a>7.7 MPLS</h3><p>在转发IP数据包的过程中除了使用路由技术外，还在使用<strong>标记交换技术</strong>。</p>
<p>路由技术基于IP地址中最长匹配原则进行转发，而标记交换则对每个IP包都设定一个叫做“标记”的值，然后根据这个“标记”再进行转发。</p>
<p>标记交换技术中最具代表性的是<strong>多协议标记交换技术</strong>，即MPLS</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424144727819.png" srcset="/img/loading.gif" lazyload alt="IP网络中转发"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424144744169.png" srcset="/img/loading.gif" lazyload alt="MPLS中转发"></p>
<p><strong>1. MPLS的网络基本动作</strong></p>
<p>实现MPLS功能的路由器叫做<strong>标记交换路由器</strong>（LSR）。</p>
<p>与外部网络连接的那部分LSR叫做<strong>标记边缘路由器</strong>（LER）。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424150628665.png" srcset="/img/loading.gif" lazyload alt="使用Push、Swap和Pop功能进行转发"></p>
<p>在其IP首部的前面被追加了32比特的垫片头。在MPLS网络内，根据垫片头中的标记进一步进行转发。当数据离开MPLS时，垫片头就被去除。</p>
<p>附加标记转发的动作为<strong>Push</strong></p>
<p>替换标记转发的动作为<strong>Swap</strong></p>
<p>去掉标记转发的动作为<strong>Pop</strong></p>
<p>MPLS中目标地址和数据包都要通过由标记决定的同一个路径，这个路径叫做<strong>标记交换路径（LSP）</strong>。</p>
<p>LSP属于单方向的通路，如果需要双向的通信则需要两个LSP。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424151839742.png" srcset="/img/loading.gif" lazyload alt="LSP设置"></p>
<p><strong>2. MPLS的优点</strong></p>
<p>MPLS的优势有两点</p>
<p>（1）转发速度快：路由器转发IP数据包时，首先要对目标地址和路由控制表中可变长的网络地址进行比较，然后从中选出最长匹配的路径才能进行转发。MPLS则是使用固定长度的标记信息，使得处理更加简单，可以通过高速的硬件实现转发。</p>
<p>（2）利用标记生成虚拟的路径，并在它的上面实现IP等数据包的通信。基于这些特点，被称之为“尽力而为”的IP网也可以提供基于MPLS的通信质量控制、带宽保证和VPN等功能。</p>
<h2 id="第8章-应用协议"><a href="#第8章-应用协议" class="headerlink" title="第8章 应用协议"></a>第8章 应用协议</h2><h3 id="8-1-应用层协议概要"><a href="#8-1-应用层协议概要" class="headerlink" title="8.1 应用层协议概要"></a>8.1 应用层协议概要</h3><p>利用网络的应用程序有很多，包括Web浏览器，电子邮件，远程登录，文件传输，网络管理等。能够让这些应用进行特定通信处理的正是应用协议。</p>
<p>网络应用由不同的用户和软件供应商开发而成。为了实现网络应用的功能，在应用之间进行通信时将其连接的网络协议是非常重要的。</p>
<h3 id="8-2-远程登录"><a href="#8-2-远程登录" class="headerlink" title="8.2 远程登录"></a>8.2 远程登录</h3><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424155036191.png" srcset="/img/loading.gif" lazyload alt="远程登录"></p>
<p>远程登录是为了实现TSS环境，是将主机和终端的关系应用到计算机网络上的一个结果。远程登录主要使用TELNET和SSH两种协议。</p>
<p><strong>1. TELNET</strong></p>
<p>TELNET利用TCP的一条连接，通过这一条连接向主机发送文字命令并在主机上执行。本地用户好像直接与远端主机内部的shell相连着似的，直接在本地进行操作。</p>
<p>TELNET可以分为两类基本服务。一是仿真终端功能，二是协商选项机制。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424155950101.png" srcset="/img/loading.gif" lazyload alt="TELNET"></p>
<p>TELNET经常用于登录路由器或高性能交换机等网络设备进行相应的设置。</p>
<p>TELNET中除了处理用户所输入的文字外，还提供选项的交互和协商功能。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424190431615.png" srcset="/img/loading.gif" lazyload alt="行模式与透明模式"></p>
<p>TELNET客户端是指利用TELNET协议实现远程登录的客户端程序</p>
<p>TELNET客户端通常与目标主机的23号端口建立连接，并与监听这个端口的服务端程序telented进行交互。</p>
<p>一般的telnet命令中可以按照如下格式进行指定端口号：</p>
<p>telnet  主机名 TCP端口号</p>
<p>TCP端口号为21时可以连接到FTP应用，为25时可以连接到SMTP</p>
<p>为80时可以连接到HTTP，为110时可连接到POP3</p>
<p><strong>2. SSH</strong></p>
<p>SSH是加密的远程登录系统。</p>
<p>TELNET中登录时无需输入密码就可以发送，容易造成通信窃听和非法入侵的危险。使用SSH后可以加密通信内容，即使信息被窃听也无法破解所发送的密码，具体命令以及命令返回的结果是什么。</p>
<p>功能：</p>
<p>（1）可以使用更强的认证机制</p>
<p>（2）可以转发文件</p>
<p>（3）可以使用端口转发功能</p>
<p>端口转发是指将特定端口号所收到的消息转发到特定的IP地址和端口号码的一种机制。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424191236842.png" srcset="/img/loading.gif" lazyload alt="SSH的端口转发"></p>
<h3 id="8-3-文件传输"><a href="#8-3-文件传输" class="headerlink" title="8.3 文件传输"></a>8.3 文件传输</h3><p>FTP是在两个相连的计算机之间进行文件传输时使用的协议。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424191400493.png" srcset="/img/loading.gif" lazyload alt="文件传输FTP"></p>
<p>FTP中也需要登录到对方的计算机后才能进行相应的操作</p>
<p><strong>FTP的工作机制概要</strong></p>
<p>使用两条TCP连接：一条用来控制，另一条用于数据的传输</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424191906902.png" srcset="/img/loading.gif" lazyload alt="FTP机制"></p>
<p>用于控制的TCP连接主要在FTP的控制部分使用。</p>
<p>例如登录用户名和密码的验证、发送文件的名称、发送方式的设置。</p>
<p>利用这个连接，可以通过ASCII码字符串发送请求和接收应答。在这个连接上无法发送数据，数据需要一个专门的TCP进行连接。</p>
<p>FTP控制用的连接使用的是TCP21号端口。</p>
<p><strong>在TCP21号端口上进行文件GET（RETR）、PUT(STOR)、以及文件一览（LIST）等操作时，每次都会建立一个用于数据传输的TCP连接。数据的传输和文件一览表的传输正是在这个新建的连接上进行。当数据传送完毕之后，传输数据的这条连接也会被断开，然后会在控制用的连接上继续进行命令或应答的处理</strong>。</p>
<p>用于数据传输的TCP连接是按照与控制用的连接相反的方向建立的。因此，在通过NAT连接外部FTP服务器的时候，无法直接建立传输数据时使用的TCP连接。此时，必须使用PASV命令修改建立连接的方向才行。</p>
<p><strong>通过ASCII码字符串进行的交互处理</strong></p>
<p>FTP中请求命令中使用着“RETR”等ASCII码字符串。而针对这些命令的应答则使用如”200”等3位数字的ASCII码字符串。</p>
<p>FTP主要的命令</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195100027.png" srcset="/img/loading.gif" lazyload alt="FTP主要命令"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195121377.png" srcset="/img/loading.gif" lazyload alt="传输参数的命令"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195222401.png" srcset="/img/loading.gif" lazyload alt="FTP服务命令"></p>
<p>FTP的主要应答消息</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195253403.png" srcset="/img/loading.gif" lazyload alt="提供信息"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195305402.png" srcset="/img/loading.gif" lazyload alt="连接管理相关应答"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195328619.png" srcset="/img/loading.gif" lazyload alt="连接管理相关应答（续）"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195355180.png" srcset="/img/loading.gif" lazyload alt="其他应答"></p>
<h3 id="8-4-电子邮件"><a href="#8-4-电子邮件" class="headerlink" title="8.4 电子邮件"></a>8.4 电子邮件</h3><p><strong>1. 电子邮件的工作机制</strong></p>
<p>提供电子邮件服务的协议叫做SMTP</p>
<p>SMTP为了实现高效发送邮件内容，在其传输层使用了TCP协议</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195617227.png" srcset="/img/loading.gif" lazyload alt="早期的电子邮件发送过程"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195658276.png" srcset="/img/loading.gif" lazyload alt="现代电子邮件发送过程"></p>
<p>为此，在技术上改变了以往直接在发送端与接收端主机之间建立TCP连接的机制，而引进了一种一直会连接电源的邮件服务器。发送和接收端通过邮件服务器进行收发邮件，接收端从邮件服务器接收邮件时使用POP3协议。</p>
<p>电子邮件的机制由3部分组成：邮件地址、数据格式以及发送协议</p>
<p><strong>2. 邮件地址</strong></p>
<p>电子邮件的发送地址由DNS进行管理。</p>
<p>DNS中注册有邮件地址及其作为发送地址时对应的邮件服务器的域名。</p>
<p>这些映射信息被称作MX记录，可以管理不同邮件地址与特定邮件服务器之间的映射关系。</p>
<p><strong>3. MIME</strong></p>
<p>MIME用于扩展电子邮件中的文本、图片、音频、视频等数据类型。</p>
<p>它定义了一套规则，允许电子邮件和其他应用程序在传输数据时能够识别和处理不同类型的数据。</p>
<p>MIME基本上由首部和正文两部分组成。首部不能是空行，因为一旦出现空行，其后的部分将被视为正文。</p>
<p>MIME具有代表性的Content-Type：</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424200452301.png" srcset="/img/loading.gif" lazyload alt="Content-Type"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424200512290.png" srcset="/img/loading.gif" lazyload alt="MIME举例"></p>
<p><strong>4. SMTP</strong></p>
<p>SMTP是发送电子邮件的协议，使用的是TCP的25号端口。</p>
<p>SMTP建立一个TCP连接以后，在这个连接上进行控制和应答以及数据的发送。客户端以文本的形式发出请求，服务端返回一个3位数字的应答。</p>
<p><strong>SMTP的主要命令</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424200908976.png" srcset="/img/loading.gif" lazyload alt="SMTP的主要命令"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424203955674.png" srcset="/img/loading.gif" lazyload alt="SMTP"></p>
<p>随着电子邮件使用的普及，那些漫天的广告邮件和包含钓鱼连接的垃圾邮件成为了日益严重的问题。</p>
<p>所以需要验证发送者的功能，<strong>“POP before SMTP”或”SMTP认证“</strong></p>
<p><strong>SMTP应答</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424204448940.png" srcset="/img/loading.gif" lazyload alt="针对请求进行肯定确认应答"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424204516896.png" srcset="/img/loading.gif" lazyload alt="数据输入"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424204538919.png" srcset="/img/loading.gif" lazyload alt="发送错误消息"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424204558824.png" srcset="/img/loading.gif" lazyload alt="无法继续处理的错误应答"></p>
<p><strong>5. POP</strong></p>
<p>个人电脑不可能长时间处于开机状态。只有用户在使用时才会开机。在这种情况下，人们希望一开机就能接收到邮件。然而SMTP没有这种处理机制。SMTP的一个不利之处就在于它支持的是发送端主机的行为，而不是根据接收端的请求发送邮件。</p>
<p>为了解决这个问题，就引入了<strong>POP协议</strong>。</p>
<p>该协议使一种用于接收电子邮件的协议。发送端的邮件根据SMTP协议将被转发给一直处于插电状态的POP服务器。客户端再根据POP协议从POP服务器接收对方发来的邮件。在这个过程中，为了防止他人盗窃邮件内容，还要进行用户验证。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424205123336.png" srcset="/img/loading.gif" lazyload alt="POP的工作机制"></p>
<p>POP与SMTP一样，也是在其客户端与服务器之间通过建立一个TCP连接完成相应操作。</p>
<p><strong>POP主要命令</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424205244890.png" srcset="/img/loading.gif" lazyload alt="认证时的有效命令"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424205311744.png" srcset="/img/loading.gif" lazyload alt="应答"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424205322706.png" srcset="/img/loading.gif" lazyload alt="事务状态命令"></p>
<p><strong>6. IMAP</strong></p>
<p>IMAP与POP类似，也是接收电子邮件的协议。</p>
<p><strong>优势：</strong></p>
<p>（1）使用IMAP时，可以不必从服务器上下载所有的邮件也可以阅读</p>
<p>（2）IMAP是在服务器端处理MIME信息，所以它可以实现当某一封邮件含有10个附件时“只下载其中的第7个附件”的功能。这在带宽较窄的线路上起着非常重要的作用。而且IMAP在服务器上对“已读/未读”信息和邮件分类进行管理，因此，即使在不同的计算机上打开邮箱，也能保持同步，为使用多种异构终端的人们提供了非常便利的环境。</p>
<h3 id="8-5-WWW"><a href="#8-5-WWW" class="headerlink" title="8.5 WWW"></a>8.5 WWW</h3><p><strong>1. 互联网的蓬勃发展</strong></p>
<p>万维网是将互联网中的信息以超文本形式展现的系统，也叫做Web。</p>
<p>借助浏览器，不需要考虑该信息保存在哪个服务器，只需要轻轻点击鼠标就可以访问页面上的链接并打开相关信息。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424210206129.png" srcset="/img/loading.gif" lazyload alt="WWW"></p>
<p><strong>2. WWW基本概念</strong></p>
<p>WWW定义了3个重要的概念，分别是访问信息的手段与位置（URI）、信息的表现形式（HTML）、信息转发（HTTP）</p>
<p><strong>3. URI</strong></p>
<p>URI用于标识资源，是一种可以用于WWW之外的高效的识别码，它被用于主页地址、电子邮件、电话号码等各种组合中。</p>
<p>URI所表示的组合叫方案（Scheme）</p>
<p>URI的http方案的具体格式如下：</p>
<p><a target="_blank" rel="noopener" href="http://主机名/路径">http://主机名/路径</a></p>
<p><a href="http://主机名：端口号/路径">http://主机名：端口号/路径</a></p>
<p><a href="http://主机名：端口号/路径？访问内容#部分信息">http://主机名：端口号/路径？访问内容#部分信息</a></p>
<p>其中主机名表示域名或IP地址，端口号表示传输端口号。</p>
<p>省略端口号时，则表示采用http的默认端口号80</p>
<p><strong>URI的主要方案</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424210905915.png" srcset="/img/loading.gif" lazyload alt="主要的URI方案"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424210927755.png" srcset="/img/loading.gif" lazyload alt="主要的URI方案（续）"></p>
<p><strong>4. HTML</strong></p>
<p>HTML是记述Web页的一种语言。它可以指定浏览器中显示的文字、文字的大小和颜色。此外，不仅可以对图像或动画进行相关设置，还可以设置音频内容。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424211145136.png" srcset="/img/loading.gif" lazyload alt="HTML举例"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424211200527.png" srcset="/img/loading.gif" lazyload alt="浏览器读取并显示内容"></p>
<p><strong>5. HTTP</strong></p>
<p>当用户在浏览器的地址栏里输入所要访问Web页的URI以后，HTTP的处理即会开始。</p>
<p>HTTP中默认使用80端口，它的工作机制，首先是客户端向服务器的80端口建立一个TCP连接，然后在这个TCP连接上进行请求和应答以及数据报文的发送。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424211415045.png" srcset="/img/loading.gif" lazyload alt="HTTP的工作机制"></p>
<p>HTTP中常用的有两个版本，一个HTTP1.0，另一个是HTTP1.1</p>
<p>在HTTP1.0中每一个命令和应答都会触发一次TCP连接的建立和断开，而从HTTP1.1开始，允许在一个TCP连接上发送多个命令和应答。由此，大量地减少了TCP连接的建立和断开操作，从而也提高了效率。</p>
<p><strong>HTTP的主要命令</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424212229111.png" srcset="/img/loading.gif" lazyload alt="HTTP的主要命令"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424212245032.png" srcset="/img/loading.gif" lazyload alt="信息传递"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424212303044.png" srcset="/img/loading.gif" lazyload alt="肯定应答"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424212317081.png" srcset="/img/loading.gif" lazyload alt="重定向请求"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424212333631.png" srcset="/img/loading.gif" lazyload alt="客户端请求内容出现错误"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424212357294.png" srcset="/img/loading.gif" lazyload alt="服务器错误"></p>
<p><strong>6. JavaScript、CGI、Cookie</strong></p>
<p><strong>JavaScript</strong></p>
<p>Web的基本要素是URI、HTML、HTTP</p>
<p>但是仅有这些还无法更改与条件相符的动态内内容，所以引入Javascript</p>
<p>Javascript是一种嵌入在HTML中的编程语言。作为客户端程序可以运行于多种类型的浏览器中，这些浏览器将嵌入JavaScript的HTML下载后，其对应的JavaScript程序就可以在客户端得到执行。这种JavaScript程序用于验证客户端输入字符串是否过长、是否填写或选择了页面中的必须选项等功能。</p>
<p>JavaScript还可以用于操作HTML或XML的逻辑结构以及动态显示Web页的内容和页面风格上。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424212855634.png" srcset="/img/loading.gif" lazyload alt="JavaScript、CGI的处理"></p>
<p><strong>CGI</strong></p>
<p>CGI是Web服务器调用外部程序时所使用的一种服务端应用的规范。</p>
<p>一般的Web通信中，只是按照客户端请求将保存在Web服务器硬盘中的数据转发而已。这种情况下客户端每次收获的信息也是同样的内容。而引入CGI以后客户端请求会触发Web服务器运行另一个程序，客户端所输入的数据也会传给这个外部程序。该程序运行结束后会将生成的HTML和其他数据再返回给客户端。</p>
<p>利用CGI可以针对用户的操作返回给客户端的有各种各样的变化的信息。论坛和网上购物系统中就经常使用CGI调用外部程序或访问数据库。</p>
<p><strong>Cookie</strong></p>
<p>Web应用中为了获取用户信息使用一个叫做Cookie的机制。Web服务器用Cookie在客户端保存信息。</p>
<p>Cookie常被用于保存登录信息或网络购物中放入购物车的商品信息。</p>
<p>从Web服务器检查Cookie可以确认是否为同一对端的通信，从而存放于购物车里的商品信息就不必要在保存到服务器了。</p>
<h3 id="8-6-网络管理"><a href="#8-6-网络管理" class="headerlink" title="8.6 网络管理"></a>8.6 网络管理</h3><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426150045435.png" srcset="/img/loading.gif" lazyload alt="网络管理"></p>
<p>以前网络管理是凭借管理员的记忆和直觉进行。然而随着网络规模变得越来越大，个人的记忆、经验或直觉已经无法与之匹配，需要一个严密的管理工具或方法。所以在TCP/IP的网络管理中可以使用<strong>SNMP</strong>收集必要的信息。它是一款基于UDP/IP的协议。</p>
<p><strong>SNMP中管理端叫做管理器，被管理端叫做代理（路由器、交换机等）</strong></p>
<p>但是存在安全隐患，所以在SNMPv3集合了所有SNMP的功能于同一个版本，定义了个人的功能模块，并可以结合各种不同版本进行通信。</p>
<p><strong>1. SNMP工作机制</strong></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426150548343.png" srcset="/img/loading.gif" lazyload alt="SNMP工作机制"></p>
<p><strong>查询请求和应答</strong>可以定期检查设备的运行动作</p>
<p><strong>设置请求</strong>可以修改设备的参数</p>
<p>SNMP的处理可以分为从设备读取数据和向设备写入数据两种。它们采用Fetch和Store模式。</p>
<p>出于某种原因网络设备的状况发生变化，将这个变化通知给SNMP管理器时就可以使用Trap。有了Trap，即使没有管理器到代理的请求，也能在设备发生变化时收到从代理发来的通知。</p>
<p><strong>2. MIB</strong></p>
<p>SNMP中交互的信息是MIB。MIB是在树形结构的数据库中为每个项目附加编号的一种信息结构。SNMP访问MIB信息时使用数字序列。</p>
<p>SNMP中可以将MIB值写入代理，也可以从代理中读取MIB值，通过这些操作可以手机冲突的次数和流量统计等信息，可以修改接口的IP地址，还可以进行路由器的启停、设备的启动和关闭等处理。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426151623903.png" srcset="/img/loading.gif" lazyload alt="MIB树举例"></p>
<p><strong>3. RMON</strong></p>
<p>RMON是Remote Monitoring MIB的缩写。MIB由监控网络中某个设备接口的众多参数构成。相比之下，RMON则由监控网络上线路的众多参数构成。</p>
<p><strong>RMON可以监控某个特定的主机在哪里通过什么样的协议正在与谁进行通信的统计信息，可以更加详细地了解网络上成为负荷的主机并进行后续分析</strong></p>
<p><strong>RMON中从当前使用状况到通信方向性位置，可以以终端为单位也可以以协议为单位进行监控</strong></p>
<h3 id="8-7-其他应用层协议"><a href="#8-7-其他应用层协议" class="headerlink" title="8.7 其他应用层协议"></a>8.7 其他应用层协议</h3><p><strong>1. 多媒体通信实现技术</strong></p>
<p><strong>H.323</strong></p>
<p>H.323是由ITU开发用于在IP网上传输音频，视频的一种协议。</p>
<p>H.323定义了4个主要组件：终端（用户终端）、网关（吸收用户数据压缩顺序的不一致性）、网闸（电话本管理、呼叫管理）以及多点控制单元（允许多个终端同时使用）</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426153313525.png" srcset="/img/loading.gif" lazyload alt="H.323的基本构成"></p>
<p><strong>SIP</strong></p>
<p>终端之间进行多媒体通信时，需要具备事先先解析对方地址、呼出对方号码并对所要传输的媒体信息进行处理等功能。此外，还需要具备中断会话和数据转发的功能。这些功能都被统一于SIP协议中。</p>
<p>通过终端之间收发消息，可以令SIP进行呼叫控制并做一些多媒体通信中必要的准备。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426154101270.png" srcset="/img/loading.gif" lazyload alt="SIP基本组成"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426154131556.png" srcset="/img/loading.gif" lazyload alt="通过SIP服务器的呼叫控制的顺序"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426154155419.png" srcset="/img/loading.gif" lazyload alt="主要SIP命令"></p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426154214759.png" srcset="/img/loading.gif" lazyload alt="主要SIP响应消息"></p>
<p><strong>RTP</strong></p>
<p>RTP用来对UDP实现实时的多媒体通信附加一个表示报文顺序的序列号字段，对报文发送时间进行管理。</p>
<p>RTP为每个报文附加时间戳和序列号。接收报文的应用，根据时间戳决定数据重构的时机。序列号则根据每发出一次报文加一的原则进行累加。RTP使用这个序列号对同一时间戳的数据进行排序，掌握是否有丢包情况发生。</p>
<p><strong>RTCP</strong>是辅助RTP的一种协议，通过丢包率等线路质量的管理，对RTP的数据传送率进行控制。</p>
<p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426154912852.png" srcset="/img/loading.gif" lazyload alt="RTP通信"></p>
<p><strong>数字压缩技术</strong></p>
<p>通过有效的压缩可以大量减少音频和视频数据的大小。在有限的网络资源中进行多媒体数据的传输，压缩技术成为一个必要的手段。</p>
<p>MPEG是决定数字压缩规范的ISO/IEC工作组。在这里所指定的规范叫做MPEG。在MPEG的众多规范中，MPEG1主要用于VideoCD，而MPEG2主要用于DVD和数字电视播放领域。此外还有MPEG4,MPEG7……</p>
<p><strong>2. P2P</strong></p>
<p>互联网上电子邮件的通信，普遍属于一台服务器对应多个客户端的C/S模式，即1对N的通信形态。</p>
<p>网络上的终端或主机不经服务器直接1对1相互通信的情况叫做P2P。</p>
<p><strong>3. LDAP</strong></p>
<p>LDAP是访问目录服务的一种协议，也叫做轻量级目录访问协议。</p>
<p><strong>目录服务是网络上存在的一种提供相关资源的数据库的服务</strong></p>
<p>LDAP用于访问这种目录服务，为了更简单的管理网络上的各种资源。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>图解TCP/IP协议学习</div>
      <div>http://sugar-122.github.io/2023/03/29/图解TCPIP协议学习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Sugar</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月29日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/04/09/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E4%B8%8E%E8%AE%A4%E8%AF%81%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" title="散列函数与认证、数字签名">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">散列函数与认证、数字签名</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/03/29/python%E5%AE%9E%E7%8E%B0LSB%E7%AE%97%E6%B3%95/" title="python实现LSB算法">
                        <span class="hidden-mobile">python实现LSB算法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
