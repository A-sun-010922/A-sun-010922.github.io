<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>利用dirtycow（CVE-2016-5195）漏洞实现docker escape</title>
    <link href="/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/"/>
    <url>/2023/03/03/%E5%88%A9%E7%94%A8dirtycow%EF%BC%88CVE-2016-5195%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0docker%20escape/</url>
    
    <content type="html"><![CDATA[<h3 id="利用dirtycow（CVE-2016-5195）漏洞实现docker-escape"><a href="#利用dirtycow（CVE-2016-5195）漏洞实现docker-escape" class="headerlink" title="利用dirtycow（CVE-2016-5195）漏洞实现docker escape"></a>利用dirtycow（CVE-2016-5195）漏洞实现docker escape</h3><h4 id="1-dirtycow简要介绍"><a href="#1-dirtycow简要介绍" class="headerlink" title="1.dirtycow简要介绍"></a>1.dirtycow简要介绍</h4><blockquote><p>Dirty Cow（CVE-2016-5195）是Linux内核中的权限提升漏洞，源于Linux内核的内存子系统在处理写入时拷贝（copy-on-write, Cow）存在竞争条件（race condition），允许恶意用户提权获取其他只读内存映射的写访问权限。</p></blockquote><h4 id="2-dirtycow具体机制"><a href="#2-dirtycow具体机制" class="headerlink" title="2.dirtycow具体机制"></a>2.dirtycow具体机制</h4><p>Cow机制：</p><blockquote><p>以只读模式打开文件A，返回文件表示符号fd，将文件映射到内存，标记为MAP_PRIVATE，MAP_PRIVATE是一个copy-on-write的映射方式。尽管它也是有backend的，但在写入数据时，他会在物理内存copy一份数据出来(以页为单位)，而且这些数据是不会被回写到文件的。我们想要对一个只有只读权限的文件进行写操作，会经历以下的流程。</p></blockquote><p><img src="/image-20230105144117608.png" alt="image-20230105144117608"></p><h5 id="2-1-第一次循环"><a href="#2-1-第一次循环" class="headerlink" title="2.1 第一次循环"></a>2.1 第一次循环</h5><p><strong>第一次循环</strong>：首先他会调用**__get_user_pages( )<strong>函数，进入第一次循环：通过给定的虚拟地址</strong>address<strong>，去查询相应的页表和页表项</strong>follow_page( )<strong>，发现页表和页表项目均为空，说明还没有加载过该页</strong>handle_mm_fault( )<strong>，进入进程缺页处理</strong>handle_pte_fault( )<strong>，由于对应物理页没有在内存，并且</strong>pte<strong>为空，说明之前没有加载过该页，又因为这是一个基于文件的映射,所以接下来会调用</strong>do_fault( )<strong>函数，</strong>do_fault( )**函数的具体响应方式如下。</p><p><img src="/image-20230105144452945.png" alt="image-20230105144452945"></p><p>显然这里我们是因为第二种情况造成的缺页异常，所以接下来会调用<strong>do_cow_fault( )<strong>将分配的新页与</strong>PTE</strong>建立映射，并且把内容读取到当前新分配的页内，也就是说当前的<strong>pte</strong>执行的是<strong>cowed page</strong>，此时<strong>cow page</strong>属于匿名页，并且<strong>present&#x3D;1，dirty&#x3D;1,read-only&#x3D;1</strong>，还是不可写（应用程序动态分配的堆内存称为匿名页（<strong>Anonymous Page</strong>）。</p><h5 id="2-2-第二次循环"><a href="#2-2-第二次循环" class="headerlink" title="2.2 第二次循环"></a>2.2 第二次循环</h5><p><strong>第二次循环：</strong>第一次循环完毕之后，系统再次调用<strong>follow_page( )<strong>函数，再次请求物理页，这一次页表和页表项都不为空，但是由于我们想进行写访问，但是对于</strong>vma</strong>属性为<strong>read-only</strong>，请求页失败，进入循环进行缺页处理，<strong>handle_pte_fault( )：</strong>通过此函数执行写时复制，分配新的<strong>page</strong>，拷贝旧<strong>page</strong>到新<strong>page</strong>, 并修改相应的页表项为读写。在获取旧的<strong>page</strong>的时候判断是否是匿名页，如果是匿名页，判断是否只有一个进程在引用该页或，如果是，则直接<strong>reuse old page</strong>，并尝试设置<strong>old page</strong> 标记为可写，并返回<strong>VM_FAULT_WRITE</strong>。否则需要新分配一个页作为<strong>cowed page</strong>，并返回<strong>VM_FAULT_WRITE</strong>。在循环中，如果检测到返回值为<strong>VM_FAULT_WRITE</strong>，为去掉请求访问<strong>FOLL_WRITE</strong>标志。</p><h5 id="2-3-第三次循环"><a href="#2-3-第三次循环" class="headerlink" title="2.3 第三次循环"></a>2.3 第三次循环</h5><p><strong>第三次循环：</strong>第二次循环完毕之后，再次调用<strong>follow_page( )<strong>函数，再次请求物理页，第二次请求的时候返回</strong>VM_FAULT_WRITE</strong>，去掉了<strong>FOLL_WRITE</strong>标记，这个时候<strong>PTE</strong>存在，权限也满足，故可以进行写的操作，此时的页是拷贝的副本。</p><h4 id="3-漏洞存在"><a href="#3-漏洞存在" class="headerlink" title="3. 漏洞存在"></a>3. 漏洞存在</h4><p>正常的Cow机制看似没有问题，但是由于竞态条件的存在，上面的操作不是原子的，尝试假设下面的一个情形：如果我们在第二次循环完毕之后，如果立刻使用<strong>madvise</strong>这个系统调用，释放掉刚刚分配好的拷贝页，释放掉内存是会清空页表和页表项的！！！则在第三次循环的时候，本该进行正常访问的时候，由于拷贝页已经被我们释放掉，所以说它会再进行一次页的分配，但是这个时候由于第二次循环，<strong>FOLL_WRITE</strong>标志已经被清除了，所以这个时候会被认为是读访问，所以此时分配的将会是原始页。所以这个漏洞的存在就使得我们可以对只读文件进行一个写的操作。</p><h4 id="4-逃逸思路：vdso-dirty-cow"><a href="#4-逃逸思路：vdso-dirty-cow" class="headerlink" title="4. 逃逸思路：vdso+dirty-cow"></a>4. 逃逸思路：<strong>vdso+dirty-cow</strong></h4><p><strong>dirty cow</strong>漏洞可以让我们获取只读内存的写的权限，我们首先利用<strong>dirty cow</strong>漏洞写入一段<strong>shellcode</strong>到<strong>VDSO</strong>映射的一段闲置内存中，然后改变函数的执行顺序，使得调用正常的任意函数之前都要执行这段<strong>shellcode</strong>。这段<strong>shellcode</strong>初始化的时候会检查是否是被<strong>root</strong>调用，如果是则继续执行，如果不是，则接着执行<strong>clock_gettime</strong>函数，接下来它会检测**&#x2F;tmp&#x2F;.X<strong>文件的存在，如果存在，则这时已经是</strong>root<strong>权限了，然后它会打开一个反向的</strong>TCP<strong>链接，为</strong>Shellcode<strong>中填写的</strong>IP<strong>返回一个</strong>Shell**。</p><h4 id="5-实验结果"><a href="#5-实验结果" class="headerlink" title="5. 实验结果"></a>5. 实验结果</h4><p>内核版本：<strong>3.13.0-85-generic</strong></p><p>Docker版本：<strong>17.03.0-ce</strong></p><p>Docker镜像：<strong>ppabc&#x2F;cve-2016-5195</strong></p><p><img src="/image-20230105144527454.png" alt="image-20230105144527454"></p><p>​                                                                                                          内核版本</p><p><img src="/image-20230105144542830.png" alt="image-20230105144542830"></p><p>​                                                                                                          docker版本</p><p><img src="/image-20230105144559014.png" alt="image-20230105144559014"></p><p>​docker镜像</p><p>进入docker</p><p><img src="/image-20230105144614964.png" alt="image-20230105144614964"></p><p>编译攻击程序0xdeadbeef</p><p><img src="/image-20230105144628454.png" alt="image-20230105144628454"></p><p>运行0xdeadbeef</p><p><img src="/image-20230105144638823.png" alt="image-20230105144638823"></p><p>此时已经获取了宿主机的root权限的shell，逃逸完毕</p><p><img src="/image-20230105144654254.png" alt="image-20230105144654254"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes简要学习</title>
    <link href="/2023/03/03/Kubernetes%E5%AD%A6%E4%B9%A0%E6%90%AC%E8%BF%90/"/>
    <url>/2023/03/03/Kubernetes%E5%AD%A6%E4%B9%A0%E6%90%AC%E8%BF%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes介绍"><a href="#Kubernetes介绍" class="headerlink" title="Kubernetes介绍"></a>Kubernetes介绍</h1><h2 id="1-Kubernetes-可以为你做些什么"><a href="#1-Kubernetes-可以为你做些什么" class="headerlink" title="1. Kubernetes 可以为你做些什么?"></a>1. Kubernetes 可以为你做些什么?</h2><p>通过现代的 Web 服务，用户希望应用程序能够 24&#x2F;7 全天候使用，开发人员希望每天可以多次发布部署新版本的应用程序。 容器化可以帮助软件包达成这些目标，使应用程序能够以简单快速的方式发布和更新，而无需停机。Kubernetes 帮助你确保这些容器化的应用程序在你想要的时间和地点运行，并帮助应用程序找到它们需要的资源和工具。Kubernetes 是一个可用于生产的开源平台，根据 Google 容器集群方面积累的经验，以及来自社区的最佳实践而设计。</p><h2 id="2-Kubernetes-基础模块"><a href="#2-Kubernetes-基础模块" class="headerlink" title="2. Kubernetes 基础模块"></a>2. Kubernetes 基础模块</h2><blockquote><p>1.创建一个Kubernetes集群</p><p>2.部署应用程序</p><p>3.应用程序探索</p><p>4.应用外部可见</p><p>5.应用可拓展</p><p>6.应用更新</p></blockquote><h3 id="2-1-创建一个Kubernetes集群"><a href="#2-1-创建一个Kubernetes集群" class="headerlink" title="2.1 创建一个Kubernetes集群"></a>2.1 创建一个Kubernetes集群</h3><p>使用Minikube创建集群</p><p>Kubernetes 集群</p><p><strong>Kubernetes 协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作。</strong> Kubernetes 中的抽象允许你将容器化的应用部署到集群，而无需将它们绑定到某个特定的独立计算机。为了使用这种新的部署模型，应用需要以将应用与单个主机分离的方式打包：它们需要被容器化。与过去的那种应用直接以包的方式深度与主机集成的部署模型相比，容器化应用更灵活、更可用。 <strong>Kubernetes 以更高效的方式跨集群自动分发和调度应用容器。</strong> Kubernetes 是一个开源平台，并且可应用于生产环境。</p><p>一个 Kubernetes 集群包含两种类型的资源: </p><p><strong>Master</strong>：调度整个集群</p><p><strong>Nodes</strong>：负责运行应用</p><p>集群图</p><p><img src="/image-20230112135905265.png" alt="image-20230112135905265"></p><p><strong>Master 负责管理整个集群。</strong> Master 协调集群中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。</p><p><strong>Node 是一个虚拟机或者物理机，它在 Kubernetes 集群中充当工作机器的角色</strong> 每个Node都有 Kubelet , 它管理 Node 而且是 Node 与 Master 通信的代理。 Node 还应该具有用于处理容器操作的工具，例如 Docker 或 rkt 。处理生产级流量的 Kubernetes 集群至少应具有三个 Node，因为如果一个 Node 出现故障其对应的 etcd 成员和控制平面实例都会丢失，并且冗余会受到影响。 你可以通过添加更多控制平面节点来降低这种风险 。</p><p>在 Kubernetes 上部署应用时，你告诉 Master 启动应用容器。 Master 就编排容器在集群的 Node 上运行。 <strong>Node 使用 Master 暴露的 Kubernetes API 与 Master 通信。</strong>终端用户也可以使用 Kubernetes API 与集群交互。</p><p>Kubernetes 既可以部署在物理机上也可以部署在虚拟机上。你可以使用 Minikube 开始部署 Kubernetes 集群。 Minikube 是一种轻量级的 Kubernetes 实现，可在本地计算机上创建 VM 并部署仅包含一个节点的简单集群。 Minikube 可用于 Linux ， macOS 和 Windows 系统。Minikube CLI 提供了用于引导集群工作的多种操作，包括启动、停止、查看状态和删除。</p><h3 id="2-2-Kubernetes部署"><a href="#2-2-Kubernetes部署" class="headerlink" title="2.2 Kubernetes部署"></a>2.2 Kubernetes部署</h3><p>一旦运行了 Kubernetes 集群，就可以在其上部署容器化应用程序。 为此，你需要创建 Kubernetes <strong>Deployment</strong> 配置。Deployment 指挥 Kubernetes 如何创建和更新应用程序的实例。创建 Deployment 后，Kubernetes master 将应用程序实例调度到集群中的各个节点上。</p><p>创建应用程序实例后，Kubernetes Deployment 控制器会持续监视这些实例。 如果托管实例的节点关闭或被删除，则 Deployment 控制器会将该实例替换为集群中另一个节点上的实例。 <strong>这提供了一种自我修复机制来解决机器故障维护问题。</strong></p><p>在没有 Kubernetes 这种编排系统之前，安装脚本通常用于启动应用程序，但它们不允许从机器故障中恢复。通过创建应用程序实例并使它们在节点之间运行， Kubernetes Deployments 提供了一种与众不同的应用程序管理方法。</p><p>以上均是资源搬运，便于笔者记录</p><p>原网址：<a href="https://kubernetes.io/zh-cn/docs/home/">Kubernetes 文档 | Kubernetes</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
